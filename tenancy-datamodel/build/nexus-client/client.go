// SPDX-FileCopyrightText: (C) 2025 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

// Code generated by nexus. DO NOT EDIT.

// Nexus client is a shim layer working over k8s API meant to simplify graph operation on nexus nodes.
// Features of nexus client:
// - create/get/update/delete/list of nexus nodes,
// - name hashing to avoid name collision between objects with same name but different parents,
// - ability to get, create and delete child of given parent object,
// - ability to add link and remove link to given object,
// - recursive delete of object and all it's children.
// To initialize client use NewForConfig function with Rest Config as a parameter. After that you can start using
// nexus client. You can check example in: https://gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/docs/-/tree/master/example/crudapp

package nexus_client

import (
	"context"
	"encoding/json"
	customerrors "errors"
	"fmt"
	"os"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/dynamic"
	fakeDynamicClientset "k8s.io/client-go/dynamic/fake"
	"k8s.io/client-go/rest"
	cache "k8s.io/client-go/tools/cache"

	baseClientset "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/client/clientset/versioned"
	fakeBaseClienset "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/client/clientset/versioned/fake"
	"github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/common"
	"github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/helper"

	baseapimappingconfigedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/apis/apimappingconfig.edge-orchestrator.intel.com/v1"
	baseconfigedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/apis/config.edge-orchestrator.intel.com/v1"
	basefolderedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/apis/folder.edge-orchestrator.intel.com/v1"
	basenetworkedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/apis/network.edge-orchestrator.intel.com/v1"
	baseorgedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/apis/org.edge-orchestrator.intel.com/v1"
	baseorgactivewatcheredgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/apis/orgactivewatcher.edge-orchestrator.intel.com/v1"
	baseorgwatcheredgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/apis/orgwatcher.edge-orchestrator.intel.com/v1"
	baseprojectedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/apis/project.edge-orchestrator.intel.com/v1"
	baseprojectactivewatcheredgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/apis/projectactivewatcher.edge-orchestrator.intel.com/v1"
	baseprojectwatcheredgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/apis/projectwatcher.edge-orchestrator.intel.com/v1"
	baseruntimeedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/apis/runtime.edge-orchestrator.intel.com/v1"
	baseruntimefolderedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/apis/runtimefolder.edge-orchestrator.intel.com/v1"
	baseruntimeorgedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/apis/runtimeorg.edge-orchestrator.intel.com/v1"
	baseruntimeprojectedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/apis/runtimeproject.edge-orchestrator.intel.com/v1"
	basetenancyedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/apis/tenancy.edge-orchestrator.intel.com/v1"

	informerapimappingconfigedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/client/informers/externalversions/apimappingconfig.edge-orchestrator.intel.com/v1"
	informerconfigedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/client/informers/externalversions/config.edge-orchestrator.intel.com/v1"
	informerfolderedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/client/informers/externalversions/folder.edge-orchestrator.intel.com/v1"
	informernetworkedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/client/informers/externalversions/network.edge-orchestrator.intel.com/v1"
	informerorgedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/client/informers/externalversions/org.edge-orchestrator.intel.com/v1"
	informerorgactivewatcheredgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/client/informers/externalversions/orgactivewatcher.edge-orchestrator.intel.com/v1"
	informerorgwatcheredgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/client/informers/externalversions/orgwatcher.edge-orchestrator.intel.com/v1"
	informerprojectedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/client/informers/externalversions/project.edge-orchestrator.intel.com/v1"
	informerprojectactivewatcheredgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/client/informers/externalversions/projectactivewatcher.edge-orchestrator.intel.com/v1"
	informerprojectwatcheredgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/client/informers/externalversions/projectwatcher.edge-orchestrator.intel.com/v1"
	informerruntimeedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/client/informers/externalversions/runtime.edge-orchestrator.intel.com/v1"
	informerruntimefolderedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/client/informers/externalversions/runtimefolder.edge-orchestrator.intel.com/v1"
	informerruntimeorgedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/client/informers/externalversions/runtimeorg.edge-orchestrator.intel.com/v1"
	informerruntimeprojectedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/client/informers/externalversions/runtimeproject.edge-orchestrator.intel.com/v1"
	informertenancyedgeorchestratorintelcomv1 "github.com/open-edge-platform/orch-utils/tenancy-datamodel/build/client/informers/externalversions/tenancy.edge-orchestrator.intel.com/v1"
)

var logger = logrus.New()

const maxRetryCount = 60
const sleepTime = 5
const maxRetryCount1SecSleep = 300

const ownershipAnnotation string = "Ownership"
const nexusDeferredDeleteAnnotation string = "nexus.com/nexus-deferred-delete"

// informerResyncPeriod is in second, default value is 10 Hrs(36000 Sec). INFORMER_RESYNC_PERIOD is os env to set Resync Period for informers
var informerResyncPeriod time.Duration = 36000

type Clientset struct {
	baseClient                 baseClientset.Interface
	DynamicClient              dynamic.Interface
	tenancyEdgeV1              *TenancyEdgeV1
	configEdgeV1               *ConfigEdgeV1
	apimappingconfigEdgeV1     *ApimappingconfigEdgeV1
	orgEdgeV1                  *OrgEdgeV1
	folderEdgeV1               *FolderEdgeV1
	projectEdgeV1              *ProjectEdgeV1
	networkEdgeV1              *NetworkEdgeV1
	orgwatcherEdgeV1           *OrgwatcherEdgeV1
	projectwatcherEdgeV1       *ProjectwatcherEdgeV1
	runtimeEdgeV1              *RuntimeEdgeV1
	runtimeorgEdgeV1           *RuntimeorgEdgeV1
	runtimefolderEdgeV1        *RuntimefolderEdgeV1
	runtimeprojectEdgeV1       *RuntimeprojectEdgeV1
	projectactivewatcherEdgeV1 *ProjectactivewatcherEdgeV1
	orgactivewatcherEdgeV1     *OrgactivewatcherEdgeV1
}

type subscription struct {
	informer          cache.SharedIndexInformer
	stop              chan struct{}
	WriteCacheObjects *sync.Map
}

// subscriptionMap will store crd string as key and value as subscription type,
// for example key="roots.orgchart.vmware.org" and value=subscription{}
var subscriptionMap = sync.Map{}

func subscribe(key string, informer cache.SharedIndexInformer) {
	s := subscription{
		informer:          informer,
		stop:              make(chan struct{}),
		WriteCacheObjects: &sync.Map{},
	}
	go s.informer.Run(s.stop)
	subscriptionMap.Store(key, s)
}

func (c *Clientset) SubscribeAll() {
	var key string

	key = "multitenancies.tenancy.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informertenancyedgeorchestratorintelcomv1.NewMultiTenancyInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}

	key = "configs.config.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigedgeorchestratorintelcomv1.NewConfigInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := configConfigEdgeV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerapimappingconfigedgeorchestratorintelcomv1.NewAPIMappingConfigInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := apimappingconfigApimappingconfigEdgeV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "orgs.org.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerorgedgeorchestratorintelcomv1.NewOrgInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := orgOrgEdgeV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "folders.folder.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerfolderedgeorchestratorintelcomv1.NewFolderInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := folderFolderEdgeV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "projects.project.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerprojectedgeorchestratorintelcomv1.NewProjectInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := projectProjectEdgeV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "networks.network.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informernetworkedgeorchestratorintelcomv1.NewNetworkInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := networkNetworkEdgeV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "orgwatchers.orgwatcher.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerorgwatcheredgeorchestratorintelcomv1.NewOrgWatcherInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := orgwatcherOrgwatcherEdgeV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "projectwatchers.projectwatcher.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerprojectwatcheredgeorchestratorintelcomv1.NewProjectWatcherInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := projectwatcherProjectwatcherEdgeV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "runtimes.runtime.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerruntimeedgeorchestratorintelcomv1.NewRuntimeInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := runtimeRuntimeEdgeV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "runtimeorgs.runtimeorg.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerruntimeorgedgeorchestratorintelcomv1.NewRuntimeOrgInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := runtimeorgRuntimeorgEdgeV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "runtimefolders.runtimefolder.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerruntimefolderedgeorchestratorintelcomv1.NewRuntimeFolderInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := runtimefolderRuntimefolderEdgeV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "runtimeprojects.runtimeproject.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerruntimeprojectedgeorchestratorintelcomv1.NewRuntimeProjectInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := runtimeprojectRuntimeprojectEdgeV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerprojectactivewatcheredgeorchestratorintelcomv1.NewProjectActiveWatcherInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := projectactivewatcherProjectactivewatcherEdgeV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerorgactivewatcheredgeorchestratorintelcomv1.NewOrgActiveWatcherInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := orgactivewatcherOrgactivewatcherEdgeV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

}

func (c *Clientset) UnsubscribeAll() {
	subscriptionMap.Range(func(key, s interface{}) bool {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
		return true
	})
}

// NewForConfig returns Client which can be which can be used to connect to database
func NewForConfig(config *rest.Config) (*Clientset, error) {
	baseClient, err := baseClientset.NewForConfig(config)
	if err != nil {
		return nil, err
	}

	customFormatter := new(logrus.TextFormatter)
	customFormatter.TimestampFormat = "2006-01-02 15:04:05"
	logger.SetFormatter(customFormatter)
	customFormatter.FullTimestamp = true
	if os.Getenv("NEXUS_LOG_LEVEL") == "debug" {
		logger.SetLevel(logrus.DebugLevel)
		logger.Debug("Nexus debug log enabled")
	}

	// INFORMER_RESYNC_PERIOD is os env to set Resync Period for informers
	stringResyncPeriod := os.Getenv("INFORMER_RESYNC_PERIOD")
	if stringResyncPeriod != "" {
		intResyncPeriod, err := strconv.Atoi(stringResyncPeriod)
		if err != nil {
			logger.Errorf("env INFORMER_RESYNC_PERIOD is not set with correct value")
		} else {
			informerResyncPeriod = time.Duration(intResyncPeriod)
			logger.Debugf("Resync Period for informers is set to %+v second", informerResyncPeriod)
		}
	}

	client := &Clientset{}
	client.baseClient = baseClient
	client.DynamicClient, _ = dynamic.NewForConfig(config) // TBD: check and react for error
	client.tenancyEdgeV1 = newTenancyEdgeV1(client)
	client.configEdgeV1 = newConfigEdgeV1(client)
	client.apimappingconfigEdgeV1 = newApimappingconfigEdgeV1(client)
	client.orgEdgeV1 = newOrgEdgeV1(client)
	client.folderEdgeV1 = newFolderEdgeV1(client)
	client.projectEdgeV1 = newProjectEdgeV1(client)
	client.networkEdgeV1 = newNetworkEdgeV1(client)
	client.orgwatcherEdgeV1 = newOrgwatcherEdgeV1(client)
	client.projectwatcherEdgeV1 = newProjectwatcherEdgeV1(client)
	client.runtimeEdgeV1 = newRuntimeEdgeV1(client)
	client.runtimeorgEdgeV1 = newRuntimeorgEdgeV1(client)
	client.runtimefolderEdgeV1 = newRuntimefolderEdgeV1(client)
	client.runtimeprojectEdgeV1 = newRuntimeprojectEdgeV1(client)
	client.projectactivewatcherEdgeV1 = newProjectactivewatcherEdgeV1(client)
	client.orgactivewatcherEdgeV1 = newOrgactivewatcherEdgeV1(client)

	return client, nil
}

// NewFakeClient creates simple client which can be used for unit tests
func NewFakeClient() *Clientset {
	client := &Clientset{}
	scheme := runtime.NewScheme()
	client.baseClient = fakeBaseClienset.NewSimpleClientset()
	client.DynamicClient = fakeDynamicClientset.NewSimpleDynamicClient(scheme)
	client.tenancyEdgeV1 = newTenancyEdgeV1(client)
	client.configEdgeV1 = newConfigEdgeV1(client)
	client.apimappingconfigEdgeV1 = newApimappingconfigEdgeV1(client)
	client.orgEdgeV1 = newOrgEdgeV1(client)
	client.folderEdgeV1 = newFolderEdgeV1(client)
	client.projectEdgeV1 = newProjectEdgeV1(client)
	client.networkEdgeV1 = newNetworkEdgeV1(client)
	client.orgwatcherEdgeV1 = newOrgwatcherEdgeV1(client)
	client.projectwatcherEdgeV1 = newProjectwatcherEdgeV1(client)
	client.runtimeEdgeV1 = newRuntimeEdgeV1(client)
	client.runtimeorgEdgeV1 = newRuntimeorgEdgeV1(client)
	client.runtimefolderEdgeV1 = newRuntimefolderEdgeV1(client)
	client.runtimeprojectEdgeV1 = newRuntimeprojectEdgeV1(client)
	client.projectactivewatcherEdgeV1 = newProjectactivewatcherEdgeV1(client)
	client.orgactivewatcherEdgeV1 = newOrgactivewatcherEdgeV1(client)

	return client
}

type PatchOp struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

type Patch []PatchOp

func (p Patch) Marshal() ([]byte, error) {
	return json.Marshal(p)
}

func (c *Clientset) Tenancy() *TenancyEdgeV1 {
	return c.tenancyEdgeV1
}
func (c *Clientset) Config() *ConfigEdgeV1 {
	return c.configEdgeV1
}
func (c *Clientset) Apimappingconfig() *ApimappingconfigEdgeV1 {
	return c.apimappingconfigEdgeV1
}
func (c *Clientset) Org() *OrgEdgeV1 {
	return c.orgEdgeV1
}
func (c *Clientset) Folder() *FolderEdgeV1 {
	return c.folderEdgeV1
}
func (c *Clientset) Project() *ProjectEdgeV1 {
	return c.projectEdgeV1
}
func (c *Clientset) Network() *NetworkEdgeV1 {
	return c.networkEdgeV1
}
func (c *Clientset) Orgwatcher() *OrgwatcherEdgeV1 {
	return c.orgwatcherEdgeV1
}
func (c *Clientset) Projectwatcher() *ProjectwatcherEdgeV1 {
	return c.projectwatcherEdgeV1
}
func (c *Clientset) Runtime() *RuntimeEdgeV1 {
	return c.runtimeEdgeV1
}
func (c *Clientset) Runtimeorg() *RuntimeorgEdgeV1 {
	return c.runtimeorgEdgeV1
}
func (c *Clientset) Runtimefolder() *RuntimefolderEdgeV1 {
	return c.runtimefolderEdgeV1
}
func (c *Clientset) Runtimeproject() *RuntimeprojectEdgeV1 {
	return c.runtimeprojectEdgeV1
}
func (c *Clientset) Projectactivewatcher() *ProjectactivewatcherEdgeV1 {
	return c.projectactivewatcherEdgeV1
}
func (c *Clientset) Orgactivewatcher() *OrgactivewatcherEdgeV1 {
	return c.orgactivewatcherEdgeV1
}

type TenancyEdgeV1 struct {
	client *Clientset
}

func newTenancyEdgeV1(client *Clientset) *TenancyEdgeV1 {
	return &TenancyEdgeV1{
		client: client,
	}
}

type ConfigEdgeV1 struct {
	client *Clientset
}

func newConfigEdgeV1(client *Clientset) *ConfigEdgeV1 {
	return &ConfigEdgeV1{
		client: client,
	}
}

type ApimappingconfigEdgeV1 struct {
	client *Clientset
}

func newApimappingconfigEdgeV1(client *Clientset) *ApimappingconfigEdgeV1 {
	return &ApimappingconfigEdgeV1{
		client: client,
	}
}

type OrgEdgeV1 struct {
	client *Clientset
}

func newOrgEdgeV1(client *Clientset) *OrgEdgeV1 {
	return &OrgEdgeV1{
		client: client,
	}
}

type FolderEdgeV1 struct {
	client *Clientset
}

func newFolderEdgeV1(client *Clientset) *FolderEdgeV1 {
	return &FolderEdgeV1{
		client: client,
	}
}

type ProjectEdgeV1 struct {
	client *Clientset
}

func newProjectEdgeV1(client *Clientset) *ProjectEdgeV1 {
	return &ProjectEdgeV1{
		client: client,
	}
}

type NetworkEdgeV1 struct {
	client *Clientset
}

func newNetworkEdgeV1(client *Clientset) *NetworkEdgeV1 {
	return &NetworkEdgeV1{
		client: client,
	}
}

type OrgwatcherEdgeV1 struct {
	client *Clientset
}

func newOrgwatcherEdgeV1(client *Clientset) *OrgwatcherEdgeV1 {
	return &OrgwatcherEdgeV1{
		client: client,
	}
}

type ProjectwatcherEdgeV1 struct {
	client *Clientset
}

func newProjectwatcherEdgeV1(client *Clientset) *ProjectwatcherEdgeV1 {
	return &ProjectwatcherEdgeV1{
		client: client,
	}
}

type RuntimeEdgeV1 struct {
	client *Clientset
}

func newRuntimeEdgeV1(client *Clientset) *RuntimeEdgeV1 {
	return &RuntimeEdgeV1{
		client: client,
	}
}

type RuntimeorgEdgeV1 struct {
	client *Clientset
}

func newRuntimeorgEdgeV1(client *Clientset) *RuntimeorgEdgeV1 {
	return &RuntimeorgEdgeV1{
		client: client,
	}
}

type RuntimefolderEdgeV1 struct {
	client *Clientset
}

func newRuntimefolderEdgeV1(client *Clientset) *RuntimefolderEdgeV1 {
	return &RuntimefolderEdgeV1{
		client: client,
	}
}

type RuntimeprojectEdgeV1 struct {
	client *Clientset
}

func newRuntimeprojectEdgeV1(client *Clientset) *RuntimeprojectEdgeV1 {
	return &RuntimeprojectEdgeV1{
		client: client,
	}
}

type ProjectactivewatcherEdgeV1 struct {
	client *Clientset
}

func newProjectactivewatcherEdgeV1(client *Clientset) *ProjectactivewatcherEdgeV1 {
	return &ProjectactivewatcherEdgeV1{
		client: client,
	}
}

type OrgactivewatcherEdgeV1 struct {
	client *Clientset
}

func newOrgactivewatcherEdgeV1(client *Clientset) *OrgactivewatcherEdgeV1 {
	return &OrgactivewatcherEdgeV1{
		client: client,
	}
}

func (group *TenancyEdgeV1) GetMultiTenancyChildrenMap() map[string]basetenancyedgeorchestratorintelcomv1.Child {
	return map[string]basetenancyedgeorchestratorintelcomv1.Child{}
}

func (group *TenancyEdgeV1) GetMultiTenancyChild(grp, kind, name string) basetenancyedgeorchestratorintelcomv1.Child {
	return basetenancyedgeorchestratorintelcomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetMultiTenancyByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *TenancyEdgeV1) GetMultiTenancyByName(ctx context.Context, hashedName string) (*TenancyMultiTenancy, error) {
	key := "multitenancies.tenancy.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			logger.Debugf("[GetMultiTenancyByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basetenancyedgeorchestratorintelcomv1.MultiTenancy)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				logger.Fatalf("[GetMultiTenancyByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basetenancyedgeorchestratorintelcomv1.MultiTenancy).ResourceVersion)
				if writeCacheVersionErr != nil {
					logger.Fatalf("[GetMultiTenancyByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &TenancyMultiTenancy{
					client:       group.client,
					MultiTenancy: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &TenancyMultiTenancy{
				client:       group.client,
				MultiTenancy: resWrCache.(*basetenancyedgeorchestratorintelcomv1.MultiTenancy),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			TenancyEdgeV1().
			MultiTenancies().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &TenancyMultiTenancy{
				client:       group.client,
				MultiTenancy: result,
			}, nil
		} else if errors.IsNotFound(err) {
			logger.Debugf("[GetMultiTenancyByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on Get MultiTenancies: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[GetMultiTenancyByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[GetMultiTenancyByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadMultiTenancyByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *TenancyEdgeV1) ForceReadMultiTenancyByName(ctx context.Context, hashedName string) (*TenancyMultiTenancy, error) {
	logger.Debugf("[ForceReadMultiTenancyByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			TenancyEdgeV1().
			MultiTenancies().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[ForceReadMultiTenancyByName] Failed to Get MultiTenancies: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max Retry exceed on Get MultiTenancies: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[ForceReadMultiTenancyByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[ForceReadMultiTenancyByName]: %+v", err)
				return nil, err
			}
		} else {
			logger.Debugf("[ForceReadMultiTenancyByName] Executed Successfully :%s", hashedName)
			return &TenancyMultiTenancy{
				client:       group.client,
				MultiTenancy: result,
			}, nil
		}
	}
}

// DeleteMultiTenancyByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *TenancyEdgeV1) DeleteMultiTenancyByName(ctx context.Context, hashedName string) (err error) {
	logger.Debugf("[DeleteMultiTenancyByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basetenancyedgeorchestratorintelcomv1.MultiTenancy
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			TenancyEdgeV1().
			MultiTenancies().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[DeleteMultiTenancyByName] Failed to get MultiTenancies: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on get MultiTenancies: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteMultiTenancyByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteMultiTenancyByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteMultiTenancyByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("multitenancies.tenancy.edge-orchestrator.intel.com", hashedName, "configs.config.edge-orchestrator.intel.com") {
		err := group.client.Config().DeleteConfigByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("multitenancies.tenancy.edge-orchestrator.intel.com", hashedName, "configs.config.edge-orchestrator.intel.com", child)
	}

	for _, child := range GetChildren("multitenancies.tenancy.edge-orchestrator.intel.com", hashedName, "runtimes.runtime.edge-orchestrator.intel.com") {
		err := group.client.Runtime().DeleteRuntimeByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("multitenancies.tenancy.edge-orchestrator.intel.com", hashedName, "runtimes.runtime.edge-orchestrator.intel.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			TenancyEdgeV1().
			MultiTenancies().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			logger.Errorf("[DeleteMultiTenancyByName] failed to delete MultiTenancies: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on delete MultiTenancies: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteMultiTenancyByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteMultiTenancyByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteMultiTenancyByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("multitenancies.tenancy.edge-orchestrator.intel.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	return nil
}

// CreateMultiTenancyByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *TenancyEdgeV1) CreateMultiTenancyByName(ctx context.Context,
	objToCreate *basetenancyedgeorchestratorintelcomv1.MultiTenancy) (*TenancyMultiTenancy, error) {
	logger.Debugf("[CreateMultiTenancyByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DisplayNameLabel]; !ok {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DisplayNameLabel] == "" {
		objToCreate.Labels[common.DisplayNameLabel] = helper.DefaultKey
	}
	if objToCreate.Labels[common.DisplayNameLabel] != helper.DefaultKey {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DisplayNameLabel])
	}

	objToCreate.Spec.ConfigGvk = nil
	objToCreate.Spec.RuntimeGvk = nil

	var (
		retryCount int
		result     *basetenancyedgeorchestratorintelcomv1.MultiTenancy
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			TenancyEdgeV1().
			MultiTenancies().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			logger.Errorf("[CreateMultiTenancyByName] Failed to create MultiTenancy: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on create MultiTenancy: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[CreateMultiTenancyByName] context canceled while creating MultiTenancy: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else {
				logger.Errorf("[CreateMultiTenancyByName] found unexpected error while creating MultiTenancy: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			logger.Debugf("[CreateMultiTenancyByName] MultiTenancy: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("multitenancies.tenancy.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[CreateMultiTenancyByName] MultiTenancy: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	logger.Debugf("[CreateMultiTenancyByName] Executed Successfully: %s", objToCreate.GetName())
	return &TenancyMultiTenancy{
		client:       group.client,
		MultiTenancy: result,
	}, nil
}

// UpdateMultiTenancyByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *TenancyEdgeV1) UpdateMultiTenancyByName(ctx context.Context,
	objToUpdate *basetenancyedgeorchestratorintelcomv1.MultiTenancy) (*TenancyMultiTenancy, error) {
	logger.Debugf("[UpdateMultiTenancyByName] Received objToUpdate: %s", objToUpdate.GetName())
	if objToUpdate.Labels[common.DisplayNameLabel] != helper.DefaultKey {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DisplayNameLabel])
	}

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Tenancy().GetMultiTenancyByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["multitenancies.tenancy.edge-orchestrator.intel.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IsNameHashedLabel] = current.Labels[common.IsNameHashedLabel]
			objToUpdate.Labels[common.DisplayNameLabel] = current.Labels[common.DisplayNameLabel]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basetenancyedgeorchestratorintelcomv1.MultiTenancy
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			TenancyEdgeV1().
			MultiTenancies().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			logger.Errorf("[UpdateMultiTenancyByName] Failed to patch MultiTenancy %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					logger.Debugf("Trigger MultiTenancy Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteMultiTenancyByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						logger.Debugf("Error occur while deleting MultiTenancy: %s", objToUpdate.GetName())
						return nil, delErr
					}
					logger.Debugf("MultiTenancy deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[UpdateMultiTenancyByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				logger.Errorf("[UpdateMultiTenancyByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				logger.Debugf("Trigger MultiTenancy Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteMultiTenancyByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					logger.Debugf("Error occur while deleting MultiTenancy: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				logger.Debugf("MultiTenancy Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			logger.Debugf("[UpdateMultiTenancyByName] Patch MultiTenancy Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("multitenancies.tenancy.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[UpdateMultiTenancyByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	logger.Debugf("[UpdateMultiTenancyByName] Executed Successfully %s", objToUpdate.GetName())
	return &TenancyMultiTenancy{
		client:       group.client,
		MultiTenancy: result,
	}, nil
}

// ListMultiTenancies returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *TenancyEdgeV1) ListMultiTenancies(ctx context.Context,
	opts metav1.ListOptions) (result []*TenancyMultiTenancy, err error) {
	key := "multitenancies.tenancy.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*TenancyMultiTenancy, len(items))
		for k, v := range items {
			item, _ := v.(*basetenancyedgeorchestratorintelcomv1.MultiTenancy)
			result[k] = &TenancyMultiTenancy{
				client:       group.client,
				MultiTenancy: item,
			}
		}
	} else {
		list, err := group.client.baseClient.TenancyEdgeV1().
			MultiTenancies().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*TenancyMultiTenancy, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &TenancyMultiTenancy{
				client:       group.client,
				MultiTenancy: &item,
			}
		}
	}
	return
}

type TenancyMultiTenancy struct {
	client *Clientset
	*basetenancyedgeorchestratorintelcomv1.MultiTenancy
}

// Delete removes obj and all it's children from the database.
func (obj *TenancyMultiTenancy) Delete(ctx context.Context) error {
	err := obj.client.Tenancy().DeleteMultiTenancyByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.MultiTenancy = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *TenancyMultiTenancy) Update(ctx context.Context) error {
	result, err := obj.client.Tenancy().UpdateMultiTenancyByName(ctx, obj.MultiTenancy)
	if err != nil {
		return err
	}
	obj.MultiTenancy = result.MultiTenancy
	return nil
}

// GetTenancyMultiTenancy calculates the hashed name based on parents and
// returns given object
func (c *Clientset) GetTenancyMultiTenancy(ctx context.Context) (result *TenancyMultiTenancy, err error) {
	hashedName := helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", nil, helper.DefaultKey)
	return c.Tenancy().GetMultiTenancyByName(ctx, hashedName)
}

func (c *Clientset) TenancyMultiTenancy() *multitenancyTenancyEdgeV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["multitenancies.tenancy.edge-orchestrator.intel.com"] = helper.DefaultKey
	return &multitenancyTenancyEdgeV1Chainer{
		client:       c,
		name:         helper.DefaultKey,
		parentLabels: parentLabels,
	}
}

// AddTenancyMultiTenancy calculates hashed name of the object based on
// parents names and creates it. objToCreate.Name is changed to the hashed name. Original name (helper.DefaultKey) is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddTenancyMultiTenancy(ctx context.Context,
	objToCreate *basetenancyedgeorchestratorintelcomv1.MultiTenancy) (result *TenancyMultiTenancy, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DefaultKey)
	}
	if objToCreate.GetName() != helper.DefaultKey {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Tenancy().CreateMultiTenancyByName(ctx, objToCreate)
}

// DeleteTenancyMultiTenancy calculates hashedName of object based on
// parents and deletes given object
func (c *Clientset) DeleteTenancyMultiTenancy(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", nil, helper.DefaultKey)
	return c.Tenancy().DeleteMultiTenancyByName(ctx, hashedName)
}

// GetConfig returns child of given type
func (obj *TenancyMultiTenancy) GetConfig(ctx context.Context) (
	result *ConfigConfig, err error) {
	children := GetChildren("multitenancies.tenancy.edge-orchestrator.intel.com", obj.Name, "configs.config.edge-orchestrator.intel.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Tenancy.MultiTenancy", "Config")
	}
	return obj.client.Config().GetConfigByName(ctx, children[0])
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *TenancyMultiTenancy) AddConfig(ctx context.Context,
	objToCreate *baseconfigedgeorchestratorintelcomv1.Config) (result *ConfigConfig, err error) {
	logger.Debugf("[AddConfig] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["multitenancies.tenancy.edge-orchestrator.intel.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["multitenancies.tenancy.edge-orchestrator.intel.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DefaultKey)
		}
		if objToCreate.GetName() != helper.DefaultKey {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Config().CreateConfigByName(ctx, objToCreate)
	logger.Debugf("[AddConfig] Config created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Tenancy().GetMultiTenancyByName(ctx, obj.GetName())
	if getErr == nil {
		obj.MultiTenancy = updatedObj.MultiTenancy
	}
	logger.Debugf("[AddConfig] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *TenancyMultiTenancy) DeleteConfig(ctx context.Context) (err error) {
	children := GetChildren("multitenancies.tenancy.edge-orchestrator.intel.com", obj.Name, "configs.config.edge-orchestrator.intel.com")
	if len(children) > 1 {
		logger.Panicf("[ DeleteConfig] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Config().DeleteConfigByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Tenancy().GetMultiTenancyByName(ctx, obj.GetName())
	if err == nil {
		obj.MultiTenancy = updatedObj.MultiTenancy
	}
	return
}

// GetRuntime returns child of given type
func (obj *TenancyMultiTenancy) GetRuntime(ctx context.Context) (
	result *RuntimeRuntime, err error) {
	children := GetChildren("multitenancies.tenancy.edge-orchestrator.intel.com", obj.Name, "runtimes.runtime.edge-orchestrator.intel.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Tenancy.MultiTenancy", "Runtime")
	}
	return obj.client.Runtime().GetRuntimeByName(ctx, children[0])
}

// AddRuntime calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *TenancyMultiTenancy) AddRuntime(ctx context.Context,
	objToCreate *baseruntimeedgeorchestratorintelcomv1.Runtime) (result *RuntimeRuntime, err error) {
	logger.Debugf("[AddRuntime] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["multitenancies.tenancy.edge-orchestrator.intel.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["multitenancies.tenancy.edge-orchestrator.intel.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DefaultKey)
		}
		if objToCreate.GetName() != helper.DefaultKey {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Runtime().CreateRuntimeByName(ctx, objToCreate)
	logger.Debugf("[AddRuntime] Runtime created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Tenancy().GetMultiTenancyByName(ctx, obj.GetName())
	if getErr == nil {
		obj.MultiTenancy = updatedObj.MultiTenancy
	}
	logger.Debugf("[AddRuntime] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteRuntime calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *TenancyMultiTenancy) DeleteRuntime(ctx context.Context) (err error) {
	children := GetChildren("multitenancies.tenancy.edge-orchestrator.intel.com", obj.Name, "runtimes.runtime.edge-orchestrator.intel.com")
	if len(children) > 1 {
		logger.Panicf("[ DeleteRuntime] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Runtime().DeleteRuntimeByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Tenancy().GetMultiTenancyByName(ctx, obj.GetName())
	if err == nil {
		obj.MultiTenancy = updatedObj.MultiTenancy
	}
	return
}

type multitenancyTenancyEdgeV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *multitenancyTenancyEdgeV1Chainer) Subscribe() {
	key := "multitenancies.tenancy.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informertenancyedgeorchestratorintelcomv1.NewMultiTenancyInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}
}

func (c *multitenancyTenancyEdgeV1Chainer) Unsubscribe() {
	key := "multitenancies.tenancy.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *multitenancyTenancyEdgeV1Chainer) IsSubscribed() bool {
	key := "multitenancies.tenancy.edge-orchestrator.intel.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *multitenancyTenancyEdgeV1Chainer) RegisterEventHandler(addCB func(obj *TenancyMultiTenancy), updateCB func(oldObj, newObj *TenancyMultiTenancy), deleteCB func(obj *TenancyMultiTenancy)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for TenancyMultiTenancy")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "multitenancies.tenancy.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for TenancyMultiTenancy")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for TenancyMultiTenancy, so creating a new one")
		informer = informertenancyedgeorchestratorintelcomv1.NewMultiTenancyInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &TenancyMultiTenancy{
				client:       c.client,
				MultiTenancy: obj.(*basetenancyedgeorchestratorintelcomv1.MultiTenancy),
			}
			logger.Debugf("[RegisterEventHandler AddFunc] Got Add event for multitenancies.tenancy.edge-orchestrator.intel.com name %s", nc.MultiTenancy.Name)

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &TenancyMultiTenancy{
				client:       c.client,
				MultiTenancy: oldObj.(*basetenancyedgeorchestratorintelcomv1.MultiTenancy),
			}
			newData := &TenancyMultiTenancy{
				client:       c.client,
				MultiTenancy: newObj.(*basetenancyedgeorchestratorintelcomv1.MultiTenancy),
			}
			logger.Debugf("[RegisterEventHandler UpdateFunc] Got Update event for multitenancies.tenancy.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.MultiTenancy.Name, oldData.ResourceVersion, newData.ResourceVersion)
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &TenancyMultiTenancy{
				client:       c.client,
				MultiTenancy: obj.(*basetenancyedgeorchestratorintelcomv1.MultiTenancy),
			}
			logger.Debugf("[RegisterEventHandler DeleteFunc] Got Delete event for multitenancies.tenancy.edge-orchestrator.intel.com name %s", nc.MultiTenancy.Name)

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *multitenancyTenancyEdgeV1Chainer) RegisterAddCallback(cbfn func(obj *TenancyMultiTenancy)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterAddCallback] Received for TenancyMultiTenancy")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "multitenancies.tenancy.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for TenancyMultiTenancy")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for TenancyMultiTenancy, so creating a new one")
		informer = informertenancyedgeorchestratorintelcomv1.NewMultiTenancyInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &TenancyMultiTenancy{
				client:       c.client,
				MultiTenancy: obj.(*basetenancyedgeorchestratorintelcomv1.MultiTenancy),
			}
			logger.Debugf("[RegisterAddCallback] Got Add event for multitenancies.tenancy.edge-orchestrator.intel.com name %s", nc.MultiTenancy.Name)

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *multitenancyTenancyEdgeV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *TenancyMultiTenancy)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterUpdateCallback] Received for TenancyMultiTenancy")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "multitenancies.tenancy.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for TenancyMultiTenancy")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for TenancyMultiTenancy, so creating a new one")
		informer = informertenancyedgeorchestratorintelcomv1.NewMultiTenancyInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &TenancyMultiTenancy{
				client:       c.client,
				MultiTenancy: oldObj.(*basetenancyedgeorchestratorintelcomv1.MultiTenancy),
			}
			newData := &TenancyMultiTenancy{
				client:       c.client,
				MultiTenancy: newObj.(*basetenancyedgeorchestratorintelcomv1.MultiTenancy),
			}
			logger.Debugf("[RegisterUpdateCallback] Got Update event for multitenancies.tenancy.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.MultiTenancy.Name, oldData.ResourceVersion, newData.ResourceVersion)
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *multitenancyTenancyEdgeV1Chainer) RegisterDeleteCallback(cbfn func(obj *TenancyMultiTenancy)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterDeleteCallback] Received for TenancyMultiTenancy")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "multitenancies.tenancy.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for TenancyMultiTenancy")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for TenancyMultiTenancy, so creating a new one")
		informer = informertenancyedgeorchestratorintelcomv1.NewMultiTenancyInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &TenancyMultiTenancy{
				client:       c.client,
				MultiTenancy: obj.(*basetenancyedgeorchestratorintelcomv1.MultiTenancy),
			}
			logger.Debugf("[RegisterDeleteCallback] Got Delete event for multitenancies.tenancy.edge-orchestrator.intel.com name %s", nc.MultiTenancy.Name)

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *multitenancyTenancyEdgeV1Chainer) Config() *configConfigEdgeV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["configs.config.edge-orchestrator.intel.com"] = helper.DefaultKey
	return &configConfigEdgeV1Chainer{
		client:       c.client,
		name:         helper.DefaultKey,
		parentLabels: parentLabels,
	}
}

// GetConfig calculates hashed name of the object based on it's parents and returns the object
func (c *multitenancyTenancyEdgeV1Chainer) GetConfig(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", c.parentLabels, helper.DefaultKey)
	return c.client.Config().GetConfigByName(ctx, hashedName)
}

// AddConfig calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *multitenancyTenancyEdgeV1Chainer) AddConfig(ctx context.Context,
	objToCreate *baseconfigedgeorchestratorintelcomv1.Config) (result *ConfigConfig, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DefaultKey)
	}
	if objToCreate.GetName() != helper.DefaultKey {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Config().CreateConfigByName(ctx, objToCreate)
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *multitenancyTenancyEdgeV1Chainer) DeleteConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IsNameHashedLabel] = "true"
	hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", c.parentLabels, name)
	return c.client.Config().DeleteConfigByName(ctx, hashedName)
}

func (c *multitenancyTenancyEdgeV1Chainer) Runtime() *runtimeRuntimeEdgeV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["runtimes.runtime.edge-orchestrator.intel.com"] = helper.DefaultKey
	return &runtimeRuntimeEdgeV1Chainer{
		client:       c.client,
		name:         helper.DefaultKey,
		parentLabels: parentLabels,
	}
}

// GetRuntime calculates hashed name of the object based on it's parents and returns the object
func (c *multitenancyTenancyEdgeV1Chainer) GetRuntime(ctx context.Context) (result *RuntimeRuntime, err error) {
	hashedName := helper.GetHashedName("runtimes.runtime.edge-orchestrator.intel.com", c.parentLabels, helper.DefaultKey)
	return c.client.Runtime().GetRuntimeByName(ctx, hashedName)
}

// AddRuntime calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *multitenancyTenancyEdgeV1Chainer) AddRuntime(ctx context.Context,
	objToCreate *baseruntimeedgeorchestratorintelcomv1.Runtime) (result *RuntimeRuntime, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DefaultKey)
	}
	if objToCreate.GetName() != helper.DefaultKey {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName("runtimes.runtime.edge-orchestrator.intel.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Runtime().CreateRuntimeByName(ctx, objToCreate)
}

// DeleteRuntime calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *multitenancyTenancyEdgeV1Chainer) DeleteRuntime(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IsNameHashedLabel] = "true"
	hashedName := helper.GetHashedName("runtimes.runtime.edge-orchestrator.intel.com", c.parentLabels, name)
	return c.client.Runtime().DeleteRuntimeByName(ctx, hashedName)
}

func (group *ConfigEdgeV1) GetConfigChildrenMap() map[string]baseconfigedgeorchestratorintelcomv1.Child {
	return map[string]baseconfigedgeorchestratorintelcomv1.Child{}
}

func (group *ConfigEdgeV1) GetConfigChild(grp, kind, name string) baseconfigedgeorchestratorintelcomv1.Child {
	return baseconfigedgeorchestratorintelcomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigEdgeV1) GetConfigByName(ctx context.Context, hashedName string) (*ConfigConfig, error) {
	key := "configs.config.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			logger.Debugf("[GetConfigByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseconfigedgeorchestratorintelcomv1.Config)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				logger.Fatalf("[GetConfigByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseconfigedgeorchestratorintelcomv1.Config).ResourceVersion)
				if writeCacheVersionErr != nil {
					logger.Fatalf("[GetConfigByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &ConfigConfig{
					client: group.client,
					Config: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &ConfigConfig{
				client: group.client,
				Config: resWrCache.(*baseconfigedgeorchestratorintelcomv1.Config),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ConfigEdgeV1().
			Configs().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &ConfigConfig{
				client: group.client,
				Config: result,
			}, nil
		} else if errors.IsNotFound(err) {
			logger.Debugf("[GetConfigByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on Get Configs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[GetConfigByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[GetConfigByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadConfigByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigEdgeV1) ForceReadConfigByName(ctx context.Context, hashedName string) (*ConfigConfig, error) {
	logger.Debugf("[ForceReadConfigByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ConfigEdgeV1().
			Configs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[ForceReadConfigByName] Failed to Get Configs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max Retry exceed on Get Configs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[ForceReadConfigByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[ForceReadConfigByName]: %+v", err)
				return nil, err
			}
		} else {
			logger.Debugf("[ForceReadConfigByName] Executed Successfully :%s", hashedName)
			return &ConfigConfig{
				client: group.client,
				Config: result,
			}, nil
		}
	}
}

// DeleteConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ConfigEdgeV1) DeleteConfigByName(ctx context.Context, hashedName string) (err error) {
	logger.Debugf("[DeleteConfigByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseconfigedgeorchestratorintelcomv1.Config
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ConfigEdgeV1().
			Configs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[DeleteConfigByName] Failed to get Configs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on get Configs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteConfigByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteConfigByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteConfigByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("configs.config.edge-orchestrator.intel.com", hashedName, "orgs.org.edge-orchestrator.intel.com") {
		err := group.client.Org().DeleteOrgByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("configs.config.edge-orchestrator.intel.com", hashedName, "orgs.org.edge-orchestrator.intel.com", child)
	}

	for _, child := range GetChildren("configs.config.edge-orchestrator.intel.com", hashedName, "orgwatchers.orgwatcher.edge-orchestrator.intel.com") {
		err := group.client.Orgwatcher().DeleteOrgWatcherByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("configs.config.edge-orchestrator.intel.com", hashedName, "orgwatchers.orgwatcher.edge-orchestrator.intel.com", child)
	}

	for _, child := range GetChildren("configs.config.edge-orchestrator.intel.com", hashedName, "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com") {
		err := group.client.Apimappingconfig().DeleteAPIMappingConfigByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("configs.config.edge-orchestrator.intel.com", hashedName, "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", child)
	}

	for _, child := range GetChildren("configs.config.edge-orchestrator.intel.com", hashedName, "projectwatchers.projectwatcher.edge-orchestrator.intel.com") {
		err := group.client.Projectwatcher().DeleteProjectWatcherByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("configs.config.edge-orchestrator.intel.com", hashedName, "projectwatchers.projectwatcher.edge-orchestrator.intel.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			ConfigEdgeV1().
			Configs().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			logger.Errorf("[DeleteConfigByName] failed to delete Configs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on delete Configs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteConfigByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteConfigByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteConfigByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("configs.config.edge-orchestrator.intel.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	logger.Debugf("[DeleteConfigByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["multitenancies.tenancy.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	if result.GetLabels() != nil {
		if parents[common.IsNameHashedLabel] == "true" {
			parentName = helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", parents, parentName)
	}
	RemoveChild("multitenancies.tenancy.edge-orchestrator.intel.com", parentName, "configs.config.edge-orchestrator.intel.com", hashedName)

	return nil
}

// CreateConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ConfigEdgeV1) CreateConfigByName(ctx context.Context,
	objToCreate *baseconfigedgeorchestratorintelcomv1.Config) (*ConfigConfig, error) {
	logger.Debugf("[CreateConfigByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DisplayNameLabel]; !ok {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DisplayNameLabel] == "" {
		objToCreate.Labels[common.DisplayNameLabel] = helper.DefaultKey
	}
	if objToCreate.Labels[common.DisplayNameLabel] != helper.DefaultKey {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DisplayNameLabel])
	}

	objToCreate.Spec.OrgsGvk = nil
	objToCreate.Spec.OrgWatchersGvk = nil
	objToCreate.Spec.APIMappingsGvk = nil
	objToCreate.Spec.ProjectWatchersGvk = nil

	var (
		retryCount int
		result     *baseconfigedgeorchestratorintelcomv1.Config
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ConfigEdgeV1().
			Configs().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			logger.Errorf("[CreateConfigByName] Failed to create Config: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on create Config: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[CreateConfigByName] context canceled while creating Config: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				logger.Debugf("[CreateConfigByName] Config: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.ConfigEdgeV1().Configs().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					logger.Fatalf("[CreateConfigByName] Unable to Get Config %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				logger.Errorf("[CreateConfigByName] found unexpected error while creating Config: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			logger.Debugf("[CreateConfigByName] Config: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("configs.config.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[CreateConfigByName] Config: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["multitenancies.tenancy.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	parentHashedName := helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", objToCreate.GetLabels(), parentName)

	AddChild("multitenancies.tenancy.edge-orchestrator.intel.com", parentHashedName, "configs.config.edge-orchestrator.intel.com", objToCreate.Name)

	logger.Debugf("[CreateConfigByName] Executed Successfully: %s", objToCreate.GetName())
	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// UpdateConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ConfigEdgeV1) UpdateConfigByName(ctx context.Context,
	objToUpdate *baseconfigedgeorchestratorintelcomv1.Config) (*ConfigConfig, error) {
	logger.Debugf("[UpdateConfigByName] Received objToUpdate: %s", objToUpdate.GetName())
	if objToUpdate.Labels[common.DisplayNameLabel] != helper.DefaultKey {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DisplayNameLabel])
	}

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Config().GetConfigByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["configs.config.edge-orchestrator.intel.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IsNameHashedLabel] = current.Labels[common.IsNameHashedLabel]
			objToUpdate.Labels[common.DisplayNameLabel] = current.Labels[common.DisplayNameLabel]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseconfigedgeorchestratorintelcomv1.Config
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			ConfigEdgeV1().
			Configs().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			logger.Errorf("[UpdateConfigByName] Failed to patch Config %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					logger.Debugf("Trigger Config Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteConfigByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						logger.Debugf("Error occur while deleting Config: %s", objToUpdate.GetName())
						return nil, delErr
					}
					logger.Debugf("Config deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[UpdateConfigByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				logger.Errorf("[UpdateConfigByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				logger.Debugf("Trigger Config Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteConfigByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					logger.Debugf("Error occur while deleting Config: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				logger.Debugf("Config Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			logger.Debugf("[UpdateConfigByName] Patch Config Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("configs.config.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[UpdateConfigByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	logger.Debugf("[UpdateConfigByName] Executed Successfully %s", objToUpdate.GetName())
	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// ListConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ConfigEdgeV1) ListConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*ConfigConfig, err error) {
	key := "configs.config.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*ConfigConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseconfigedgeorchestratorintelcomv1.Config)
			result[k] = &ConfigConfig{
				client: group.client,
				Config: item,
			}
		}
	} else {
		list, err := group.client.baseClient.ConfigEdgeV1().
			Configs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*ConfigConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &ConfigConfig{
				client: group.client,
				Config: &item,
			}
		}
	}
	return
}

type ConfigConfig struct {
	client *Clientset
	*baseconfigedgeorchestratorintelcomv1.Config
}

// Delete removes obj and all it's children from the database.
func (obj *ConfigConfig) Delete(ctx context.Context) error {
	err := obj.client.Config().DeleteConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Config = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ConfigConfig) Update(ctx context.Context) error {
	result, err := obj.client.Config().UpdateConfigByName(ctx, obj.Config)
	if err != nil {
		return err
	}
	obj.Config = result.Config
	return nil
}

func (obj *ConfigConfig) GetParent(ctx context.Context) (result *TenancyMultiTenancy, err error) {
	hashedName := helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", obj.Labels, obj.Labels["multitenancies.tenancy.edge-orchestrator.intel.com"])
	logger.Debugf("[GetParent] Get parent of ConfigConfig name %s [labels %#v] of parent type multitenancies.tenancy.edge-orchestrator.intel.com and name %s", obj.Name, obj.Labels, hashedName)
	return obj.client.Tenancy().GetMultiTenancyByName(ctx, hashedName)
}

type ConfigConfigOrgs struct {
	client *Clientset
	Orgs   []baseconfigedgeorchestratorintelcomv1.Child
}

func (n *ConfigConfigOrgs) Next(ctx context.Context) (*OrgOrg, error) {
	for index, child := range n.Orgs {
		logger.Debugf("[ConfigConfigOrgs Next] Get next Orgs with name %s", child.Name)
		obj, err := n.client.Org().GetOrgByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Orgs)-1 {
				n.Orgs = nil
			} else {
				n.Orgs = n.Orgs[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllOrgsIter returns an iterator for all children of given type
func (obj *ConfigConfig) GetAllOrgsIter(ctx context.Context) (
	result ConfigConfigOrgs) {
	result.client = obj.client
	for _, v := range GetChildren("configs.config.edge-orchestrator.intel.com", obj.Name, "orgs.org.edge-orchestrator.intel.com") {
		result.Orgs = append(result.Orgs, baseconfigedgeorchestratorintelcomv1.Child{
			Group: "org.edge-orchestrator.intel.com",
			Kind:  "Org",
			Name:  v,
		})
	}
	return
}

// GetAllOrgs returns all children of a given type
func (obj *ConfigConfig) GetAllOrgs(ctx context.Context) (
	result []*OrgOrg, err error) {
	for _, v := range GetChildren("configs.config.edge-orchestrator.intel.com", obj.Name, "orgs.org.edge-orchestrator.intel.com") {
		logger.Debugf("[ConfigConfig GetAllOrgs] Get next Orgs with name %s", v)
		l, err := obj.client.Org().GetOrgByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetOrgs returns child which has given displayName
func (obj *ConfigConfig) GetOrgs(ctx context.Context,
	displayName string) (result *OrgOrg, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("orgs.org.edge-orchestrator.intel.com", parentLabels, displayName)
	logger.Debugf("[GetOrgs] in ConfigConfig with name %s, displayName %s, parentLabels %#v", childHashName, displayName, parentLabels)
	if IsChildExists("configs.config.edge-orchestrator.intel.com", obj.Name, "orgs.org.edge-orchestrator.intel.com", childHashName) == false {
		logger.Debugf("[GetOrgs] ChildNotFound Orgs with name %s, displayName %s ", childHashName, displayName)
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "Orgs", displayName)
	}

	logger.Debugf("[GetOrgs] invoke GetOrgByName name %s, displayName %s", childHashName, displayName)
	result, err = obj.client.Org().GetOrgByName(ctx, childHashName)
	return
}

// AddOrgs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddOrgs(ctx context.Context,
	objToCreate *baseorgedgeorchestratorintelcomv1.Org) (result *OrgOrg, err error) {
	logger.Debugf("[AddOrgs] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.edge-orchestrator.intel.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.edge-orchestrator.intel.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Org().CreateOrgByName(ctx, objToCreate)
	logger.Debugf("[AddOrgs] Org created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	logger.Debugf("[AddOrgs] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteOrgs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteOrgs(ctx context.Context, displayName string) (err error) {
	logger.Debugf("[ DeleteOrgs] Received for Org object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("orgs.org.edge-orchestrator.intel.com", parentLabels, displayName)
	if IsChildExists("configs.config.edge-orchestrator.intel.com", obj.Name, "orgs.org.edge-orchestrator.intel.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Config.Config", "Orgs", displayName)
	}

	err = obj.client.Org().DeleteOrgByName(ctx, childHashName)
	if err != nil {
		return err
	}
	logger.Debugf("[ DeleteOrgs] Org object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

type ConfigConfigOrgWatchers struct {
	client      *Clientset
	OrgWatchers []baseconfigedgeorchestratorintelcomv1.Child
}

func (n *ConfigConfigOrgWatchers) Next(ctx context.Context) (*OrgwatcherOrgWatcher, error) {
	for index, child := range n.OrgWatchers {
		logger.Debugf("[ConfigConfigOrgWatchers Next] Get next OrgWatchers with name %s", child.Name)
		obj, err := n.client.Orgwatcher().GetOrgWatcherByName(ctx, child.Name)
		if err == nil {
			if index == len(n.OrgWatchers)-1 {
				n.OrgWatchers = nil
			} else {
				n.OrgWatchers = n.OrgWatchers[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllOrgWatchersIter returns an iterator for all children of given type
func (obj *ConfigConfig) GetAllOrgWatchersIter(ctx context.Context) (
	result ConfigConfigOrgWatchers) {
	result.client = obj.client
	for _, v := range GetChildren("configs.config.edge-orchestrator.intel.com", obj.Name, "orgwatchers.orgwatcher.edge-orchestrator.intel.com") {
		result.OrgWatchers = append(result.OrgWatchers, baseconfigedgeorchestratorintelcomv1.Child{
			Group: "orgwatcher.edge-orchestrator.intel.com",
			Kind:  "OrgWatcher",
			Name:  v,
		})
	}
	return
}

// GetAllOrgWatchers returns all children of a given type
func (obj *ConfigConfig) GetAllOrgWatchers(ctx context.Context) (
	result []*OrgwatcherOrgWatcher, err error) {
	for _, v := range GetChildren("configs.config.edge-orchestrator.intel.com", obj.Name, "orgwatchers.orgwatcher.edge-orchestrator.intel.com") {
		logger.Debugf("[ConfigConfig GetAllOrgWatchers] Get next OrgWatchers with name %s", v)
		l, err := obj.client.Orgwatcher().GetOrgWatcherByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetOrgWatchers returns child which has given displayName
func (obj *ConfigConfig) GetOrgWatchers(ctx context.Context,
	displayName string) (result *OrgwatcherOrgWatcher, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("orgwatchers.orgwatcher.edge-orchestrator.intel.com", parentLabels, displayName)
	logger.Debugf("[GetOrgWatchers] in ConfigConfig with name %s, displayName %s, parentLabels %#v", childHashName, displayName, parentLabels)
	if IsChildExists("configs.config.edge-orchestrator.intel.com", obj.Name, "orgwatchers.orgwatcher.edge-orchestrator.intel.com", childHashName) == false {
		logger.Debugf("[GetOrgWatchers] ChildNotFound OrgWatchers with name %s, displayName %s ", childHashName, displayName)
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "OrgWatchers", displayName)
	}

	logger.Debugf("[GetOrgWatchers] invoke GetOrgWatcherByName name %s, displayName %s", childHashName, displayName)
	result, err = obj.client.Orgwatcher().GetOrgWatcherByName(ctx, childHashName)
	return
}

// AddOrgWatchers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddOrgWatchers(ctx context.Context,
	objToCreate *baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher) (result *OrgwatcherOrgWatcher, err error) {
	logger.Debugf("[AddOrgWatchers] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.edge-orchestrator.intel.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.edge-orchestrator.intel.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Orgwatcher().CreateOrgWatcherByName(ctx, objToCreate)
	logger.Debugf("[AddOrgWatchers] OrgWatcher created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	logger.Debugf("[AddOrgWatchers] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteOrgWatchers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteOrgWatchers(ctx context.Context, displayName string) (err error) {
	logger.Debugf("[ DeleteOrgWatchers] Received for OrgWatcher object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("orgwatchers.orgwatcher.edge-orchestrator.intel.com", parentLabels, displayName)
	if IsChildExists("configs.config.edge-orchestrator.intel.com", obj.Name, "orgwatchers.orgwatcher.edge-orchestrator.intel.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Config.Config", "OrgWatchers", displayName)
	}

	err = obj.client.Orgwatcher().DeleteOrgWatcherByName(ctx, childHashName)
	if err != nil {
		return err
	}
	logger.Debugf("[ DeleteOrgWatchers] OrgWatcher object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

type ConfigConfigAPIMappings struct {
	client      *Clientset
	APIMappings []baseconfigedgeorchestratorintelcomv1.Child
}

func (n *ConfigConfigAPIMappings) Next(ctx context.Context) (*ApimappingconfigAPIMappingConfig, error) {
	for index, child := range n.APIMappings {
		logger.Debugf("[ConfigConfigAPIMappings Next] Get next APIMappings with name %s", child.Name)
		obj, err := n.client.Apimappingconfig().GetAPIMappingConfigByName(ctx, child.Name)
		if err == nil {
			if index == len(n.APIMappings)-1 {
				n.APIMappings = nil
			} else {
				n.APIMappings = n.APIMappings[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllAPIMappingsIter returns an iterator for all children of given type
func (obj *ConfigConfig) GetAllAPIMappingsIter(ctx context.Context) (
	result ConfigConfigAPIMappings) {
	result.client = obj.client
	for _, v := range GetChildren("configs.config.edge-orchestrator.intel.com", obj.Name, "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com") {
		result.APIMappings = append(result.APIMappings, baseconfigedgeorchestratorintelcomv1.Child{
			Group: "apimappingconfig.edge-orchestrator.intel.com",
			Kind:  "APIMappingConfig",
			Name:  v,
		})
	}
	return
}

// GetAllAPIMappings returns all children of a given type
func (obj *ConfigConfig) GetAllAPIMappings(ctx context.Context) (
	result []*ApimappingconfigAPIMappingConfig, err error) {
	for _, v := range GetChildren("configs.config.edge-orchestrator.intel.com", obj.Name, "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com") {
		logger.Debugf("[ConfigConfig GetAllAPIMappings] Get next APIMappings with name %s", v)
		l, err := obj.client.Apimappingconfig().GetAPIMappingConfigByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetAPIMappings returns child which has given displayName
func (obj *ConfigConfig) GetAPIMappings(ctx context.Context,
	displayName string) (result *ApimappingconfigAPIMappingConfig, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", parentLabels, displayName)
	logger.Debugf("[GetAPIMappings] in ConfigConfig with name %s, displayName %s, parentLabels %#v", childHashName, displayName, parentLabels)
	if IsChildExists("configs.config.edge-orchestrator.intel.com", obj.Name, "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", childHashName) == false {
		logger.Debugf("[GetAPIMappings] ChildNotFound APIMappings with name %s, displayName %s ", childHashName, displayName)
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "APIMappings", displayName)
	}

	logger.Debugf("[GetAPIMappings] invoke GetAPIMappingConfigByName name %s, displayName %s", childHashName, displayName)
	result, err = obj.client.Apimappingconfig().GetAPIMappingConfigByName(ctx, childHashName)
	return
}

// AddAPIMappings calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddAPIMappings(ctx context.Context,
	objToCreate *baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig) (result *ApimappingconfigAPIMappingConfig, err error) {
	logger.Debugf("[AddAPIMappings] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.edge-orchestrator.intel.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.edge-orchestrator.intel.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Apimappingconfig().CreateAPIMappingConfigByName(ctx, objToCreate)
	logger.Debugf("[AddAPIMappings] APIMappingConfig created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	logger.Debugf("[AddAPIMappings] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteAPIMappings calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteAPIMappings(ctx context.Context, displayName string) (err error) {
	logger.Debugf("[ DeleteAPIMappings] Received for APIMappingConfig object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", parentLabels, displayName)
	if IsChildExists("configs.config.edge-orchestrator.intel.com", obj.Name, "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Config.Config", "APIMappings", displayName)
	}

	err = obj.client.Apimappingconfig().DeleteAPIMappingConfigByName(ctx, childHashName)
	if err != nil {
		return err
	}
	logger.Debugf("[ DeleteAPIMappings] APIMappingConfig object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

type ConfigConfigProjectWatchers struct {
	client          *Clientset
	ProjectWatchers []baseconfigedgeorchestratorintelcomv1.Child
}

func (n *ConfigConfigProjectWatchers) Next(ctx context.Context) (*ProjectwatcherProjectWatcher, error) {
	for index, child := range n.ProjectWatchers {
		logger.Debugf("[ConfigConfigProjectWatchers Next] Get next ProjectWatchers with name %s", child.Name)
		obj, err := n.client.Projectwatcher().GetProjectWatcherByName(ctx, child.Name)
		if err == nil {
			if index == len(n.ProjectWatchers)-1 {
				n.ProjectWatchers = nil
			} else {
				n.ProjectWatchers = n.ProjectWatchers[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllProjectWatchersIter returns an iterator for all children of given type
func (obj *ConfigConfig) GetAllProjectWatchersIter(ctx context.Context) (
	result ConfigConfigProjectWatchers) {
	result.client = obj.client
	for _, v := range GetChildren("configs.config.edge-orchestrator.intel.com", obj.Name, "projectwatchers.projectwatcher.edge-orchestrator.intel.com") {
		result.ProjectWatchers = append(result.ProjectWatchers, baseconfigedgeorchestratorintelcomv1.Child{
			Group: "projectwatcher.edge-orchestrator.intel.com",
			Kind:  "ProjectWatcher",
			Name:  v,
		})
	}
	return
}

// GetAllProjectWatchers returns all children of a given type
func (obj *ConfigConfig) GetAllProjectWatchers(ctx context.Context) (
	result []*ProjectwatcherProjectWatcher, err error) {
	for _, v := range GetChildren("configs.config.edge-orchestrator.intel.com", obj.Name, "projectwatchers.projectwatcher.edge-orchestrator.intel.com") {
		logger.Debugf("[ConfigConfig GetAllProjectWatchers] Get next ProjectWatchers with name %s", v)
		l, err := obj.client.Projectwatcher().GetProjectWatcherByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetProjectWatchers returns child which has given displayName
func (obj *ConfigConfig) GetProjectWatchers(ctx context.Context,
	displayName string) (result *ProjectwatcherProjectWatcher, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("projectwatchers.projectwatcher.edge-orchestrator.intel.com", parentLabels, displayName)
	logger.Debugf("[GetProjectWatchers] in ConfigConfig with name %s, displayName %s, parentLabels %#v", childHashName, displayName, parentLabels)
	if IsChildExists("configs.config.edge-orchestrator.intel.com", obj.Name, "projectwatchers.projectwatcher.edge-orchestrator.intel.com", childHashName) == false {
		logger.Debugf("[GetProjectWatchers] ChildNotFound ProjectWatchers with name %s, displayName %s ", childHashName, displayName)
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "ProjectWatchers", displayName)
	}

	logger.Debugf("[GetProjectWatchers] invoke GetProjectWatcherByName name %s, displayName %s", childHashName, displayName)
	result, err = obj.client.Projectwatcher().GetProjectWatcherByName(ctx, childHashName)
	return
}

// AddProjectWatchers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddProjectWatchers(ctx context.Context,
	objToCreate *baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher) (result *ProjectwatcherProjectWatcher, err error) {
	logger.Debugf("[AddProjectWatchers] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.edge-orchestrator.intel.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.edge-orchestrator.intel.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Projectwatcher().CreateProjectWatcherByName(ctx, objToCreate)
	logger.Debugf("[AddProjectWatchers] ProjectWatcher created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	logger.Debugf("[AddProjectWatchers] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteProjectWatchers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteProjectWatchers(ctx context.Context, displayName string) (err error) {
	logger.Debugf("[ DeleteProjectWatchers] Received for ProjectWatcher object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("projectwatchers.projectwatcher.edge-orchestrator.intel.com", parentLabels, displayName)
	if IsChildExists("configs.config.edge-orchestrator.intel.com", obj.Name, "projectwatchers.projectwatcher.edge-orchestrator.intel.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Config.Config", "ProjectWatchers", displayName)
	}

	err = obj.client.Projectwatcher().DeleteProjectWatcherByName(ctx, childHashName)
	if err != nil {
		return err
	}
	logger.Debugf("[ DeleteProjectWatchers] ProjectWatcher object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

type configConfigEdgeV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *configConfigEdgeV1Chainer) Subscribe() {
	key := "configs.config.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigedgeorchestratorintelcomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *configConfigEdgeV1Chainer) Unsubscribe() {
	key := "configs.config.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *configConfigEdgeV1Chainer) IsSubscribed() bool {
	key := "configs.config.edge-orchestrator.intel.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *configConfigEdgeV1Chainer) addCallback(obj *ConfigConfig) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["multitenancies.tenancy.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[addCallback] received for configs.config.edge-orchestrator.intel.com name %s displayName %s parent multitenancies.tenancy.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	AddChild("multitenancies.tenancy.edge-orchestrator.intel.com", parentHashName, "configs.config.edge-orchestrator.intel.com", obj.Name)
}

func (c *configConfigEdgeV1Chainer) deleteCallback(obj *ConfigConfig) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["multitenancies.tenancy.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[deleteCallback] received for configs.config.edge-orchestrator.intel.com name %s displayName %s parent multitenancies.tenancy.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	RemoveChild("multitenancies.tenancy.edge-orchestrator.intel.com", parentHashName, "configs.config.edge-orchestrator.intel.com", obj.Name)
}

func (c *configConfigEdgeV1Chainer) RegisterEventHandler(addCB func(obj *ConfigConfig), updateCB func(oldObj, newObj *ConfigConfig), deleteCB func(obj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "configs.config.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigConfig, so creating a new one")
		informer = informerconfigedgeorchestratorintelcomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ConfigConfig{
				client: c.client,
				Config: obj.(*baseconfigedgeorchestratorintelcomv1.Config),
			}
			logger.Debugf("[RegisterEventHandler AddFunc] Got Add event for configs.config.edge-orchestrator.intel.com name %s", nc.Config.Name)

			var parent *TenancyMultiTenancy
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", nc.Labels, nc.Labels["multitenancies.tenancy.edge-orchestrator.intel.com"])
				parent, err = c.client.Tenancy().ForceReadMultiTenancyByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("multitenancies.tenancy.edge-orchestrator.intel.com", parent.Name, "configs.config.edge-orchestrator.intel.com", nc.Name) {
				AddChild("multitenancies.tenancy.edge-orchestrator.intel.com", parent.Name, "configs.config.edge-orchestrator.intel.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ConfigConfig{
				client: c.client,
				Config: oldObj.(*baseconfigedgeorchestratorintelcomv1.Config),
			}
			newData := &ConfigConfig{
				client: c.client,
				Config: newObj.(*baseconfigedgeorchestratorintelcomv1.Config),
			}
			logger.Debugf("[RegisterEventHandler UpdateFunc] Got Update event for configs.config.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.Config.Name, oldData.ResourceVersion, newData.ResourceVersion)
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &ConfigConfig{
				client: c.client,
				Config: obj.(*baseconfigedgeorchestratorintelcomv1.Config),
			}
			logger.Debugf("[RegisterEventHandler DeleteFunc] Got Delete event for configs.config.edge-orchestrator.intel.com name %s", nc.Config.Name)

			var parent *TenancyMultiTenancy
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", nc.Labels, nc.Labels["multitenancies.tenancy.edge-orchestrator.intel.com"])
				parent, err = c.client.Tenancy().ForceReadMultiTenancyByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("multitenancies.tenancy.edge-orchestrator.intel.com", parent.Name, "configs.config.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("multitenancies.tenancy.edge-orchestrator.intel.com", parent.Name, "configs.config.edge-orchestrator.intel.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *configConfigEdgeV1Chainer) RegisterAddCallback(cbfn func(obj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterAddCallback] Received for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "configs.config.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigConfig, so creating a new one")
		informer = informerconfigedgeorchestratorintelcomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ConfigConfig{
				client: c.client,
				Config: obj.(*baseconfigedgeorchestratorintelcomv1.Config),
			}
			logger.Debugf("[RegisterAddCallback] Got Add event for configs.config.edge-orchestrator.intel.com name %s", nc.Config.Name)

			var parent *TenancyMultiTenancy
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", nc.Labels, nc.Labels["multitenancies.tenancy.edge-orchestrator.intel.com"])
				parent, err = c.client.Tenancy().ForceReadMultiTenancyByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("multitenancies.tenancy.edge-orchestrator.intel.com", parent.Name, "configs.config.edge-orchestrator.intel.com", nc.Name) {
				AddChild("multitenancies.tenancy.edge-orchestrator.intel.com", parent.Name, "configs.config.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *configConfigEdgeV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterUpdateCallback] Received for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "configs.config.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigConfig, so creating a new one")
		informer = informerconfigedgeorchestratorintelcomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ConfigConfig{
				client: c.client,
				Config: oldObj.(*baseconfigedgeorchestratorintelcomv1.Config),
			}
			newData := &ConfigConfig{
				client: c.client,
				Config: newObj.(*baseconfigedgeorchestratorintelcomv1.Config),
			}
			logger.Debugf("[RegisterUpdateCallback] Got Update event for configs.config.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.Config.Name, oldData.ResourceVersion, newData.ResourceVersion)
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *configConfigEdgeV1Chainer) RegisterDeleteCallback(cbfn func(obj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterDeleteCallback] Received for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "configs.config.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigConfig, so creating a new one")
		informer = informerconfigedgeorchestratorintelcomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &ConfigConfig{
				client: c.client,
				Config: obj.(*baseconfigedgeorchestratorintelcomv1.Config),
			}
			logger.Debugf("[RegisterDeleteCallback] Got Delete event for configs.config.edge-orchestrator.intel.com name %s", nc.Config.Name)

			var parent *TenancyMultiTenancy
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", nc.Labels, nc.Labels["multitenancies.tenancy.edge-orchestrator.intel.com"])
				parent, err = c.client.Tenancy().ForceReadMultiTenancyByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("multitenancies.tenancy.edge-orchestrator.intel.com", parent.Name, "configs.config.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("multitenancies.tenancy.edge-orchestrator.intel.com", parent.Name, "configs.config.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *configConfigEdgeV1Chainer) Orgs(name string) *orgOrgEdgeV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["orgs.org.edge-orchestrator.intel.com"] = name
	return &orgOrgEdgeV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetOrgs calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigEdgeV1Chainer) GetOrgs(ctx context.Context, displayName string) (result *OrgOrg, err error) {
	hashedName := helper.GetHashedName("orgs.org.edge-orchestrator.intel.com", c.parentLabels, displayName)
	logger.Debugf("[GetOrgs] using chainer for name %s, displayName %s, labels %#v", hashedName, displayName, c.parentLabels)
	return c.client.Org().GetOrgByName(ctx, hashedName)
}

// AddOrgs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigEdgeV1Chainer) AddOrgs(ctx context.Context,
	objToCreate *baseorgedgeorchestratorintelcomv1.Org) (result *OrgOrg, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName("orgs.org.edge-orchestrator.intel.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Org().CreateOrgByName(ctx, objToCreate)
}

// DeleteOrgs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigEdgeV1Chainer) DeleteOrgs(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IsNameHashedLabel] = "true"
	hashedName := helper.GetHashedName("orgs.org.edge-orchestrator.intel.com", c.parentLabels, name)
	return c.client.Org().DeleteOrgByName(ctx, hashedName)
}

func (c *configConfigEdgeV1Chainer) OrgWatchers(name string) *orgwatcherOrgwatcherEdgeV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["orgwatchers.orgwatcher.edge-orchestrator.intel.com"] = name
	return &orgwatcherOrgwatcherEdgeV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetOrgWatchers calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigEdgeV1Chainer) GetOrgWatchers(ctx context.Context, displayName string) (result *OrgwatcherOrgWatcher, err error) {
	hashedName := helper.GetHashedName("orgwatchers.orgwatcher.edge-orchestrator.intel.com", c.parentLabels, displayName)
	logger.Debugf("[GetOrgWatchers] using chainer for name %s, displayName %s, labels %#v", hashedName, displayName, c.parentLabels)
	return c.client.Orgwatcher().GetOrgWatcherByName(ctx, hashedName)
}

// AddOrgWatchers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigEdgeV1Chainer) AddOrgWatchers(ctx context.Context,
	objToCreate *baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher) (result *OrgwatcherOrgWatcher, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName("orgwatchers.orgwatcher.edge-orchestrator.intel.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Orgwatcher().CreateOrgWatcherByName(ctx, objToCreate)
}

// DeleteOrgWatchers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigEdgeV1Chainer) DeleteOrgWatchers(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IsNameHashedLabel] = "true"
	hashedName := helper.GetHashedName("orgwatchers.orgwatcher.edge-orchestrator.intel.com", c.parentLabels, name)
	return c.client.Orgwatcher().DeleteOrgWatcherByName(ctx, hashedName)
}

func (c *configConfigEdgeV1Chainer) APIMappings(name string) *apimappingconfigApimappingconfigEdgeV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com"] = name
	return &apimappingconfigApimappingconfigEdgeV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAPIMappings calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigEdgeV1Chainer) GetAPIMappings(ctx context.Context, displayName string) (result *ApimappingconfigAPIMappingConfig, err error) {
	hashedName := helper.GetHashedName("apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", c.parentLabels, displayName)
	logger.Debugf("[GetAPIMappings] using chainer for name %s, displayName %s, labels %#v", hashedName, displayName, c.parentLabels)
	return c.client.Apimappingconfig().GetAPIMappingConfigByName(ctx, hashedName)
}

// AddAPIMappings calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigEdgeV1Chainer) AddAPIMappings(ctx context.Context,
	objToCreate *baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig) (result *ApimappingconfigAPIMappingConfig, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName("apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Apimappingconfig().CreateAPIMappingConfigByName(ctx, objToCreate)
}

// DeleteAPIMappings calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigEdgeV1Chainer) DeleteAPIMappings(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IsNameHashedLabel] = "true"
	hashedName := helper.GetHashedName("apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", c.parentLabels, name)
	return c.client.Apimappingconfig().DeleteAPIMappingConfigByName(ctx, hashedName)
}

func (c *configConfigEdgeV1Chainer) ProjectWatchers(name string) *projectwatcherProjectwatcherEdgeV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["projectwatchers.projectwatcher.edge-orchestrator.intel.com"] = name
	return &projectwatcherProjectwatcherEdgeV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetProjectWatchers calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigEdgeV1Chainer) GetProjectWatchers(ctx context.Context, displayName string) (result *ProjectwatcherProjectWatcher, err error) {
	hashedName := helper.GetHashedName("projectwatchers.projectwatcher.edge-orchestrator.intel.com", c.parentLabels, displayName)
	logger.Debugf("[GetProjectWatchers] using chainer for name %s, displayName %s, labels %#v", hashedName, displayName, c.parentLabels)
	return c.client.Projectwatcher().GetProjectWatcherByName(ctx, hashedName)
}

// AddProjectWatchers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigEdgeV1Chainer) AddProjectWatchers(ctx context.Context,
	objToCreate *baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher) (result *ProjectwatcherProjectWatcher, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName("projectwatchers.projectwatcher.edge-orchestrator.intel.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Projectwatcher().CreateProjectWatcherByName(ctx, objToCreate)
}

// DeleteProjectWatchers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigEdgeV1Chainer) DeleteProjectWatchers(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IsNameHashedLabel] = "true"
	hashedName := helper.GetHashedName("projectwatchers.projectwatcher.edge-orchestrator.intel.com", c.parentLabels, name)
	return c.client.Projectwatcher().DeleteProjectWatcherByName(ctx, hashedName)
}

func (group *ApimappingconfigEdgeV1) GetAPIMappingConfigChildrenMap() map[string]baseapimappingconfigedgeorchestratorintelcomv1.Child {
	return map[string]baseapimappingconfigedgeorchestratorintelcomv1.Child{}
}

func (group *ApimappingconfigEdgeV1) GetAPIMappingConfigChild(grp, kind, name string) baseapimappingconfigedgeorchestratorintelcomv1.Child {
	return baseapimappingconfigedgeorchestratorintelcomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetAPIMappingConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ApimappingconfigEdgeV1) GetAPIMappingConfigByName(ctx context.Context, hashedName string) (*ApimappingconfigAPIMappingConfig, error) {
	key := "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			logger.Debugf("[GetAPIMappingConfigByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				logger.Fatalf("[GetAPIMappingConfigByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig).ResourceVersion)
				if writeCacheVersionErr != nil {
					logger.Fatalf("[GetAPIMappingConfigByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &ApimappingconfigAPIMappingConfig{
					client:           group.client,
					APIMappingConfig: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &ApimappingconfigAPIMappingConfig{
				client:           group.client,
				APIMappingConfig: resWrCache.(*baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ApimappingconfigEdgeV1().
			APIMappingConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &ApimappingconfigAPIMappingConfig{
				client:           group.client,
				APIMappingConfig: result,
			}, nil
		} else if errors.IsNotFound(err) {
			logger.Debugf("[GetAPIMappingConfigByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on Get APIMappingConfigs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[GetAPIMappingConfigByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[GetAPIMappingConfigByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadAPIMappingConfigByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ApimappingconfigEdgeV1) ForceReadAPIMappingConfigByName(ctx context.Context, hashedName string) (*ApimappingconfigAPIMappingConfig, error) {
	logger.Debugf("[ForceReadAPIMappingConfigByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ApimappingconfigEdgeV1().
			APIMappingConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[ForceReadAPIMappingConfigByName] Failed to Get APIMappingConfigs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max Retry exceed on Get APIMappingConfigs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[ForceReadAPIMappingConfigByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[ForceReadAPIMappingConfigByName]: %+v", err)
				return nil, err
			}
		} else {
			logger.Debugf("[ForceReadAPIMappingConfigByName] Executed Successfully :%s", hashedName)
			return &ApimappingconfigAPIMappingConfig{
				client:           group.client,
				APIMappingConfig: result,
			}, nil
		}
	}
}

// DeleteAPIMappingConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ApimappingconfigEdgeV1) DeleteAPIMappingConfigByName(ctx context.Context, hashedName string) (err error) {
	logger.Debugf("[DeleteAPIMappingConfigByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ApimappingconfigEdgeV1().
			APIMappingConfigs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[DeleteAPIMappingConfigByName] Failed to get APIMappingConfigs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on get APIMappingConfigs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteAPIMappingConfigByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteAPIMappingConfigByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteAPIMappingConfigByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			ApimappingconfigEdgeV1().
			APIMappingConfigs().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			logger.Errorf("[DeleteAPIMappingConfigByName] failed to delete APIMappingConfigs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on delete APIMappingConfigs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteAPIMappingConfigByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteAPIMappingConfigByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteAPIMappingConfigByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	logger.Debugf("[DeleteAPIMappingConfigByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	if result.GetLabels() != nil {
		if parents[common.IsNameHashedLabel] == "true" {
			parentName = helper.GetHashedName("configs.config.edge-orchestrator.intel.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("configs.config.edge-orchestrator.intel.com", parents, parentName)
	}
	RemoveChild("configs.config.edge-orchestrator.intel.com", parentName, "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", hashedName)

	return nil
}

// CreateAPIMappingConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ApimappingconfigEdgeV1) CreateAPIMappingConfigByName(ctx context.Context,
	objToCreate *baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig) (*ApimappingconfigAPIMappingConfig, error) {
	logger.Debugf("[CreateAPIMappingConfigByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DisplayNameLabel]; !ok {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ApimappingconfigEdgeV1().
			APIMappingConfigs().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			logger.Errorf("[CreateAPIMappingConfigByName] Failed to create APIMappingConfig: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on create APIMappingConfig: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[CreateAPIMappingConfigByName] context canceled while creating APIMappingConfig: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				logger.Debugf("[CreateAPIMappingConfigByName] APIMappingConfig: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.ApimappingconfigEdgeV1().APIMappingConfigs().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					logger.Fatalf("[CreateAPIMappingConfigByName] Unable to Get APIMappingConfig %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				logger.Errorf("[CreateAPIMappingConfigByName] found unexpected error while creating APIMappingConfig: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			logger.Debugf("[CreateAPIMappingConfigByName] APIMappingConfig: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[CreateAPIMappingConfigByName] APIMappingConfig: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	parentHashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", objToCreate.GetLabels(), parentName)

	AddChild("configs.config.edge-orchestrator.intel.com", parentHashedName, "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", objToCreate.Name)

	logger.Debugf("[CreateAPIMappingConfigByName] Executed Successfully: %s", objToCreate.GetName())
	return &ApimappingconfigAPIMappingConfig{
		client:           group.client,
		APIMappingConfig: result,
	}, nil
}

// UpdateAPIMappingConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ApimappingconfigEdgeV1) UpdateAPIMappingConfigByName(ctx context.Context,
	objToUpdate *baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig) (*ApimappingconfigAPIMappingConfig, error) {
	logger.Debugf("[UpdateAPIMappingConfigByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Apimappingconfig().GetAPIMappingConfigByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IsNameHashedLabel] = current.Labels[common.IsNameHashedLabel]
			objToUpdate.Labels[common.DisplayNameLabel] = current.Labels[common.DisplayNameLabel]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.SpecGenEnabled)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.SpecGenEnabled).IsNil() {
			patchValueSpecGenEnabled := objToUpdate.Spec.SpecGenEnabled
			patchOpSpecGenEnabled := PatchOp{
				Op:    "replace",
				Path:  "/spec/specGenEnabled",
				Value: patchValueSpecGenEnabled,
			}
			patch = append(patch, patchOpSpecGenEnabled)
		}
	} else {
		patchValueSpecGenEnabled := objToUpdate.Spec.SpecGenEnabled
		patchOpSpecGenEnabled := PatchOp{
			Op:    "replace",
			Path:  "/spec/specGenEnabled",
			Value: patchValueSpecGenEnabled,
		}
		patch = append(patch, patchOpSpecGenEnabled)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.RepoConf)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.RepoConf).IsNil() {
			patchValueRepoConf := objToUpdate.Spec.RepoConf
			patchOpRepoConf := PatchOp{
				Op:    "replace",
				Path:  "/spec/repoConf",
				Value: patchValueRepoConf,
			}
			patch = append(patch, patchOpRepoConf)
		}
	} else {
		patchValueRepoConf := objToUpdate.Spec.RepoConf
		patchOpRepoConf := PatchOp{
			Op:    "replace",
			Path:  "/spec/repoConf",
			Value: patchValueRepoConf,
		}
		patch = append(patch, patchOpRepoConf)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Mappings)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Mappings).IsNil() {
			patchValueMappings := objToUpdate.Spec.Mappings
			patchOpMappings := PatchOp{
				Op:    "replace",
				Path:  "/spec/mappings",
				Value: patchValueMappings,
			}
			patch = append(patch, patchOpMappings)
		}
	} else {
		patchValueMappings := objToUpdate.Spec.Mappings
		patchOpMappings := PatchOp{
			Op:    "replace",
			Path:  "/spec/mappings",
			Value: patchValueMappings,
		}
		patch = append(patch, patchOpMappings)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Backend)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Backend).IsNil() {
			patchValueBackend := objToUpdate.Spec.Backend
			patchOpBackend := PatchOp{
				Op:    "replace",
				Path:  "/spec/backend",
				Value: patchValueBackend,
			}
			patch = append(patch, patchOpBackend)
		}
	} else {
		patchValueBackend := objToUpdate.Spec.Backend
		patchOpBackend := PatchOp{
			Op:    "replace",
			Path:  "/spec/backend",
			Value: patchValueBackend,
		}
		patch = append(patch, patchOpBackend)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			ApimappingconfigEdgeV1().
			APIMappingConfigs().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			logger.Errorf("[UpdateAPIMappingConfigByName] Failed to patch APIMappingConfig %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					logger.Debugf("Trigger APIMappingConfig Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteAPIMappingConfigByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						logger.Debugf("Error occur while deleting APIMappingConfig: %s", objToUpdate.GetName())
						return nil, delErr
					}
					logger.Debugf("APIMappingConfig deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[UpdateAPIMappingConfigByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				logger.Errorf("[UpdateAPIMappingConfigByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				logger.Debugf("Trigger APIMappingConfig Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteAPIMappingConfigByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					logger.Debugf("Error occur while deleting APIMappingConfig: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				logger.Debugf("APIMappingConfig Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			logger.Debugf("[UpdateAPIMappingConfigByName] Patch APIMappingConfig Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[UpdateAPIMappingConfigByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	logger.Debugf("[UpdateAPIMappingConfigByName] Executed Successfully %s", objToUpdate.GetName())
	return &ApimappingconfigAPIMappingConfig{
		client:           group.client,
		APIMappingConfig: result,
	}, nil
}

// ListAPIMappingConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ApimappingconfigEdgeV1) ListAPIMappingConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*ApimappingconfigAPIMappingConfig, err error) {
	key := "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*ApimappingconfigAPIMappingConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig)
			result[k] = &ApimappingconfigAPIMappingConfig{
				client:           group.client,
				APIMappingConfig: item,
			}
		}
	} else {
		list, err := group.client.baseClient.ApimappingconfigEdgeV1().
			APIMappingConfigs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*ApimappingconfigAPIMappingConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &ApimappingconfigAPIMappingConfig{
				client:           group.client,
				APIMappingConfig: &item,
			}
		}
	}
	return
}

type ApimappingconfigAPIMappingConfig struct {
	client *Clientset
	*baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig
}

// Delete removes obj and all it's children from the database.
func (obj *ApimappingconfigAPIMappingConfig) Delete(ctx context.Context) error {
	err := obj.client.Apimappingconfig().DeleteAPIMappingConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.APIMappingConfig = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ApimappingconfigAPIMappingConfig) Update(ctx context.Context) error {
	result, err := obj.client.Apimappingconfig().UpdateAPIMappingConfigByName(ctx, obj.APIMappingConfig)
	if err != nil {
		return err
	}
	obj.APIMappingConfig = result.APIMappingConfig
	return nil
}

func (obj *ApimappingconfigAPIMappingConfig) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", obj.Labels, obj.Labels["configs.config.edge-orchestrator.intel.com"])
	logger.Debugf("[GetParent] Get parent of ApimappingconfigAPIMappingConfig name %s [labels %#v] of parent type configs.config.edge-orchestrator.intel.com and name %s", obj.Name, obj.Labels, hashedName)
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type apimappingconfigApimappingconfigEdgeV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *apimappingconfigApimappingconfigEdgeV1Chainer) Subscribe() {
	key := "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerapimappingconfigedgeorchestratorintelcomv1.NewAPIMappingConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *apimappingconfigApimappingconfigEdgeV1Chainer) Unsubscribe() {
	key := "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *apimappingconfigApimappingconfigEdgeV1Chainer) IsSubscribed() bool {
	key := "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *apimappingconfigApimappingconfigEdgeV1Chainer) addCallback(obj *ApimappingconfigAPIMappingConfig) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["configs.config.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[addCallback] received for apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com name %s displayName %s parent configs.config.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	AddChild("configs.config.edge-orchestrator.intel.com", parentHashName, "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", obj.Name)
}

func (c *apimappingconfigApimappingconfigEdgeV1Chainer) deleteCallback(obj *ApimappingconfigAPIMappingConfig) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["configs.config.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[deleteCallback] received for apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com name %s displayName %s parent configs.config.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	RemoveChild("configs.config.edge-orchestrator.intel.com", parentHashName, "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", obj.Name)
}

func (c *apimappingconfigApimappingconfigEdgeV1Chainer) RegisterEventHandler(addCB func(obj *ApimappingconfigAPIMappingConfig), updateCB func(oldObj, newObj *ApimappingconfigAPIMappingConfig), deleteCB func(obj *ApimappingconfigAPIMappingConfig)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for ApimappingconfigAPIMappingConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ApimappingconfigAPIMappingConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ApimappingconfigAPIMappingConfig, so creating a new one")
		informer = informerapimappingconfigedgeorchestratorintelcomv1.NewAPIMappingConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ApimappingconfigAPIMappingConfig{
				client:           c.client,
				APIMappingConfig: obj.(*baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig),
			}
			logger.Debugf("[RegisterEventHandler AddFunc] Got Add event for apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com name %s", nc.APIMappingConfig.Name)

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", nc.Labels, nc.Labels["configs.config.edge-orchestrator.intel.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("configs.config.edge-orchestrator.intel.com", parent.Name, "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", nc.Name) {
				AddChild("configs.config.edge-orchestrator.intel.com", parent.Name, "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ApimappingconfigAPIMappingConfig{
				client:           c.client,
				APIMappingConfig: oldObj.(*baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig),
			}
			newData := &ApimappingconfigAPIMappingConfig{
				client:           c.client,
				APIMappingConfig: newObj.(*baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig),
			}
			logger.Debugf("[RegisterEventHandler UpdateFunc] Got Update event for apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.APIMappingConfig.Name, oldData.ResourceVersion, newData.ResourceVersion)
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &ApimappingconfigAPIMappingConfig{
				client:           c.client,
				APIMappingConfig: obj.(*baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig),
			}
			logger.Debugf("[RegisterEventHandler DeleteFunc] Got Delete event for apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com name %s", nc.APIMappingConfig.Name)

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", nc.Labels, nc.Labels["configs.config.edge-orchestrator.intel.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("configs.config.edge-orchestrator.intel.com", parent.Name, "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("configs.config.edge-orchestrator.intel.com", parent.Name, "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *apimappingconfigApimappingconfigEdgeV1Chainer) RegisterAddCallback(cbfn func(obj *ApimappingconfigAPIMappingConfig)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterAddCallback] Received for ApimappingconfigAPIMappingConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ApimappingconfigAPIMappingConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ApimappingconfigAPIMappingConfig, so creating a new one")
		informer = informerapimappingconfigedgeorchestratorintelcomv1.NewAPIMappingConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ApimappingconfigAPIMappingConfig{
				client:           c.client,
				APIMappingConfig: obj.(*baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig),
			}
			logger.Debugf("[RegisterAddCallback] Got Add event for apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com name %s", nc.APIMappingConfig.Name)

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", nc.Labels, nc.Labels["configs.config.edge-orchestrator.intel.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("configs.config.edge-orchestrator.intel.com", parent.Name, "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", nc.Name) {
				AddChild("configs.config.edge-orchestrator.intel.com", parent.Name, "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *apimappingconfigApimappingconfigEdgeV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *ApimappingconfigAPIMappingConfig)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterUpdateCallback] Received for ApimappingconfigAPIMappingConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ApimappingconfigAPIMappingConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ApimappingconfigAPIMappingConfig, so creating a new one")
		informer = informerapimappingconfigedgeorchestratorintelcomv1.NewAPIMappingConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ApimappingconfigAPIMappingConfig{
				client:           c.client,
				APIMappingConfig: oldObj.(*baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig),
			}
			newData := &ApimappingconfigAPIMappingConfig{
				client:           c.client,
				APIMappingConfig: newObj.(*baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig),
			}
			logger.Debugf("[RegisterUpdateCallback] Got Update event for apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.APIMappingConfig.Name, oldData.ResourceVersion, newData.ResourceVersion)
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *apimappingconfigApimappingconfigEdgeV1Chainer) RegisterDeleteCallback(cbfn func(obj *ApimappingconfigAPIMappingConfig)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterDeleteCallback] Received for ApimappingconfigAPIMappingConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ApimappingconfigAPIMappingConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ApimappingconfigAPIMappingConfig, so creating a new one")
		informer = informerapimappingconfigedgeorchestratorintelcomv1.NewAPIMappingConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &ApimappingconfigAPIMappingConfig{
				client:           c.client,
				APIMappingConfig: obj.(*baseapimappingconfigedgeorchestratorintelcomv1.APIMappingConfig),
			}
			logger.Debugf("[RegisterDeleteCallback] Got Delete event for apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com name %s", nc.APIMappingConfig.Name)

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", nc.Labels, nc.Labels["configs.config.edge-orchestrator.intel.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("configs.config.edge-orchestrator.intel.com", parent.Name, "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("configs.config.edge-orchestrator.intel.com", parent.Name, "apimappingconfigs.apimappingconfig.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (group *OrgEdgeV1) GetOrgChildrenMap() map[string]baseorgedgeorchestratorintelcomv1.Child {
	return map[string]baseorgedgeorchestratorintelcomv1.Child{}
}

func (group *OrgEdgeV1) GetOrgChild(grp, kind, name string) baseorgedgeorchestratorintelcomv1.Child {
	return baseorgedgeorchestratorintelcomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetOrgByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *OrgEdgeV1) GetOrgByName(ctx context.Context, hashedName string) (*OrgOrg, error) {
	key := "orgs.org.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			logger.Debugf("[GetOrgByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseorgedgeorchestratorintelcomv1.Org)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				logger.Fatalf("[GetOrgByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseorgedgeorchestratorintelcomv1.Org).ResourceVersion)
				if writeCacheVersionErr != nil {
					logger.Fatalf("[GetOrgByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &OrgOrg{
					client: group.client,
					Org:    resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &OrgOrg{
				client: group.client,
				Org:    resWrCache.(*baseorgedgeorchestratorintelcomv1.Org),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			OrgEdgeV1().
			Orgs().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &OrgOrg{
				client: group.client,
				Org:    result,
			}, nil
		} else if errors.IsNotFound(err) {
			logger.Debugf("[GetOrgByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on Get Orgs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[GetOrgByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[GetOrgByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadOrgByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *OrgEdgeV1) ForceReadOrgByName(ctx context.Context, hashedName string) (*OrgOrg, error) {
	logger.Debugf("[ForceReadOrgByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			OrgEdgeV1().
			Orgs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[ForceReadOrgByName] Failed to Get Orgs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max Retry exceed on Get Orgs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[ForceReadOrgByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[ForceReadOrgByName]: %+v", err)
				return nil, err
			}
		} else {
			logger.Debugf("[ForceReadOrgByName] Executed Successfully :%s", hashedName)
			return &OrgOrg{
				client: group.client,
				Org:    result,
			}, nil
		}
	}
}

// DeleteOrgByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *OrgEdgeV1) DeleteOrgByName(ctx context.Context, hashedName string) (err error) {
	logger.Debugf("[DeleteOrgByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseorgedgeorchestratorintelcomv1.Org
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			OrgEdgeV1().
			Orgs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[DeleteOrgByName] Failed to get Orgs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on get Orgs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteOrgByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteOrgByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteOrgByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("orgs.org.edge-orchestrator.intel.com", hashedName, "folders.folder.edge-orchestrator.intel.com") {
		err := group.client.Folder().DeleteFolderByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("orgs.org.edge-orchestrator.intel.com", hashedName, "folders.folder.edge-orchestrator.intel.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			OrgEdgeV1().
			Orgs().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			logger.Errorf("[DeleteOrgByName] failed to delete Orgs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on delete Orgs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteOrgByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteOrgByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteOrgByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("orgs.org.edge-orchestrator.intel.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	logger.Debugf("[DeleteOrgByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	if result.GetLabels() != nil {
		if parents[common.IsNameHashedLabel] == "true" {
			parentName = helper.GetHashedName("configs.config.edge-orchestrator.intel.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("configs.config.edge-orchestrator.intel.com", parents, parentName)
	}
	RemoveChild("configs.config.edge-orchestrator.intel.com", parentName, "orgs.org.edge-orchestrator.intel.com", hashedName)

	return nil
}

// CreateOrgByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *OrgEdgeV1) CreateOrgByName(ctx context.Context,
	objToCreate *baseorgedgeorchestratorintelcomv1.Org) (*OrgOrg, error) {
	logger.Debugf("[CreateOrgByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DisplayNameLabel]; !ok {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
	}

	logger.Debugf("[CreateOrgByName] Node is marked for deferred delete: %s", objToCreate.GetName())
	found := false
	for _, finalizer := range objToCreate.Finalizers {
		if finalizer == nexusDeferredDeleteAnnotation {
			found = true
			break
		}
	}
	if !found {
		objToCreate.Finalizers = append(objToCreate.Finalizers, nexusDeferredDeleteAnnotation)
		logger.Debugf("[CreateOrgByName] Added %s finalizer to node: %s", nexusDeferredDeleteAnnotation, objToCreate.GetName())
	}

	objToCreate.Spec.FoldersGvk = nil

	var (
		retryCount int
		result     *baseorgedgeorchestratorintelcomv1.Org
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			OrgEdgeV1().
			Orgs().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			logger.Errorf("[CreateOrgByName] Failed to create Org: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on create Org: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[CreateOrgByName] context canceled while creating Org: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				logger.Debugf("[CreateOrgByName] Org: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.OrgEdgeV1().Orgs().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					logger.Fatalf("[CreateOrgByName] Unable to Get Org %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				logger.Errorf("[CreateOrgByName] found unexpected error while creating Org: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			logger.Debugf("[CreateOrgByName] Org: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("orgs.org.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[CreateOrgByName] Org: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	parentHashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", objToCreate.GetLabels(), parentName)

	AddChild("configs.config.edge-orchestrator.intel.com", parentHashedName, "orgs.org.edge-orchestrator.intel.com", objToCreate.Name)

	logger.Debugf("[CreateOrgByName] Executed Successfully: %s", objToCreate.GetName())
	return &OrgOrg{
		client: group.client,
		Org:    result,
	}, nil
}

// SetOrgOrgStatusByName sets user defined status
func (group *OrgEdgeV1) SetOrgOrgStatusByName(ctx context.Context,
	objToUpdate *baseorgedgeorchestratorintelcomv1.Org, status *baseorgedgeorchestratorintelcomv1.OrgStatus) (*OrgOrg, error) {
	logger.Debugf("[SetOrgOrgStatusByName] Received objToUpdate:%s", objToUpdate.GetName())

	gvr := schema.GroupVersionResource{
		Group:    "org.edge-orchestrator.intel.com",
		Version:  "v1",
		Resource: strings.ToLower("Orgs"),
	}

	hashedName := objToUpdate.ObjectMeta.Name
	obj := baseorgedgeorchestratorintelcomv1.Org{}
	obj.Kind = strings.ToLower("Orgs")
	obj.APIVersion = "org.edge-orchestrator.intel.com/v1"
	obj.ObjectMeta = objToUpdate.ObjectMeta
	obj.Status.OrgStatus = *status

	var mapInterface map[string]interface{}
	marshalledObj, _ := json.Marshal(&obj)
	json.Unmarshal(marshalledObj, &mapInterface)

	newCtx := context.TODO()
	retryCount := 0
	for {
		_, err := group.client.DynamicClient.Resource(gvr).UpdateStatus(ctx, &unstructured.Unstructured{Object: mapInterface}, metav1.UpdateOptions{})
		if err == nil {
			logger.Debugf("[SetOrgOrgStatusByName] Updating status for Org node %s successful", hashedName)
			break
		}

		logger.Errorf("[SetOrgOrgStatusByName] Updating status for Org node: %s failed with error %v. Retrying...", hashedName, err)

		updatedObj, err := group.ForceReadOrgByName(newCtx, hashedName)
		if err == nil {
			obj.ObjectMeta = updatedObj.ObjectMeta
			marshalledObj, _ := json.Marshal(&obj)
			json.Unmarshal(marshalledObj, &mapInterface)
		}

		retryCount += 1
		if retryCount == maxRetryCount1SecSleep {
			logger.Fatalf("[SetOrgOrgStatusByName] Max retry exceeded for updating status for Org node: %s", hashedName)
			return nil, err
		}
		time.Sleep(time.Second)
	}

	/*
		if s, ok := subscriptionMap.Load("orgs.org.edge-orchestrator.intel.com"); ok {
			resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
			var objectToWrite *baseorgedgeorchestratorintelcomv1.Org
			if inWrCache {
				objectToWrite = resWrCache.(*baseorgedgeorchestratorintelcomv1.Org)
				objectToWrite.Status.OrgStatus = *status
			} else {
				// Object is not in write cache. Populate the write cache with last "known" object.
				// TBD: Is this right ???
				//      Can we expect ObjectToUpdate to the latest version of the object ?
				//      What if we received the object spec but only want to update the status ?
				//      Get on the object will return a object form cache if the cache has newer version.
				// 		So proceeding with assumption that if newer version is available, user will get the newer version anyways.
				objectToWrite = objToUpdate
				objToUpdate.Status.OrgStatus = *status
			}
			s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), objectToWrite)
		}
	*/
	return &OrgOrg{
		client: group.client,
		Org:    objToUpdate, // TBD: To be fixed to return back the "result"
	}, nil
}

// UpdateOrgByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *OrgEdgeV1) UpdateOrgByName(ctx context.Context,
	objToUpdate *baseorgedgeorchestratorintelcomv1.Org) (*OrgOrg, error) {
	logger.Debugf("[UpdateOrgByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Org().GetOrgByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["orgs.org.edge-orchestrator.intel.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IsNameHashedLabel] = current.Labels[common.IsNameHashedLabel]
			objToUpdate.Labels[common.DisplayNameLabel] = current.Labels[common.DisplayNameLabel]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Description)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Description).IsNil() {
			patchValueDescription := objToUpdate.Spec.Description
			patchOpDescription := PatchOp{
				Op:    "replace",
				Path:  "/spec/description",
				Value: patchValueDescription,
			}
			patch = append(patch, patchOpDescription)
		}
	} else {
		patchValueDescription := objToUpdate.Spec.Description
		patchOpDescription := PatchOp{
			Op:    "replace",
			Path:  "/spec/description",
			Value: patchValueDescription,
		}
		patch = append(patch, patchOpDescription)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseorgedgeorchestratorintelcomv1.Org
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			OrgEdgeV1().
			Orgs().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			logger.Errorf("[UpdateOrgByName] Failed to patch Org %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					logger.Debugf("Trigger Org Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteOrgByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						logger.Debugf("Error occur while deleting Org: %s", objToUpdate.GetName())
						return nil, delErr
					}
					logger.Debugf("Org deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[UpdateOrgByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				logger.Errorf("[UpdateOrgByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				logger.Debugf("Trigger Org Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteOrgByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					logger.Debugf("Error occur while deleting Org: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				logger.Debugf("Org Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			logger.Debugf("[UpdateOrgByName] Patch Org Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("orgs.org.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[UpdateOrgByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	logger.Debugf("[UpdateOrgByName] Executed Successfully %s", objToUpdate.GetName())
	return &OrgOrg{
		client: group.client,
		Org:    result,
	}, nil
}

// ListOrgs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *OrgEdgeV1) ListOrgs(ctx context.Context,
	opts metav1.ListOptions) (result []*OrgOrg, err error) {
	key := "orgs.org.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*OrgOrg, len(items))
		for k, v := range items {
			item, _ := v.(*baseorgedgeorchestratorintelcomv1.Org)
			result[k] = &OrgOrg{
				client: group.client,
				Org:    item,
			}
		}
	} else {
		list, err := group.client.baseClient.OrgEdgeV1().
			Orgs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*OrgOrg, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &OrgOrg{
				client: group.client,
				Org:    &item,
			}
		}
	}
	return
}

type OrgOrg struct {
	client *Clientset
	*baseorgedgeorchestratorintelcomv1.Org
}

// Delete removes obj and all it's children from the database.
func (obj *OrgOrg) Delete(ctx context.Context) error {
	err := obj.client.Org().DeleteOrgByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Org = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *OrgOrg) Update(ctx context.Context) error {
	result, err := obj.client.Org().UpdateOrgByName(ctx, obj.Org)
	if err != nil {
		return err
	}
	obj.Org = result.Org
	return nil
}

// SetOrgStatus sets user defined status
func (obj *OrgOrg) SetOrgStatus(ctx context.Context, status *baseorgedgeorchestratorintelcomv1.OrgStatus) error {
	logger.Debugf("[OrgOrg SetOrgStatus] Set status for object with name %s", obj.GetName())
	result, err := obj.client.Org().SetOrgOrgStatusByName(ctx, obj.Org, status)
	if err != nil {
		logger.Errorf("[OrgOrg SetOrgStatus] Set status for object with name %s failed with error %v", obj.GetName(), err)
		return err
	}
	obj.Org = result.Org
	return nil
}

// GetOrgStatus to get user defined status
func (obj *OrgOrg) GetOrgStatus(ctx context.Context) (*baseorgedgeorchestratorintelcomv1.OrgStatus, error) {
	getObj, err := obj.client.Org().GetOrgByName(ctx, obj.GetName())
	if err != nil {
		return nil, err
	}
	return &getObj.Status.OrgStatus, nil
}

// ClearOrgStatus to clear user defined status
func (obj *OrgOrg) ClearOrgStatus(ctx context.Context) error {
	logger.Debugf("[OrgOrg ClearOrgStatus] Set status for object with name %s", obj.GetName())
	result, err := obj.client.Org().SetOrgOrgStatusByName(ctx, obj.Org, &baseorgedgeorchestratorintelcomv1.OrgStatus{})
	if err != nil {
		logger.Errorf("[OrgOrg ClearOrgStatus] Clear status for object with name %s failed with error %v", obj.GetName(), err)
		return err
	}
	obj.Org = result.Org
	return nil
}

func (obj *OrgOrg) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", obj.Labels, obj.Labels["configs.config.edge-orchestrator.intel.com"])
	logger.Debugf("[GetParent] Get parent of OrgOrg name %s [labels %#v] of parent type configs.config.edge-orchestrator.intel.com and name %s", obj.Name, obj.Labels, hashedName)
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type OrgOrgFolders struct {
	client  *Clientset
	Folders []baseorgedgeorchestratorintelcomv1.Child
}

func (n *OrgOrgFolders) Next(ctx context.Context) (*FolderFolder, error) {
	for index, child := range n.Folders {
		logger.Debugf("[OrgOrgFolders Next] Get next Folders with name %s", child.Name)
		obj, err := n.client.Folder().GetFolderByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Folders)-1 {
				n.Folders = nil
			} else {
				n.Folders = n.Folders[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllFoldersIter returns an iterator for all children of given type
func (obj *OrgOrg) GetAllFoldersIter(ctx context.Context) (
	result OrgOrgFolders) {
	result.client = obj.client
	for _, v := range GetChildren("orgs.org.edge-orchestrator.intel.com", obj.Name, "folders.folder.edge-orchestrator.intel.com") {
		result.Folders = append(result.Folders, baseorgedgeorchestratorintelcomv1.Child{
			Group: "folder.edge-orchestrator.intel.com",
			Kind:  "Folder",
			Name:  v,
		})
	}
	return
}

// GetAllFolders returns all children of a given type
func (obj *OrgOrg) GetAllFolders(ctx context.Context) (
	result []*FolderFolder, err error) {
	for _, v := range GetChildren("orgs.org.edge-orchestrator.intel.com", obj.Name, "folders.folder.edge-orchestrator.intel.com") {
		logger.Debugf("[OrgOrg GetAllFolders] Get next Folders with name %s", v)
		l, err := obj.client.Folder().GetFolderByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetFolders returns child which has given displayName
func (obj *OrgOrg) GetFolders(ctx context.Context,
	displayName string) (result *FolderFolder, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["orgs.org.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("folders.folder.edge-orchestrator.intel.com", parentLabels, displayName)
	logger.Debugf("[GetFolders] in OrgOrg with name %s, displayName %s, parentLabels %#v", childHashName, displayName, parentLabels)
	if IsChildExists("orgs.org.edge-orchestrator.intel.com", obj.Name, "folders.folder.edge-orchestrator.intel.com", childHashName) == false {
		logger.Debugf("[GetFolders] ChildNotFound Folders with name %s, displayName %s ", childHashName, displayName)
		return nil, NewChildNotFound(obj.DisplayName(), "Org.Org", "Folders", displayName)
	}

	logger.Debugf("[GetFolders] invoke GetFolderByName name %s, displayName %s", childHashName, displayName)
	result, err = obj.client.Folder().GetFolderByName(ctx, childHashName)
	return
}

// AddFolders calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *OrgOrg) AddFolders(ctx context.Context,
	objToCreate *basefolderedgeorchestratorintelcomv1.Folder) (result *FolderFolder, err error) {
	logger.Debugf("[AddFolders] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["orgs.org.edge-orchestrator.intel.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["orgs.org.edge-orchestrator.intel.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Folder().CreateFolderByName(ctx, objToCreate)
	logger.Debugf("[AddFolders] Folder created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Org().GetOrgByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Org = updatedObj.Org
	}
	logger.Debugf("[AddFolders] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteFolders calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *OrgOrg) DeleteFolders(ctx context.Context, displayName string) (err error) {
	logger.Debugf("[ DeleteFolders] Received for Folder object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["orgs.org.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("folders.folder.edge-orchestrator.intel.com", parentLabels, displayName)
	if IsChildExists("orgs.org.edge-orchestrator.intel.com", obj.Name, "folders.folder.edge-orchestrator.intel.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Org.Org", "Folders", displayName)
	}

	err = obj.client.Folder().DeleteFolderByName(ctx, childHashName)
	if err != nil {
		return err
	}
	logger.Debugf("[ DeleteFolders] Folder object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Org().GetOrgByName(ctx, obj.GetName())
	if err == nil {
		obj.Org = updatedObj.Org
	}
	return
}

type orgOrgEdgeV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *orgOrgEdgeV1Chainer) Subscribe() {
	key := "orgs.org.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerorgedgeorchestratorintelcomv1.NewOrgInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *orgOrgEdgeV1Chainer) Unsubscribe() {
	key := "orgs.org.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *orgOrgEdgeV1Chainer) IsSubscribed() bool {
	key := "orgs.org.edge-orchestrator.intel.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *orgOrgEdgeV1Chainer) addCallback(obj *OrgOrg) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["configs.config.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[addCallback] received for orgs.org.edge-orchestrator.intel.com name %s displayName %s parent configs.config.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	AddChild("configs.config.edge-orchestrator.intel.com", parentHashName, "orgs.org.edge-orchestrator.intel.com", obj.Name)
}

func (c *orgOrgEdgeV1Chainer) deleteCallback(obj *OrgOrg) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["configs.config.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[deleteCallback] received for orgs.org.edge-orchestrator.intel.com name %s displayName %s parent configs.config.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	RemoveChild("configs.config.edge-orchestrator.intel.com", parentHashName, "orgs.org.edge-orchestrator.intel.com", obj.Name)
}

func (c *orgOrgEdgeV1Chainer) RegisterEventHandler(addCB func(obj *OrgOrg), updateCB func(oldObj, newObj *OrgOrg), deleteCB func(obj *OrgOrg)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for OrgOrg")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "orgs.org.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for OrgOrg")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for OrgOrg, so creating a new one")
		informer = informerorgedgeorchestratorintelcomv1.NewOrgInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &OrgOrg{
				client: c.client,
				Org:    obj.(*baseorgedgeorchestratorintelcomv1.Org),
			}
			logger.Debugf("[RegisterEventHandler AddFunc] Got Add event for orgs.org.edge-orchestrator.intel.com name %s", nc.Org.Name)

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", nc.Labels, nc.Labels["configs.config.edge-orchestrator.intel.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("configs.config.edge-orchestrator.intel.com", parent.Name, "orgs.org.edge-orchestrator.intel.com", nc.Name) {
				AddChild("configs.config.edge-orchestrator.intel.com", parent.Name, "orgs.org.edge-orchestrator.intel.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &OrgOrg{
				client: c.client,
				Org:    oldObj.(*baseorgedgeorchestratorintelcomv1.Org),
			}
			newData := &OrgOrg{
				client: c.client,
				Org:    newObj.(*baseorgedgeorchestratorintelcomv1.Org),
			}
			logger.Debugf("[RegisterEventHandler UpdateFunc] Got Update event for orgs.org.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.Org.Name, oldData.ResourceVersion, newData.ResourceVersion)
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &OrgOrg{
				client: c.client,
				Org:    obj.(*baseorgedgeorchestratorintelcomv1.Org),
			}
			logger.Debugf("[RegisterEventHandler DeleteFunc] Got Delete event for orgs.org.edge-orchestrator.intel.com name %s", nc.Org.Name)

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", nc.Labels, nc.Labels["configs.config.edge-orchestrator.intel.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("configs.config.edge-orchestrator.intel.com", parent.Name, "orgs.org.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("configs.config.edge-orchestrator.intel.com", parent.Name, "orgs.org.edge-orchestrator.intel.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *orgOrgEdgeV1Chainer) RegisterAddCallback(cbfn func(obj *OrgOrg)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterAddCallback] Received for OrgOrg")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "orgs.org.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for OrgOrg")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for OrgOrg, so creating a new one")
		informer = informerorgedgeorchestratorintelcomv1.NewOrgInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &OrgOrg{
				client: c.client,
				Org:    obj.(*baseorgedgeorchestratorintelcomv1.Org),
			}
			logger.Debugf("[RegisterAddCallback] Got Add event for orgs.org.edge-orchestrator.intel.com name %s", nc.Org.Name)

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", nc.Labels, nc.Labels["configs.config.edge-orchestrator.intel.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("configs.config.edge-orchestrator.intel.com", parent.Name, "orgs.org.edge-orchestrator.intel.com", nc.Name) {
				AddChild("configs.config.edge-orchestrator.intel.com", parent.Name, "orgs.org.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *orgOrgEdgeV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *OrgOrg)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterUpdateCallback] Received for OrgOrg")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "orgs.org.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for OrgOrg")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for OrgOrg, so creating a new one")
		informer = informerorgedgeorchestratorintelcomv1.NewOrgInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &OrgOrg{
				client: c.client,
				Org:    oldObj.(*baseorgedgeorchestratorintelcomv1.Org),
			}
			newData := &OrgOrg{
				client: c.client,
				Org:    newObj.(*baseorgedgeorchestratorintelcomv1.Org),
			}
			logger.Debugf("[RegisterUpdateCallback] Got Update event for orgs.org.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.Org.Name, oldData.ResourceVersion, newData.ResourceVersion)
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *orgOrgEdgeV1Chainer) RegisterDeleteCallback(cbfn func(obj *OrgOrg)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterDeleteCallback] Received for OrgOrg")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "orgs.org.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for OrgOrg")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for OrgOrg, so creating a new one")
		informer = informerorgedgeorchestratorintelcomv1.NewOrgInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &OrgOrg{
				client: c.client,
				Org:    obj.(*baseorgedgeorchestratorintelcomv1.Org),
			}
			logger.Debugf("[RegisterDeleteCallback] Got Delete event for orgs.org.edge-orchestrator.intel.com name %s", nc.Org.Name)

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", nc.Labels, nc.Labels["configs.config.edge-orchestrator.intel.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("configs.config.edge-orchestrator.intel.com", parent.Name, "orgs.org.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("configs.config.edge-orchestrator.intel.com", parent.Name, "orgs.org.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

// ClearOrgStatus to clear user defined status
func (c *orgOrgEdgeV1Chainer) ClearOrgStatus(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("orgs.org.edge-orchestrator.intel.com", c.parentLabels, c.name)
	logger.Debugf("[orgOrgEdgeV1Chainer ClearOrgStatus] Clear status for object with name %s", hashedName)
	obj, err := c.client.Org().GetOrgByName(ctx, hashedName)
	if err != nil {
		logger.Errorf("[orgOrgEdgeV1Chainer ClearOrgStatus] Clear status for object with name %s failed with error %v", hashedName, err)
		return err
	}
	_, err = c.client.Org().SetOrgOrgStatusByName(ctx, obj.Org, nil)
	return err
}

// GetOrgStatus to get user defined status
func (c *orgOrgEdgeV1Chainer) GetOrgStatus(ctx context.Context) (result *baseorgedgeorchestratorintelcomv1.OrgStatus, err error) {
	hashedName := helper.GetHashedName("orgs.org.edge-orchestrator.intel.com", c.parentLabels, c.name)
	obj, err := c.client.Org().GetOrgByName(ctx, hashedName)
	if err != nil {
		return nil, err
	}
	return &obj.Status.OrgStatus, nil
}

// SetOrgStatus sets user defined status
func (c *orgOrgEdgeV1Chainer) SetOrgStatus(ctx context.Context, status *baseorgedgeorchestratorintelcomv1.OrgStatus) (err error) {
	hashedName := helper.GetHashedName("orgs.org.edge-orchestrator.intel.com", c.parentLabels, c.name)
	logger.Debugf("[orgOrgEdgeV1Chainer SetOrgStatus] Set status for object with name %s", hashedName)
	obj, err := c.client.Org().GetOrgByName(ctx, hashedName)
	if err != nil {
		logger.Errorf("[orgOrgEdgeV1Chainer SetOrgStatus] Set status for object with name %s failed with error %v", hashedName, err)
		return err
	}
	_, err = c.client.Org().SetOrgOrgStatusByName(ctx, obj.Org, status)
	return err
}

func (c *orgOrgEdgeV1Chainer) Folders(name string) *folderFolderEdgeV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["folders.folder.edge-orchestrator.intel.com"] = name
	return &folderFolderEdgeV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetFolders calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *orgOrgEdgeV1Chainer) GetFolders(ctx context.Context, displayName string) (result *FolderFolder, err error) {
	hashedName := helper.GetHashedName("folders.folder.edge-orchestrator.intel.com", c.parentLabels, displayName)
	logger.Debugf("[GetFolders] using chainer for name %s, displayName %s, labels %#v", hashedName, displayName, c.parentLabels)
	return c.client.Folder().GetFolderByName(ctx, hashedName)
}

// AddFolders calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *orgOrgEdgeV1Chainer) AddFolders(ctx context.Context,
	objToCreate *basefolderedgeorchestratorintelcomv1.Folder) (result *FolderFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName("folders.folder.edge-orchestrator.intel.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Folder().CreateFolderByName(ctx, objToCreate)
}

// DeleteFolders calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *orgOrgEdgeV1Chainer) DeleteFolders(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IsNameHashedLabel] = "true"
	hashedName := helper.GetHashedName("folders.folder.edge-orchestrator.intel.com", c.parentLabels, name)
	return c.client.Folder().DeleteFolderByName(ctx, hashedName)
}

func (group *FolderEdgeV1) GetFolderChildrenMap() map[string]basefolderedgeorchestratorintelcomv1.Child {
	return map[string]basefolderedgeorchestratorintelcomv1.Child{}
}

func (group *FolderEdgeV1) GetFolderChild(grp, kind, name string) basefolderedgeorchestratorintelcomv1.Child {
	return basefolderedgeorchestratorintelcomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *FolderEdgeV1) GetFolderByName(ctx context.Context, hashedName string) (*FolderFolder, error) {
	key := "folders.folder.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			logger.Debugf("[GetFolderByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basefolderedgeorchestratorintelcomv1.Folder)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				logger.Fatalf("[GetFolderByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basefolderedgeorchestratorintelcomv1.Folder).ResourceVersion)
				if writeCacheVersionErr != nil {
					logger.Fatalf("[GetFolderByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &FolderFolder{
					client: group.client,
					Folder: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &FolderFolder{
				client: group.client,
				Folder: resWrCache.(*basefolderedgeorchestratorintelcomv1.Folder),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			FolderEdgeV1().
			Folders().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &FolderFolder{
				client: group.client,
				Folder: result,
			}, nil
		} else if errors.IsNotFound(err) {
			logger.Debugf("[GetFolderByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on Get Folders: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[GetFolderByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[GetFolderByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadFolderByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *FolderEdgeV1) ForceReadFolderByName(ctx context.Context, hashedName string) (*FolderFolder, error) {
	logger.Debugf("[ForceReadFolderByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			FolderEdgeV1().
			Folders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[ForceReadFolderByName] Failed to Get Folders: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max Retry exceed on Get Folders: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[ForceReadFolderByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[ForceReadFolderByName]: %+v", err)
				return nil, err
			}
		} else {
			logger.Debugf("[ForceReadFolderByName] Executed Successfully :%s", hashedName)
			return &FolderFolder{
				client: group.client,
				Folder: result,
			}, nil
		}
	}
}

// DeleteFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *FolderEdgeV1) DeleteFolderByName(ctx context.Context, hashedName string) (err error) {
	logger.Debugf("[DeleteFolderByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basefolderedgeorchestratorintelcomv1.Folder
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			FolderEdgeV1().
			Folders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[DeleteFolderByName] Failed to get Folders: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on get Folders: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteFolderByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteFolderByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteFolderByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("folders.folder.edge-orchestrator.intel.com", hashedName, "projects.project.edge-orchestrator.intel.com") {
		err := group.client.Project().DeleteProjectByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("folders.folder.edge-orchestrator.intel.com", hashedName, "projects.project.edge-orchestrator.intel.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			FolderEdgeV1().
			Folders().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			logger.Errorf("[DeleteFolderByName] failed to delete Folders: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on delete Folders: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteFolderByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteFolderByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteFolderByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("folders.folder.edge-orchestrator.intel.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	logger.Debugf("[DeleteFolderByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["orgs.org.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	if result.GetLabels() != nil {
		if parents[common.IsNameHashedLabel] == "true" {
			parentName = helper.GetHashedName("orgs.org.edge-orchestrator.intel.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("orgs.org.edge-orchestrator.intel.com", parents, parentName)
	}
	RemoveChild("orgs.org.edge-orchestrator.intel.com", parentName, "folders.folder.edge-orchestrator.intel.com", hashedName)

	return nil
}

// CreateFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *FolderEdgeV1) CreateFolderByName(ctx context.Context,
	objToCreate *basefolderedgeorchestratorintelcomv1.Folder) (*FolderFolder, error) {
	logger.Debugf("[CreateFolderByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DisplayNameLabel]; !ok {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
	}

	objToCreate.Spec.ProjectsGvk = nil

	var (
		retryCount int
		result     *basefolderedgeorchestratorintelcomv1.Folder
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			FolderEdgeV1().
			Folders().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			logger.Errorf("[CreateFolderByName] Failed to create Folder: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on create Folder: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[CreateFolderByName] context canceled while creating Folder: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				logger.Debugf("[CreateFolderByName] Folder: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.FolderEdgeV1().Folders().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					logger.Fatalf("[CreateFolderByName] Unable to Get Folder %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				logger.Errorf("[CreateFolderByName] found unexpected error while creating Folder: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			logger.Debugf("[CreateFolderByName] Folder: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("folders.folder.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[CreateFolderByName] Folder: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["orgs.org.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	parentHashedName := helper.GetHashedName("orgs.org.edge-orchestrator.intel.com", objToCreate.GetLabels(), parentName)

	AddChild("orgs.org.edge-orchestrator.intel.com", parentHashedName, "folders.folder.edge-orchestrator.intel.com", objToCreate.Name)

	logger.Debugf("[CreateFolderByName] Executed Successfully: %s", objToCreate.GetName())
	return &FolderFolder{
		client: group.client,
		Folder: result,
	}, nil
}

// UpdateFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *FolderEdgeV1) UpdateFolderByName(ctx context.Context,
	objToUpdate *basefolderedgeorchestratorintelcomv1.Folder) (*FolderFolder, error) {
	logger.Debugf("[UpdateFolderByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Folder().GetFolderByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["folders.folder.edge-orchestrator.intel.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IsNameHashedLabel] = current.Labels[common.IsNameHashedLabel]
			objToUpdate.Labels[common.DisplayNameLabel] = current.Labels[common.DisplayNameLabel]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basefolderedgeorchestratorintelcomv1.Folder
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			FolderEdgeV1().
			Folders().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			logger.Errorf("[UpdateFolderByName] Failed to patch Folder %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					logger.Debugf("Trigger Folder Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteFolderByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						logger.Debugf("Error occur while deleting Folder: %s", objToUpdate.GetName())
						return nil, delErr
					}
					logger.Debugf("Folder deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[UpdateFolderByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				logger.Errorf("[UpdateFolderByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				logger.Debugf("Trigger Folder Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteFolderByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					logger.Debugf("Error occur while deleting Folder: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				logger.Debugf("Folder Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			logger.Debugf("[UpdateFolderByName] Patch Folder Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("folders.folder.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[UpdateFolderByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	logger.Debugf("[UpdateFolderByName] Executed Successfully %s", objToUpdate.GetName())
	return &FolderFolder{
		client: group.client,
		Folder: result,
	}, nil
}

// ListFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *FolderEdgeV1) ListFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*FolderFolder, err error) {
	key := "folders.folder.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*FolderFolder, len(items))
		for k, v := range items {
			item, _ := v.(*basefolderedgeorchestratorintelcomv1.Folder)
			result[k] = &FolderFolder{
				client: group.client,
				Folder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.FolderEdgeV1().
			Folders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*FolderFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &FolderFolder{
				client: group.client,
				Folder: &item,
			}
		}
	}
	return
}

type FolderFolder struct {
	client *Clientset
	*basefolderedgeorchestratorintelcomv1.Folder
}

// Delete removes obj and all it's children from the database.
func (obj *FolderFolder) Delete(ctx context.Context) error {
	err := obj.client.Folder().DeleteFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Folder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *FolderFolder) Update(ctx context.Context) error {
	result, err := obj.client.Folder().UpdateFolderByName(ctx, obj.Folder)
	if err != nil {
		return err
	}
	obj.Folder = result.Folder
	return nil
}

func (obj *FolderFolder) GetParent(ctx context.Context) (result *OrgOrg, err error) {
	hashedName := helper.GetHashedName("orgs.org.edge-orchestrator.intel.com", obj.Labels, obj.Labels["orgs.org.edge-orchestrator.intel.com"])
	logger.Debugf("[GetParent] Get parent of FolderFolder name %s [labels %#v] of parent type orgs.org.edge-orchestrator.intel.com and name %s", obj.Name, obj.Labels, hashedName)
	return obj.client.Org().GetOrgByName(ctx, hashedName)
}

type FolderFolderProjects struct {
	client   *Clientset
	Projects []basefolderedgeorchestratorintelcomv1.Child
}

func (n *FolderFolderProjects) Next(ctx context.Context) (*ProjectProject, error) {
	for index, child := range n.Projects {
		logger.Debugf("[FolderFolderProjects Next] Get next Projects with name %s", child.Name)
		obj, err := n.client.Project().GetProjectByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Projects)-1 {
				n.Projects = nil
			} else {
				n.Projects = n.Projects[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllProjectsIter returns an iterator for all children of given type
func (obj *FolderFolder) GetAllProjectsIter(ctx context.Context) (
	result FolderFolderProjects) {
	result.client = obj.client
	for _, v := range GetChildren("folders.folder.edge-orchestrator.intel.com", obj.Name, "projects.project.edge-orchestrator.intel.com") {
		result.Projects = append(result.Projects, basefolderedgeorchestratorintelcomv1.Child{
			Group: "project.edge-orchestrator.intel.com",
			Kind:  "Project",
			Name:  v,
		})
	}
	return
}

// GetAllProjects returns all children of a given type
func (obj *FolderFolder) GetAllProjects(ctx context.Context) (
	result []*ProjectProject, err error) {
	for _, v := range GetChildren("folders.folder.edge-orchestrator.intel.com", obj.Name, "projects.project.edge-orchestrator.intel.com") {
		logger.Debugf("[FolderFolder GetAllProjects] Get next Projects with name %s", v)
		l, err := obj.client.Project().GetProjectByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetProjects returns child which has given displayName
func (obj *FolderFolder) GetProjects(ctx context.Context,
	displayName string) (result *ProjectProject, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["folders.folder.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("projects.project.edge-orchestrator.intel.com", parentLabels, displayName)
	logger.Debugf("[GetProjects] in FolderFolder with name %s, displayName %s, parentLabels %#v", childHashName, displayName, parentLabels)
	if IsChildExists("folders.folder.edge-orchestrator.intel.com", obj.Name, "projects.project.edge-orchestrator.intel.com", childHashName) == false {
		logger.Debugf("[GetProjects] ChildNotFound Projects with name %s, displayName %s ", childHashName, displayName)
		return nil, NewChildNotFound(obj.DisplayName(), "Folder.Folder", "Projects", displayName)
	}

	logger.Debugf("[GetProjects] invoke GetProjectByName name %s, displayName %s", childHashName, displayName)
	result, err = obj.client.Project().GetProjectByName(ctx, childHashName)
	return
}

// AddProjects calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *FolderFolder) AddProjects(ctx context.Context,
	objToCreate *baseprojectedgeorchestratorintelcomv1.Project) (result *ProjectProject, err error) {
	logger.Debugf("[AddProjects] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["folders.folder.edge-orchestrator.intel.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["folders.folder.edge-orchestrator.intel.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Project().CreateProjectByName(ctx, objToCreate)
	logger.Debugf("[AddProjects] Project created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Folder().GetFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Folder = updatedObj.Folder
	}
	logger.Debugf("[AddProjects] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteProjects calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *FolderFolder) DeleteProjects(ctx context.Context, displayName string) (err error) {
	logger.Debugf("[ DeleteProjects] Received for Project object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["folders.folder.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("projects.project.edge-orchestrator.intel.com", parentLabels, displayName)
	if IsChildExists("folders.folder.edge-orchestrator.intel.com", obj.Name, "projects.project.edge-orchestrator.intel.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Folder.Folder", "Projects", displayName)
	}

	err = obj.client.Project().DeleteProjectByName(ctx, childHashName)
	if err != nil {
		return err
	}
	logger.Debugf("[ DeleteProjects] Project object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Folder().GetFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.Folder = updatedObj.Folder
	}
	return
}

type folderFolderEdgeV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *folderFolderEdgeV1Chainer) Subscribe() {
	key := "folders.folder.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerfolderedgeorchestratorintelcomv1.NewFolderInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *folderFolderEdgeV1Chainer) Unsubscribe() {
	key := "folders.folder.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *folderFolderEdgeV1Chainer) IsSubscribed() bool {
	key := "folders.folder.edge-orchestrator.intel.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *folderFolderEdgeV1Chainer) addCallback(obj *FolderFolder) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["orgs.org.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("orgs.org.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[addCallback] received for folders.folder.edge-orchestrator.intel.com name %s displayName %s parent orgs.org.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	AddChild("orgs.org.edge-orchestrator.intel.com", parentHashName, "folders.folder.edge-orchestrator.intel.com", obj.Name)
}

func (c *folderFolderEdgeV1Chainer) deleteCallback(obj *FolderFolder) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["orgs.org.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("orgs.org.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[deleteCallback] received for folders.folder.edge-orchestrator.intel.com name %s displayName %s parent orgs.org.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	RemoveChild("orgs.org.edge-orchestrator.intel.com", parentHashName, "folders.folder.edge-orchestrator.intel.com", obj.Name)
}

func (c *folderFolderEdgeV1Chainer) RegisterEventHandler(addCB func(obj *FolderFolder), updateCB func(oldObj, newObj *FolderFolder), deleteCB func(obj *FolderFolder)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for FolderFolder")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "folders.folder.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for FolderFolder")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for FolderFolder, so creating a new one")
		informer = informerfolderedgeorchestratorintelcomv1.NewFolderInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &FolderFolder{
				client: c.client,
				Folder: obj.(*basefolderedgeorchestratorintelcomv1.Folder),
			}
			logger.Debugf("[RegisterEventHandler AddFunc] Got Add event for folders.folder.edge-orchestrator.intel.com name %s", nc.Folder.Name)

			var parent *OrgOrg
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("orgs.org.edge-orchestrator.intel.com", nc.Labels, nc.Labels["orgs.org.edge-orchestrator.intel.com"])
				parent, err = c.client.Org().ForceReadOrgByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("orgs.org.edge-orchestrator.intel.com", parent.Name, "folders.folder.edge-orchestrator.intel.com", nc.Name) {
				AddChild("orgs.org.edge-orchestrator.intel.com", parent.Name, "folders.folder.edge-orchestrator.intel.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &FolderFolder{
				client: c.client,
				Folder: oldObj.(*basefolderedgeorchestratorintelcomv1.Folder),
			}
			newData := &FolderFolder{
				client: c.client,
				Folder: newObj.(*basefolderedgeorchestratorintelcomv1.Folder),
			}
			logger.Debugf("[RegisterEventHandler UpdateFunc] Got Update event for folders.folder.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.Folder.Name, oldData.ResourceVersion, newData.ResourceVersion)
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &FolderFolder{
				client: c.client,
				Folder: obj.(*basefolderedgeorchestratorintelcomv1.Folder),
			}
			logger.Debugf("[RegisterEventHandler DeleteFunc] Got Delete event for folders.folder.edge-orchestrator.intel.com name %s", nc.Folder.Name)

			var parent *OrgOrg
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("orgs.org.edge-orchestrator.intel.com", nc.Labels, nc.Labels["orgs.org.edge-orchestrator.intel.com"])
				parent, err = c.client.Org().ForceReadOrgByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("orgs.org.edge-orchestrator.intel.com", parent.Name, "folders.folder.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("orgs.org.edge-orchestrator.intel.com", parent.Name, "folders.folder.edge-orchestrator.intel.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *folderFolderEdgeV1Chainer) RegisterAddCallback(cbfn func(obj *FolderFolder)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterAddCallback] Received for FolderFolder")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "folders.folder.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for FolderFolder")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for FolderFolder, so creating a new one")
		informer = informerfolderedgeorchestratorintelcomv1.NewFolderInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &FolderFolder{
				client: c.client,
				Folder: obj.(*basefolderedgeorchestratorintelcomv1.Folder),
			}
			logger.Debugf("[RegisterAddCallback] Got Add event for folders.folder.edge-orchestrator.intel.com name %s", nc.Folder.Name)

			var parent *OrgOrg
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("orgs.org.edge-orchestrator.intel.com", nc.Labels, nc.Labels["orgs.org.edge-orchestrator.intel.com"])
				parent, err = c.client.Org().ForceReadOrgByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("orgs.org.edge-orchestrator.intel.com", parent.Name, "folders.folder.edge-orchestrator.intel.com", nc.Name) {
				AddChild("orgs.org.edge-orchestrator.intel.com", parent.Name, "folders.folder.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *folderFolderEdgeV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *FolderFolder)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterUpdateCallback] Received for FolderFolder")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "folders.folder.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for FolderFolder")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for FolderFolder, so creating a new one")
		informer = informerfolderedgeorchestratorintelcomv1.NewFolderInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &FolderFolder{
				client: c.client,
				Folder: oldObj.(*basefolderedgeorchestratorintelcomv1.Folder),
			}
			newData := &FolderFolder{
				client: c.client,
				Folder: newObj.(*basefolderedgeorchestratorintelcomv1.Folder),
			}
			logger.Debugf("[RegisterUpdateCallback] Got Update event for folders.folder.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.Folder.Name, oldData.ResourceVersion, newData.ResourceVersion)
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *folderFolderEdgeV1Chainer) RegisterDeleteCallback(cbfn func(obj *FolderFolder)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterDeleteCallback] Received for FolderFolder")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "folders.folder.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for FolderFolder")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for FolderFolder, so creating a new one")
		informer = informerfolderedgeorchestratorintelcomv1.NewFolderInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &FolderFolder{
				client: c.client,
				Folder: obj.(*basefolderedgeorchestratorintelcomv1.Folder),
			}
			logger.Debugf("[RegisterDeleteCallback] Got Delete event for folders.folder.edge-orchestrator.intel.com name %s", nc.Folder.Name)

			var parent *OrgOrg
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("orgs.org.edge-orchestrator.intel.com", nc.Labels, nc.Labels["orgs.org.edge-orchestrator.intel.com"])
				parent, err = c.client.Org().ForceReadOrgByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("orgs.org.edge-orchestrator.intel.com", parent.Name, "folders.folder.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("orgs.org.edge-orchestrator.intel.com", parent.Name, "folders.folder.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *folderFolderEdgeV1Chainer) Projects(name string) *projectProjectEdgeV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["projects.project.edge-orchestrator.intel.com"] = name
	return &projectProjectEdgeV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetProjects calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *folderFolderEdgeV1Chainer) GetProjects(ctx context.Context, displayName string) (result *ProjectProject, err error) {
	hashedName := helper.GetHashedName("projects.project.edge-orchestrator.intel.com", c.parentLabels, displayName)
	logger.Debugf("[GetProjects] using chainer for name %s, displayName %s, labels %#v", hashedName, displayName, c.parentLabels)
	return c.client.Project().GetProjectByName(ctx, hashedName)
}

// AddProjects calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *folderFolderEdgeV1Chainer) AddProjects(ctx context.Context,
	objToCreate *baseprojectedgeorchestratorintelcomv1.Project) (result *ProjectProject, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName("projects.project.edge-orchestrator.intel.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Project().CreateProjectByName(ctx, objToCreate)
}

// DeleteProjects calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *folderFolderEdgeV1Chainer) DeleteProjects(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IsNameHashedLabel] = "true"
	hashedName := helper.GetHashedName("projects.project.edge-orchestrator.intel.com", c.parentLabels, name)
	return c.client.Project().DeleteProjectByName(ctx, hashedName)
}

func (group *ProjectEdgeV1) GetProjectChildrenMap() map[string]baseprojectedgeorchestratorintelcomv1.Child {
	return map[string]baseprojectedgeorchestratorintelcomv1.Child{}
}

func (group *ProjectEdgeV1) GetProjectChild(grp, kind, name string) baseprojectedgeorchestratorintelcomv1.Child {
	return baseprojectedgeorchestratorintelcomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetProjectByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ProjectEdgeV1) GetProjectByName(ctx context.Context, hashedName string) (*ProjectProject, error) {
	key := "projects.project.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			logger.Debugf("[GetProjectByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseprojectedgeorchestratorintelcomv1.Project)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				logger.Fatalf("[GetProjectByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseprojectedgeorchestratorintelcomv1.Project).ResourceVersion)
				if writeCacheVersionErr != nil {
					logger.Fatalf("[GetProjectByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &ProjectProject{
					client:  group.client,
					Project: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &ProjectProject{
				client:  group.client,
				Project: resWrCache.(*baseprojectedgeorchestratorintelcomv1.Project),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ProjectEdgeV1().
			Projects().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &ProjectProject{
				client:  group.client,
				Project: result,
			}, nil
		} else if errors.IsNotFound(err) {
			logger.Debugf("[GetProjectByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on Get Projects: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[GetProjectByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[GetProjectByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadProjectByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ProjectEdgeV1) ForceReadProjectByName(ctx context.Context, hashedName string) (*ProjectProject, error) {
	logger.Debugf("[ForceReadProjectByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ProjectEdgeV1().
			Projects().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[ForceReadProjectByName] Failed to Get Projects: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max Retry exceed on Get Projects: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[ForceReadProjectByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[ForceReadProjectByName]: %+v", err)
				return nil, err
			}
		} else {
			logger.Debugf("[ForceReadProjectByName] Executed Successfully :%s", hashedName)
			return &ProjectProject{
				client:  group.client,
				Project: result,
			}, nil
		}
	}
}

// DeleteProjectByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ProjectEdgeV1) DeleteProjectByName(ctx context.Context, hashedName string) (err error) {
	logger.Debugf("[DeleteProjectByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseprojectedgeorchestratorintelcomv1.Project
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ProjectEdgeV1().
			Projects().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[DeleteProjectByName] Failed to get Projects: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on get Projects: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteProjectByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteProjectByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteProjectByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("projects.project.edge-orchestrator.intel.com", hashedName, "networks.network.edge-orchestrator.intel.com") {
		err := group.client.Network().DeleteNetworkByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("projects.project.edge-orchestrator.intel.com", hashedName, "networks.network.edge-orchestrator.intel.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			ProjectEdgeV1().
			Projects().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			logger.Errorf("[DeleteProjectByName] failed to delete Projects: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on delete Projects: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteProjectByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteProjectByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteProjectByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("projects.project.edge-orchestrator.intel.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	logger.Debugf("[DeleteProjectByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["folders.folder.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	if result.GetLabels() != nil {
		if parents[common.IsNameHashedLabel] == "true" {
			parentName = helper.GetHashedName("folders.folder.edge-orchestrator.intel.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("folders.folder.edge-orchestrator.intel.com", parents, parentName)
	}
	RemoveChild("folders.folder.edge-orchestrator.intel.com", parentName, "projects.project.edge-orchestrator.intel.com", hashedName)

	return nil
}

// CreateProjectByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ProjectEdgeV1) CreateProjectByName(ctx context.Context,
	objToCreate *baseprojectedgeorchestratorintelcomv1.Project) (*ProjectProject, error) {
	logger.Debugf("[CreateProjectByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DisplayNameLabel]; !ok {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
	}

	logger.Debugf("[CreateProjectByName] Node is marked for deferred delete: %s", objToCreate.GetName())
	found := false
	for _, finalizer := range objToCreate.Finalizers {
		if finalizer == nexusDeferredDeleteAnnotation {
			found = true
			break
		}
	}
	if !found {
		objToCreate.Finalizers = append(objToCreate.Finalizers, nexusDeferredDeleteAnnotation)
		logger.Debugf("[CreateProjectByName] Added %s finalizer to node: %s", nexusDeferredDeleteAnnotation, objToCreate.GetName())
	}

	objToCreate.Spec.NetworksGvk = nil

	var (
		retryCount int
		result     *baseprojectedgeorchestratorintelcomv1.Project
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ProjectEdgeV1().
			Projects().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			logger.Errorf("[CreateProjectByName] Failed to create Project: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on create Project: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[CreateProjectByName] context canceled while creating Project: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				logger.Debugf("[CreateProjectByName] Project: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.ProjectEdgeV1().Projects().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					logger.Fatalf("[CreateProjectByName] Unable to Get Project %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				logger.Errorf("[CreateProjectByName] found unexpected error while creating Project: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			logger.Debugf("[CreateProjectByName] Project: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("projects.project.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[CreateProjectByName] Project: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["folders.folder.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	parentHashedName := helper.GetHashedName("folders.folder.edge-orchestrator.intel.com", objToCreate.GetLabels(), parentName)

	AddChild("folders.folder.edge-orchestrator.intel.com", parentHashedName, "projects.project.edge-orchestrator.intel.com", objToCreate.Name)

	logger.Debugf("[CreateProjectByName] Executed Successfully: %s", objToCreate.GetName())
	return &ProjectProject{
		client:  group.client,
		Project: result,
	}, nil
}

// SetProjectProjectStatusByName sets user defined status
func (group *ProjectEdgeV1) SetProjectProjectStatusByName(ctx context.Context,
	objToUpdate *baseprojectedgeorchestratorintelcomv1.Project, status *baseprojectedgeorchestratorintelcomv1.ProjectStatus) (*ProjectProject, error) {
	logger.Debugf("[SetProjectProjectStatusByName] Received objToUpdate:%s", objToUpdate.GetName())

	gvr := schema.GroupVersionResource{
		Group:    "project.edge-orchestrator.intel.com",
		Version:  "v1",
		Resource: strings.ToLower("Projects"),
	}

	hashedName := objToUpdate.ObjectMeta.Name
	obj := baseprojectedgeorchestratorintelcomv1.Project{}
	obj.Kind = strings.ToLower("Projects")
	obj.APIVersion = "project.edge-orchestrator.intel.com/v1"
	obj.ObjectMeta = objToUpdate.ObjectMeta
	obj.Status.ProjectStatus = *status

	var mapInterface map[string]interface{}
	marshalledObj, _ := json.Marshal(&obj)
	json.Unmarshal(marshalledObj, &mapInterface)

	newCtx := context.TODO()
	retryCount := 0
	for {
		_, err := group.client.DynamicClient.Resource(gvr).UpdateStatus(ctx, &unstructured.Unstructured{Object: mapInterface}, metav1.UpdateOptions{})
		if err == nil {
			logger.Debugf("[SetProjectProjectStatusByName] Updating status for Project node %s successful", hashedName)
			break
		}

		logger.Errorf("[SetProjectProjectStatusByName] Updating status for Project node: %s failed with error %v. Retrying...", hashedName, err)

		updatedObj, err := group.ForceReadProjectByName(newCtx, hashedName)
		if err == nil {
			obj.ObjectMeta = updatedObj.ObjectMeta
			marshalledObj, _ := json.Marshal(&obj)
			json.Unmarshal(marshalledObj, &mapInterface)
		}

		retryCount += 1
		if retryCount == maxRetryCount1SecSleep {
			logger.Fatalf("[SetProjectProjectStatusByName] Max retry exceeded for updating status for Project node: %s", hashedName)
			return nil, err
		}
		time.Sleep(time.Second)
	}

	/*
		if s, ok := subscriptionMap.Load("projects.project.edge-orchestrator.intel.com"); ok {
			resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
			var objectToWrite *baseprojectedgeorchestratorintelcomv1.Project
			if inWrCache {
				objectToWrite = resWrCache.(*baseprojectedgeorchestratorintelcomv1.Project)
				objectToWrite.Status.ProjectStatus = *status
			} else {
				// Object is not in write cache. Populate the write cache with last "known" object.
				// TBD: Is this right ???
				//      Can we expect ObjectToUpdate to the latest version of the object ?
				//      What if we received the object spec but only want to update the status ?
				//      Get on the object will return a object form cache if the cache has newer version.
				// 		So proceeding with assumption that if newer version is available, user will get the newer version anyways.
				objectToWrite = objToUpdate
				objToUpdate.Status.ProjectStatus = *status
			}
			s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), objectToWrite)
		}
	*/
	return &ProjectProject{
		client:  group.client,
		Project: objToUpdate, // TBD: To be fixed to return back the "result"
	}, nil
}

// UpdateProjectByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ProjectEdgeV1) UpdateProjectByName(ctx context.Context,
	objToUpdate *baseprojectedgeorchestratorintelcomv1.Project) (*ProjectProject, error) {
	logger.Debugf("[UpdateProjectByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Project().GetProjectByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["projects.project.edge-orchestrator.intel.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IsNameHashedLabel] = current.Labels[common.IsNameHashedLabel]
			objToUpdate.Labels[common.DisplayNameLabel] = current.Labels[common.DisplayNameLabel]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Description)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Description).IsNil() {
			patchValueDescription := objToUpdate.Spec.Description
			patchOpDescription := PatchOp{
				Op:    "replace",
				Path:  "/spec/description",
				Value: patchValueDescription,
			}
			patch = append(patch, patchOpDescription)
		}
	} else {
		patchValueDescription := objToUpdate.Spec.Description
		patchOpDescription := PatchOp{
			Op:    "replace",
			Path:  "/spec/description",
			Value: patchValueDescription,
		}
		patch = append(patch, patchOpDescription)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseprojectedgeorchestratorintelcomv1.Project
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			ProjectEdgeV1().
			Projects().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			logger.Errorf("[UpdateProjectByName] Failed to patch Project %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					logger.Debugf("Trigger Project Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteProjectByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						logger.Debugf("Error occur while deleting Project: %s", objToUpdate.GetName())
						return nil, delErr
					}
					logger.Debugf("Project deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[UpdateProjectByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				logger.Errorf("[UpdateProjectByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				logger.Debugf("Trigger Project Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteProjectByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					logger.Debugf("Error occur while deleting Project: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				logger.Debugf("Project Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			logger.Debugf("[UpdateProjectByName] Patch Project Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("projects.project.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[UpdateProjectByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	logger.Debugf("[UpdateProjectByName] Executed Successfully %s", objToUpdate.GetName())
	return &ProjectProject{
		client:  group.client,
		Project: result,
	}, nil
}

// ListProjects returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ProjectEdgeV1) ListProjects(ctx context.Context,
	opts metav1.ListOptions) (result []*ProjectProject, err error) {
	key := "projects.project.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*ProjectProject, len(items))
		for k, v := range items {
			item, _ := v.(*baseprojectedgeorchestratorintelcomv1.Project)
			result[k] = &ProjectProject{
				client:  group.client,
				Project: item,
			}
		}
	} else {
		list, err := group.client.baseClient.ProjectEdgeV1().
			Projects().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*ProjectProject, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &ProjectProject{
				client:  group.client,
				Project: &item,
			}
		}
	}
	return
}

type ProjectProject struct {
	client *Clientset
	*baseprojectedgeorchestratorintelcomv1.Project
}

// Delete removes obj and all it's children from the database.
func (obj *ProjectProject) Delete(ctx context.Context) error {
	err := obj.client.Project().DeleteProjectByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Project = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ProjectProject) Update(ctx context.Context) error {
	result, err := obj.client.Project().UpdateProjectByName(ctx, obj.Project)
	if err != nil {
		return err
	}
	obj.Project = result.Project
	return nil
}

// SetProjectStatus sets user defined status
func (obj *ProjectProject) SetProjectStatus(ctx context.Context, status *baseprojectedgeorchestratorintelcomv1.ProjectStatus) error {
	logger.Debugf("[ProjectProject SetProjectStatus] Set status for object with name %s", obj.GetName())
	result, err := obj.client.Project().SetProjectProjectStatusByName(ctx, obj.Project, status)
	if err != nil {
		logger.Errorf("[ProjectProject SetProjectStatus] Set status for object with name %s failed with error %v", obj.GetName(), err)
		return err
	}
	obj.Project = result.Project
	return nil
}

// GetProjectStatus to get user defined status
func (obj *ProjectProject) GetProjectStatus(ctx context.Context) (*baseprojectedgeorchestratorintelcomv1.ProjectStatus, error) {
	getObj, err := obj.client.Project().GetProjectByName(ctx, obj.GetName())
	if err != nil {
		return nil, err
	}
	return &getObj.Status.ProjectStatus, nil
}

// ClearProjectStatus to clear user defined status
func (obj *ProjectProject) ClearProjectStatus(ctx context.Context) error {
	logger.Debugf("[ProjectProject ClearProjectStatus] Set status for object with name %s", obj.GetName())
	result, err := obj.client.Project().SetProjectProjectStatusByName(ctx, obj.Project, &baseprojectedgeorchestratorintelcomv1.ProjectStatus{})
	if err != nil {
		logger.Errorf("[ProjectProject ClearProjectStatus] Clear status for object with name %s failed with error %v", obj.GetName(), err)
		return err
	}
	obj.Project = result.Project
	return nil
}

func (obj *ProjectProject) GetParent(ctx context.Context) (result *FolderFolder, err error) {
	hashedName := helper.GetHashedName("folders.folder.edge-orchestrator.intel.com", obj.Labels, obj.Labels["folders.folder.edge-orchestrator.intel.com"])
	logger.Debugf("[GetParent] Get parent of ProjectProject name %s [labels %#v] of parent type folders.folder.edge-orchestrator.intel.com and name %s", obj.Name, obj.Labels, hashedName)
	return obj.client.Folder().GetFolderByName(ctx, hashedName)
}

type ProjectProjectNetworks struct {
	client   *Clientset
	Networks []baseprojectedgeorchestratorintelcomv1.Child
}

func (n *ProjectProjectNetworks) Next(ctx context.Context) (*NetworkNetwork, error) {
	for index, child := range n.Networks {
		logger.Debugf("[ProjectProjectNetworks Next] Get next Networks with name %s", child.Name)
		obj, err := n.client.Network().GetNetworkByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Networks)-1 {
				n.Networks = nil
			} else {
				n.Networks = n.Networks[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllNetworksIter returns an iterator for all children of given type
func (obj *ProjectProject) GetAllNetworksIter(ctx context.Context) (
	result ProjectProjectNetworks) {
	result.client = obj.client
	for _, v := range GetChildren("projects.project.edge-orchestrator.intel.com", obj.Name, "networks.network.edge-orchestrator.intel.com") {
		result.Networks = append(result.Networks, baseprojectedgeorchestratorintelcomv1.Child{
			Group: "network.edge-orchestrator.intel.com",
			Kind:  "Network",
			Name:  v,
		})
	}
	return
}

// GetAllNetworks returns all children of a given type
func (obj *ProjectProject) GetAllNetworks(ctx context.Context) (
	result []*NetworkNetwork, err error) {
	for _, v := range GetChildren("projects.project.edge-orchestrator.intel.com", obj.Name, "networks.network.edge-orchestrator.intel.com") {
		logger.Debugf("[ProjectProject GetAllNetworks] Get next Networks with name %s", v)
		l, err := obj.client.Network().GetNetworkByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetNetworks returns child which has given displayName
func (obj *ProjectProject) GetNetworks(ctx context.Context,
	displayName string) (result *NetworkNetwork, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["projects.project.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("networks.network.edge-orchestrator.intel.com", parentLabels, displayName)
	logger.Debugf("[GetNetworks] in ProjectProject with name %s, displayName %s, parentLabels %#v", childHashName, displayName, parentLabels)
	if IsChildExists("projects.project.edge-orchestrator.intel.com", obj.Name, "networks.network.edge-orchestrator.intel.com", childHashName) == false {
		logger.Debugf("[GetNetworks] ChildNotFound Networks with name %s, displayName %s ", childHashName, displayName)
		return nil, NewChildNotFound(obj.DisplayName(), "Project.Project", "Networks", displayName)
	}

	logger.Debugf("[GetNetworks] invoke GetNetworkByName name %s, displayName %s", childHashName, displayName)
	result, err = obj.client.Network().GetNetworkByName(ctx, childHashName)
	return
}

// AddNetworks calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ProjectProject) AddNetworks(ctx context.Context,
	objToCreate *basenetworkedgeorchestratorintelcomv1.Network) (result *NetworkNetwork, err error) {
	logger.Debugf("[AddNetworks] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["projects.project.edge-orchestrator.intel.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["projects.project.edge-orchestrator.intel.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Network().CreateNetworkByName(ctx, objToCreate)
	logger.Debugf("[AddNetworks] Network created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Project().GetProjectByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Project = updatedObj.Project
	}
	logger.Debugf("[AddNetworks] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteNetworks calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ProjectProject) DeleteNetworks(ctx context.Context, displayName string) (err error) {
	logger.Debugf("[ DeleteNetworks] Received for Network object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["projects.project.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("networks.network.edge-orchestrator.intel.com", parentLabels, displayName)
	if IsChildExists("projects.project.edge-orchestrator.intel.com", obj.Name, "networks.network.edge-orchestrator.intel.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Project.Project", "Networks", displayName)
	}

	err = obj.client.Network().DeleteNetworkByName(ctx, childHashName)
	if err != nil {
		return err
	}
	logger.Debugf("[ DeleteNetworks] Network object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Project().GetProjectByName(ctx, obj.GetName())
	if err == nil {
		obj.Project = updatedObj.Project
	}
	return
}

type projectProjectEdgeV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *projectProjectEdgeV1Chainer) Subscribe() {
	key := "projects.project.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerprojectedgeorchestratorintelcomv1.NewProjectInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *projectProjectEdgeV1Chainer) Unsubscribe() {
	key := "projects.project.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *projectProjectEdgeV1Chainer) IsSubscribed() bool {
	key := "projects.project.edge-orchestrator.intel.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *projectProjectEdgeV1Chainer) addCallback(obj *ProjectProject) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["folders.folder.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("folders.folder.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[addCallback] received for projects.project.edge-orchestrator.intel.com name %s displayName %s parent folders.folder.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	AddChild("folders.folder.edge-orchestrator.intel.com", parentHashName, "projects.project.edge-orchestrator.intel.com", obj.Name)
}

func (c *projectProjectEdgeV1Chainer) deleteCallback(obj *ProjectProject) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["folders.folder.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("folders.folder.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[deleteCallback] received for projects.project.edge-orchestrator.intel.com name %s displayName %s parent folders.folder.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	RemoveChild("folders.folder.edge-orchestrator.intel.com", parentHashName, "projects.project.edge-orchestrator.intel.com", obj.Name)
}

func (c *projectProjectEdgeV1Chainer) RegisterEventHandler(addCB func(obj *ProjectProject), updateCB func(oldObj, newObj *ProjectProject), deleteCB func(obj *ProjectProject)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for ProjectProject")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "projects.project.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ProjectProject")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ProjectProject, so creating a new one")
		informer = informerprojectedgeorchestratorintelcomv1.NewProjectInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ProjectProject{
				client:  c.client,
				Project: obj.(*baseprojectedgeorchestratorintelcomv1.Project),
			}
			logger.Debugf("[RegisterEventHandler AddFunc] Got Add event for projects.project.edge-orchestrator.intel.com name %s", nc.Project.Name)

			var parent *FolderFolder
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("folders.folder.edge-orchestrator.intel.com", nc.Labels, nc.Labels["folders.folder.edge-orchestrator.intel.com"])
				parent, err = c.client.Folder().ForceReadFolderByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("folders.folder.edge-orchestrator.intel.com", parent.Name, "projects.project.edge-orchestrator.intel.com", nc.Name) {
				AddChild("folders.folder.edge-orchestrator.intel.com", parent.Name, "projects.project.edge-orchestrator.intel.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ProjectProject{
				client:  c.client,
				Project: oldObj.(*baseprojectedgeorchestratorintelcomv1.Project),
			}
			newData := &ProjectProject{
				client:  c.client,
				Project: newObj.(*baseprojectedgeorchestratorintelcomv1.Project),
			}
			logger.Debugf("[RegisterEventHandler UpdateFunc] Got Update event for projects.project.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.Project.Name, oldData.ResourceVersion, newData.ResourceVersion)
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &ProjectProject{
				client:  c.client,
				Project: obj.(*baseprojectedgeorchestratorintelcomv1.Project),
			}
			logger.Debugf("[RegisterEventHandler DeleteFunc] Got Delete event for projects.project.edge-orchestrator.intel.com name %s", nc.Project.Name)

			var parent *FolderFolder
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("folders.folder.edge-orchestrator.intel.com", nc.Labels, nc.Labels["folders.folder.edge-orchestrator.intel.com"])
				parent, err = c.client.Folder().ForceReadFolderByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("folders.folder.edge-orchestrator.intel.com", parent.Name, "projects.project.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("folders.folder.edge-orchestrator.intel.com", parent.Name, "projects.project.edge-orchestrator.intel.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *projectProjectEdgeV1Chainer) RegisterAddCallback(cbfn func(obj *ProjectProject)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterAddCallback] Received for ProjectProject")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "projects.project.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ProjectProject")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ProjectProject, so creating a new one")
		informer = informerprojectedgeorchestratorintelcomv1.NewProjectInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ProjectProject{
				client:  c.client,
				Project: obj.(*baseprojectedgeorchestratorintelcomv1.Project),
			}
			logger.Debugf("[RegisterAddCallback] Got Add event for projects.project.edge-orchestrator.intel.com name %s", nc.Project.Name)

			var parent *FolderFolder
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("folders.folder.edge-orchestrator.intel.com", nc.Labels, nc.Labels["folders.folder.edge-orchestrator.intel.com"])
				parent, err = c.client.Folder().ForceReadFolderByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("folders.folder.edge-orchestrator.intel.com", parent.Name, "projects.project.edge-orchestrator.intel.com", nc.Name) {
				AddChild("folders.folder.edge-orchestrator.intel.com", parent.Name, "projects.project.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *projectProjectEdgeV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *ProjectProject)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterUpdateCallback] Received for ProjectProject")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "projects.project.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ProjectProject")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ProjectProject, so creating a new one")
		informer = informerprojectedgeorchestratorintelcomv1.NewProjectInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ProjectProject{
				client:  c.client,
				Project: oldObj.(*baseprojectedgeorchestratorintelcomv1.Project),
			}
			newData := &ProjectProject{
				client:  c.client,
				Project: newObj.(*baseprojectedgeorchestratorintelcomv1.Project),
			}
			logger.Debugf("[RegisterUpdateCallback] Got Update event for projects.project.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.Project.Name, oldData.ResourceVersion, newData.ResourceVersion)
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *projectProjectEdgeV1Chainer) RegisterDeleteCallback(cbfn func(obj *ProjectProject)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterDeleteCallback] Received for ProjectProject")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "projects.project.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ProjectProject")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ProjectProject, so creating a new one")
		informer = informerprojectedgeorchestratorintelcomv1.NewProjectInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &ProjectProject{
				client:  c.client,
				Project: obj.(*baseprojectedgeorchestratorintelcomv1.Project),
			}
			logger.Debugf("[RegisterDeleteCallback] Got Delete event for projects.project.edge-orchestrator.intel.com name %s", nc.Project.Name)

			var parent *FolderFolder
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("folders.folder.edge-orchestrator.intel.com", nc.Labels, nc.Labels["folders.folder.edge-orchestrator.intel.com"])
				parent, err = c.client.Folder().ForceReadFolderByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("folders.folder.edge-orchestrator.intel.com", parent.Name, "projects.project.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("folders.folder.edge-orchestrator.intel.com", parent.Name, "projects.project.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

// ClearProjectStatus to clear user defined status
func (c *projectProjectEdgeV1Chainer) ClearProjectStatus(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("projects.project.edge-orchestrator.intel.com", c.parentLabels, c.name)
	logger.Debugf("[projectProjectEdgeV1Chainer ClearProjectStatus] Clear status for object with name %s", hashedName)
	obj, err := c.client.Project().GetProjectByName(ctx, hashedName)
	if err != nil {
		logger.Errorf("[projectProjectEdgeV1Chainer ClearProjectStatus] Clear status for object with name %s failed with error %v", hashedName, err)
		return err
	}
	_, err = c.client.Project().SetProjectProjectStatusByName(ctx, obj.Project, nil)
	return err
}

// GetProjectStatus to get user defined status
func (c *projectProjectEdgeV1Chainer) GetProjectStatus(ctx context.Context) (result *baseprojectedgeorchestratorintelcomv1.ProjectStatus, err error) {
	hashedName := helper.GetHashedName("projects.project.edge-orchestrator.intel.com", c.parentLabels, c.name)
	obj, err := c.client.Project().GetProjectByName(ctx, hashedName)
	if err != nil {
		return nil, err
	}
	return &obj.Status.ProjectStatus, nil
}

// SetProjectStatus sets user defined status
func (c *projectProjectEdgeV1Chainer) SetProjectStatus(ctx context.Context, status *baseprojectedgeorchestratorintelcomv1.ProjectStatus) (err error) {
	hashedName := helper.GetHashedName("projects.project.edge-orchestrator.intel.com", c.parentLabels, c.name)
	logger.Debugf("[projectProjectEdgeV1Chainer SetProjectStatus] Set status for object with name %s", hashedName)
	obj, err := c.client.Project().GetProjectByName(ctx, hashedName)
	if err != nil {
		logger.Errorf("[projectProjectEdgeV1Chainer SetProjectStatus] Set status for object with name %s failed with error %v", hashedName, err)
		return err
	}
	_, err = c.client.Project().SetProjectProjectStatusByName(ctx, obj.Project, status)
	return err
}

func (c *projectProjectEdgeV1Chainer) Networks(name string) *networkNetworkEdgeV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["networks.network.edge-orchestrator.intel.com"] = name
	return &networkNetworkEdgeV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetNetworks calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *projectProjectEdgeV1Chainer) GetNetworks(ctx context.Context, displayName string) (result *NetworkNetwork, err error) {
	hashedName := helper.GetHashedName("networks.network.edge-orchestrator.intel.com", c.parentLabels, displayName)
	logger.Debugf("[GetNetworks] using chainer for name %s, displayName %s, labels %#v", hashedName, displayName, c.parentLabels)
	return c.client.Network().GetNetworkByName(ctx, hashedName)
}

// AddNetworks calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *projectProjectEdgeV1Chainer) AddNetworks(ctx context.Context,
	objToCreate *basenetworkedgeorchestratorintelcomv1.Network) (result *NetworkNetwork, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName("networks.network.edge-orchestrator.intel.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Network().CreateNetworkByName(ctx, objToCreate)
}

// DeleteNetworks calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *projectProjectEdgeV1Chainer) DeleteNetworks(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IsNameHashedLabel] = "true"
	hashedName := helper.GetHashedName("networks.network.edge-orchestrator.intel.com", c.parentLabels, name)
	return c.client.Network().DeleteNetworkByName(ctx, hashedName)
}

func (group *NetworkEdgeV1) GetNetworkChildrenMap() map[string]basenetworkedgeorchestratorintelcomv1.Child {
	return map[string]basenetworkedgeorchestratorintelcomv1.Child{}
}

func (group *NetworkEdgeV1) GetNetworkChild(grp, kind, name string) basenetworkedgeorchestratorintelcomv1.Child {
	return basenetworkedgeorchestratorintelcomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetNetworkByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *NetworkEdgeV1) GetNetworkByName(ctx context.Context, hashedName string) (*NetworkNetwork, error) {
	key := "networks.network.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			logger.Debugf("[GetNetworkByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basenetworkedgeorchestratorintelcomv1.Network)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				logger.Fatalf("[GetNetworkByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basenetworkedgeorchestratorintelcomv1.Network).ResourceVersion)
				if writeCacheVersionErr != nil {
					logger.Fatalf("[GetNetworkByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &NetworkNetwork{
					client:  group.client,
					Network: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &NetworkNetwork{
				client:  group.client,
				Network: resWrCache.(*basenetworkedgeorchestratorintelcomv1.Network),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			NetworkEdgeV1().
			Networks().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &NetworkNetwork{
				client:  group.client,
				Network: result,
			}, nil
		} else if errors.IsNotFound(err) {
			logger.Debugf("[GetNetworkByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on Get Networks: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[GetNetworkByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[GetNetworkByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadNetworkByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *NetworkEdgeV1) ForceReadNetworkByName(ctx context.Context, hashedName string) (*NetworkNetwork, error) {
	logger.Debugf("[ForceReadNetworkByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			NetworkEdgeV1().
			Networks().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[ForceReadNetworkByName] Failed to Get Networks: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max Retry exceed on Get Networks: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[ForceReadNetworkByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[ForceReadNetworkByName]: %+v", err)
				return nil, err
			}
		} else {
			logger.Debugf("[ForceReadNetworkByName] Executed Successfully :%s", hashedName)
			return &NetworkNetwork{
				client:  group.client,
				Network: result,
			}, nil
		}
	}
}

// DeleteNetworkByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *NetworkEdgeV1) DeleteNetworkByName(ctx context.Context, hashedName string) (err error) {
	logger.Debugf("[DeleteNetworkByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basenetworkedgeorchestratorintelcomv1.Network
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			NetworkEdgeV1().
			Networks().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[DeleteNetworkByName] Failed to get Networks: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on get Networks: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteNetworkByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteNetworkByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteNetworkByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			NetworkEdgeV1().
			Networks().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			logger.Errorf("[DeleteNetworkByName] failed to delete Networks: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on delete Networks: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteNetworkByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteNetworkByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteNetworkByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("networks.network.edge-orchestrator.intel.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	logger.Debugf("[DeleteNetworkByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["projects.project.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	if result.GetLabels() != nil {
		if parents[common.IsNameHashedLabel] == "true" {
			parentName = helper.GetHashedName("projects.project.edge-orchestrator.intel.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("projects.project.edge-orchestrator.intel.com", parents, parentName)
	}
	RemoveChild("projects.project.edge-orchestrator.intel.com", parentName, "networks.network.edge-orchestrator.intel.com", hashedName)

	return nil
}

// CreateNetworkByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *NetworkEdgeV1) CreateNetworkByName(ctx context.Context,
	objToCreate *basenetworkedgeorchestratorintelcomv1.Network) (*NetworkNetwork, error) {
	logger.Debugf("[CreateNetworkByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DisplayNameLabel]; !ok {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
	}

	logger.Debugf("[CreateNetworkByName] Node is marked for deferred delete: %s", objToCreate.GetName())
	found := false
	for _, finalizer := range objToCreate.Finalizers {
		if finalizer == nexusDeferredDeleteAnnotation {
			found = true
			break
		}
	}
	if !found {
		objToCreate.Finalizers = append(objToCreate.Finalizers, nexusDeferredDeleteAnnotation)
		logger.Debugf("[CreateNetworkByName] Added %s finalizer to node: %s", nexusDeferredDeleteAnnotation, objToCreate.GetName())
	}

	var (
		retryCount int
		result     *basenetworkedgeorchestratorintelcomv1.Network
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			NetworkEdgeV1().
			Networks().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			logger.Errorf("[CreateNetworkByName] Failed to create Network: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on create Network: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[CreateNetworkByName] context canceled while creating Network: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				logger.Debugf("[CreateNetworkByName] Network: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.NetworkEdgeV1().Networks().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					logger.Fatalf("[CreateNetworkByName] Unable to Get Network %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				logger.Errorf("[CreateNetworkByName] found unexpected error while creating Network: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			logger.Debugf("[CreateNetworkByName] Network: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("networks.network.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[CreateNetworkByName] Network: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["projects.project.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	parentHashedName := helper.GetHashedName("projects.project.edge-orchestrator.intel.com", objToCreate.GetLabels(), parentName)

	AddChild("projects.project.edge-orchestrator.intel.com", parentHashedName, "networks.network.edge-orchestrator.intel.com", objToCreate.Name)

	logger.Debugf("[CreateNetworkByName] Executed Successfully: %s", objToCreate.GetName())
	return &NetworkNetwork{
		client:  group.client,
		Network: result,
	}, nil
}

// SetNetworkStatusByName sets user defined status
func (group *NetworkEdgeV1) SetNetworkStatusByName(ctx context.Context,
	objToUpdate *basenetworkedgeorchestratorintelcomv1.Network, status *basenetworkedgeorchestratorintelcomv1.NetworkStatus) (*NetworkNetwork, error) {
	logger.Debugf("[SetNetworkStatusByName] Received objToUpdate:%s", objToUpdate.GetName())

	gvr := schema.GroupVersionResource{
		Group:    "network.edge-orchestrator.intel.com",
		Version:  "v1",
		Resource: strings.ToLower("Networks"),
	}

	hashedName := objToUpdate.ObjectMeta.Name
	obj := basenetworkedgeorchestratorintelcomv1.Network{}
	obj.Kind = strings.ToLower("Networks")
	obj.APIVersion = "network.edge-orchestrator.intel.com/v1"
	obj.ObjectMeta = objToUpdate.ObjectMeta
	obj.Status.Status = *status

	var mapInterface map[string]interface{}
	marshalledObj, _ := json.Marshal(&obj)
	json.Unmarshal(marshalledObj, &mapInterface)

	newCtx := context.TODO()
	retryCount := 0
	for {
		_, err := group.client.DynamicClient.Resource(gvr).UpdateStatus(ctx, &unstructured.Unstructured{Object: mapInterface}, metav1.UpdateOptions{})
		if err == nil {
			logger.Debugf("[SetNetworkStatusByName] Updating status for Network node %s successful", hashedName)
			break
		}

		logger.Errorf("[SetNetworkStatusByName] Updating status for Network node: %s failed with error %v. Retrying...", hashedName, err)

		updatedObj, err := group.ForceReadNetworkByName(newCtx, hashedName)
		if err == nil {
			obj.ObjectMeta = updatedObj.ObjectMeta
			marshalledObj, _ := json.Marshal(&obj)
			json.Unmarshal(marshalledObj, &mapInterface)
		}

		retryCount += 1
		if retryCount == maxRetryCount1SecSleep {
			logger.Fatalf("[SetNetworkStatusByName] Max retry exceeded for updating status for Network node: %s", hashedName)
			return nil, err
		}
		time.Sleep(time.Second)
	}

	/*
		if s, ok := subscriptionMap.Load("networks.network.edge-orchestrator.intel.com"); ok {
			resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
			var objectToWrite *basenetworkedgeorchestratorintelcomv1.Network
			if inWrCache {
				objectToWrite = resWrCache.(*basenetworkedgeorchestratorintelcomv1.Network)
				objectToWrite.Status.Status = *status
			} else {
				// Object is not in write cache. Populate the write cache with last "known" object.
				// TBD: Is this right ???
				//      Can we expect ObjectToUpdate to the latest version of the object ?
				//      What if we received the object spec but only want to update the status ?
				//      Get on the object will return a object form cache if the cache has newer version.
				// 		So proceeding with assumption that if newer version is available, user will get the newer version anyways.
				objectToWrite = objToUpdate
				objToUpdate.Status.Status = *status
			}
			s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), objectToWrite)
		}
	*/
	return &NetworkNetwork{
		client:  group.client,
		Network: objToUpdate, // TBD: To be fixed to return back the "result"
	}, nil
}

// UpdateNetworkByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *NetworkEdgeV1) UpdateNetworkByName(ctx context.Context,
	objToUpdate *basenetworkedgeorchestratorintelcomv1.Network) (*NetworkNetwork, error) {
	logger.Debugf("[UpdateNetworkByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Network().GetNetworkByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["networks.network.edge-orchestrator.intel.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IsNameHashedLabel] = current.Labels[common.IsNameHashedLabel]
			objToUpdate.Labels[common.DisplayNameLabel] = current.Labels[common.DisplayNameLabel]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Type)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Type).IsNil() {
			patchValueType := objToUpdate.Spec.Type
			patchOpType := PatchOp{
				Op:    "replace",
				Path:  "/spec/type",
				Value: patchValueType,
			}
			patch = append(patch, patchOpType)
		}
	} else {
		patchValueType := objToUpdate.Spec.Type
		patchOpType := PatchOp{
			Op:    "replace",
			Path:  "/spec/type",
			Value: patchValueType,
		}
		patch = append(patch, patchOpType)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Description)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Description).IsNil() {
			patchValueDescription := objToUpdate.Spec.Description
			patchOpDescription := PatchOp{
				Op:    "replace",
				Path:  "/spec/description",
				Value: patchValueDescription,
			}
			patch = append(patch, patchOpDescription)
		}
	} else {
		patchValueDescription := objToUpdate.Spec.Description
		patchOpDescription := PatchOp{
			Op:    "replace",
			Path:  "/spec/description",
			Value: patchValueDescription,
		}
		patch = append(patch, patchOpDescription)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basenetworkedgeorchestratorintelcomv1.Network
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			NetworkEdgeV1().
			Networks().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			logger.Errorf("[UpdateNetworkByName] Failed to patch Network %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					logger.Debugf("Trigger Network Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteNetworkByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						logger.Debugf("Error occur while deleting Network: %s", objToUpdate.GetName())
						return nil, delErr
					}
					logger.Debugf("Network deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[UpdateNetworkByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				logger.Errorf("[UpdateNetworkByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				logger.Debugf("Trigger Network Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteNetworkByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					logger.Debugf("Error occur while deleting Network: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				logger.Debugf("Network Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			logger.Debugf("[UpdateNetworkByName] Patch Network Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("networks.network.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[UpdateNetworkByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	logger.Debugf("[UpdateNetworkByName] Executed Successfully %s", objToUpdate.GetName())
	return &NetworkNetwork{
		client:  group.client,
		Network: result,
	}, nil
}

// ListNetworks returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *NetworkEdgeV1) ListNetworks(ctx context.Context,
	opts metav1.ListOptions) (result []*NetworkNetwork, err error) {
	key := "networks.network.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*NetworkNetwork, len(items))
		for k, v := range items {
			item, _ := v.(*basenetworkedgeorchestratorintelcomv1.Network)
			result[k] = &NetworkNetwork{
				client:  group.client,
				Network: item,
			}
		}
	} else {
		list, err := group.client.baseClient.NetworkEdgeV1().
			Networks().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*NetworkNetwork, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &NetworkNetwork{
				client:  group.client,
				Network: &item,
			}
		}
	}
	return
}

type NetworkNetwork struct {
	client *Clientset
	*basenetworkedgeorchestratorintelcomv1.Network
}

// Delete removes obj and all it's children from the database.
func (obj *NetworkNetwork) Delete(ctx context.Context) error {
	err := obj.client.Network().DeleteNetworkByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Network = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *NetworkNetwork) Update(ctx context.Context) error {
	result, err := obj.client.Network().UpdateNetworkByName(ctx, obj.Network)
	if err != nil {
		return err
	}
	obj.Network = result.Network
	return nil
}

// SetStatus sets user defined status
func (obj *NetworkNetwork) SetStatus(ctx context.Context, status *basenetworkedgeorchestratorintelcomv1.NetworkStatus) error {
	logger.Debugf("[NetworkNetwork SetStatus] Set status for object with name %s", obj.GetName())
	result, err := obj.client.Network().SetNetworkStatusByName(ctx, obj.Network, status)
	if err != nil {
		logger.Errorf("[NetworkNetwork SetStatus] Set status for object with name %s failed with error %v", obj.GetName(), err)
		return err
	}
	obj.Network = result.Network
	return nil
}

// GetStatus to get user defined status
func (obj *NetworkNetwork) GetStatus(ctx context.Context) (*basenetworkedgeorchestratorintelcomv1.NetworkStatus, error) {
	getObj, err := obj.client.Network().GetNetworkByName(ctx, obj.GetName())
	if err != nil {
		return nil, err
	}
	return &getObj.Status.Status, nil
}

// ClearStatus to clear user defined status
func (obj *NetworkNetwork) ClearStatus(ctx context.Context) error {
	logger.Debugf("[NetworkNetwork ClearStatus] Set status for object with name %s", obj.GetName())
	result, err := obj.client.Network().SetNetworkStatusByName(ctx, obj.Network, &basenetworkedgeorchestratorintelcomv1.NetworkStatus{})
	if err != nil {
		logger.Errorf("[NetworkNetwork ClearStatus] Clear status for object with name %s failed with error %v", obj.GetName(), err)
		return err
	}
	obj.Network = result.Network
	return nil
}

func (obj *NetworkNetwork) GetParent(ctx context.Context) (result *ProjectProject, err error) {
	hashedName := helper.GetHashedName("projects.project.edge-orchestrator.intel.com", obj.Labels, obj.Labels["projects.project.edge-orchestrator.intel.com"])
	logger.Debugf("[GetParent] Get parent of NetworkNetwork name %s [labels %#v] of parent type projects.project.edge-orchestrator.intel.com and name %s", obj.Name, obj.Labels, hashedName)
	return obj.client.Project().GetProjectByName(ctx, hashedName)
}

type networkNetworkEdgeV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *networkNetworkEdgeV1Chainer) Subscribe() {
	key := "networks.network.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informernetworkedgeorchestratorintelcomv1.NewNetworkInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *networkNetworkEdgeV1Chainer) Unsubscribe() {
	key := "networks.network.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *networkNetworkEdgeV1Chainer) IsSubscribed() bool {
	key := "networks.network.edge-orchestrator.intel.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *networkNetworkEdgeV1Chainer) addCallback(obj *NetworkNetwork) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["projects.project.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("projects.project.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[addCallback] received for networks.network.edge-orchestrator.intel.com name %s displayName %s parent projects.project.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	AddChild("projects.project.edge-orchestrator.intel.com", parentHashName, "networks.network.edge-orchestrator.intel.com", obj.Name)
}

func (c *networkNetworkEdgeV1Chainer) deleteCallback(obj *NetworkNetwork) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["projects.project.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("projects.project.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[deleteCallback] received for networks.network.edge-orchestrator.intel.com name %s displayName %s parent projects.project.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	RemoveChild("projects.project.edge-orchestrator.intel.com", parentHashName, "networks.network.edge-orchestrator.intel.com", obj.Name)
}

func (c *networkNetworkEdgeV1Chainer) RegisterEventHandler(addCB func(obj *NetworkNetwork), updateCB func(oldObj, newObj *NetworkNetwork), deleteCB func(obj *NetworkNetwork)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for NetworkNetwork")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "networks.network.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for NetworkNetwork")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for NetworkNetwork, so creating a new one")
		informer = informernetworkedgeorchestratorintelcomv1.NewNetworkInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &NetworkNetwork{
				client:  c.client,
				Network: obj.(*basenetworkedgeorchestratorintelcomv1.Network),
			}
			logger.Debugf("[RegisterEventHandler AddFunc] Got Add event for networks.network.edge-orchestrator.intel.com name %s", nc.Network.Name)

			var parent *ProjectProject
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("projects.project.edge-orchestrator.intel.com", nc.Labels, nc.Labels["projects.project.edge-orchestrator.intel.com"])
				parent, err = c.client.Project().ForceReadProjectByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("projects.project.edge-orchestrator.intel.com", parent.Name, "networks.network.edge-orchestrator.intel.com", nc.Name) {
				AddChild("projects.project.edge-orchestrator.intel.com", parent.Name, "networks.network.edge-orchestrator.intel.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &NetworkNetwork{
				client:  c.client,
				Network: oldObj.(*basenetworkedgeorchestratorintelcomv1.Network),
			}
			newData := &NetworkNetwork{
				client:  c.client,
				Network: newObj.(*basenetworkedgeorchestratorintelcomv1.Network),
			}
			logger.Debugf("[RegisterEventHandler UpdateFunc] Got Update event for networks.network.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.Network.Name, oldData.ResourceVersion, newData.ResourceVersion)
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &NetworkNetwork{
				client:  c.client,
				Network: obj.(*basenetworkedgeorchestratorintelcomv1.Network),
			}
			logger.Debugf("[RegisterEventHandler DeleteFunc] Got Delete event for networks.network.edge-orchestrator.intel.com name %s", nc.Network.Name)

			var parent *ProjectProject
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("projects.project.edge-orchestrator.intel.com", nc.Labels, nc.Labels["projects.project.edge-orchestrator.intel.com"])
				parent, err = c.client.Project().ForceReadProjectByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("projects.project.edge-orchestrator.intel.com", parent.Name, "networks.network.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("projects.project.edge-orchestrator.intel.com", parent.Name, "networks.network.edge-orchestrator.intel.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *networkNetworkEdgeV1Chainer) RegisterAddCallback(cbfn func(obj *NetworkNetwork)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterAddCallback] Received for NetworkNetwork")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "networks.network.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for NetworkNetwork")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for NetworkNetwork, so creating a new one")
		informer = informernetworkedgeorchestratorintelcomv1.NewNetworkInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &NetworkNetwork{
				client:  c.client,
				Network: obj.(*basenetworkedgeorchestratorintelcomv1.Network),
			}
			logger.Debugf("[RegisterAddCallback] Got Add event for networks.network.edge-orchestrator.intel.com name %s", nc.Network.Name)

			var parent *ProjectProject
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("projects.project.edge-orchestrator.intel.com", nc.Labels, nc.Labels["projects.project.edge-orchestrator.intel.com"])
				parent, err = c.client.Project().ForceReadProjectByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("projects.project.edge-orchestrator.intel.com", parent.Name, "networks.network.edge-orchestrator.intel.com", nc.Name) {
				AddChild("projects.project.edge-orchestrator.intel.com", parent.Name, "networks.network.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *networkNetworkEdgeV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *NetworkNetwork)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterUpdateCallback] Received for NetworkNetwork")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "networks.network.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for NetworkNetwork")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for NetworkNetwork, so creating a new one")
		informer = informernetworkedgeorchestratorintelcomv1.NewNetworkInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &NetworkNetwork{
				client:  c.client,
				Network: oldObj.(*basenetworkedgeorchestratorintelcomv1.Network),
			}
			newData := &NetworkNetwork{
				client:  c.client,
				Network: newObj.(*basenetworkedgeorchestratorintelcomv1.Network),
			}
			logger.Debugf("[RegisterUpdateCallback] Got Update event for networks.network.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.Network.Name, oldData.ResourceVersion, newData.ResourceVersion)
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *networkNetworkEdgeV1Chainer) RegisterDeleteCallback(cbfn func(obj *NetworkNetwork)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterDeleteCallback] Received for NetworkNetwork")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "networks.network.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for NetworkNetwork")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for NetworkNetwork, so creating a new one")
		informer = informernetworkedgeorchestratorintelcomv1.NewNetworkInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &NetworkNetwork{
				client:  c.client,
				Network: obj.(*basenetworkedgeorchestratorintelcomv1.Network),
			}
			logger.Debugf("[RegisterDeleteCallback] Got Delete event for networks.network.edge-orchestrator.intel.com name %s", nc.Network.Name)

			var parent *ProjectProject
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("projects.project.edge-orchestrator.intel.com", nc.Labels, nc.Labels["projects.project.edge-orchestrator.intel.com"])
				parent, err = c.client.Project().ForceReadProjectByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("projects.project.edge-orchestrator.intel.com", parent.Name, "networks.network.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("projects.project.edge-orchestrator.intel.com", parent.Name, "networks.network.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

// ClearStatus to clear user defined status
func (c *networkNetworkEdgeV1Chainer) ClearStatus(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("networks.network.edge-orchestrator.intel.com", c.parentLabels, c.name)
	logger.Debugf("[networkNetworkEdgeV1Chainer ClearStatus] Clear status for object with name %s", hashedName)
	obj, err := c.client.Network().GetNetworkByName(ctx, hashedName)
	if err != nil {
		logger.Errorf("[networkNetworkEdgeV1Chainer ClearStatus] Clear status for object with name %s failed with error %v", hashedName, err)
		return err
	}
	_, err = c.client.Network().SetNetworkStatusByName(ctx, obj.Network, nil)
	return err
}

// GetStatus to get user defined status
func (c *networkNetworkEdgeV1Chainer) GetStatus(ctx context.Context) (result *basenetworkedgeorchestratorintelcomv1.NetworkStatus, err error) {
	hashedName := helper.GetHashedName("networks.network.edge-orchestrator.intel.com", c.parentLabels, c.name)
	obj, err := c.client.Network().GetNetworkByName(ctx, hashedName)
	if err != nil {
		return nil, err
	}
	return &obj.Status.Status, nil
}

// SetStatus sets user defined status
func (c *networkNetworkEdgeV1Chainer) SetStatus(ctx context.Context, status *basenetworkedgeorchestratorintelcomv1.NetworkStatus) (err error) {
	hashedName := helper.GetHashedName("networks.network.edge-orchestrator.intel.com", c.parentLabels, c.name)
	logger.Debugf("[networkNetworkEdgeV1Chainer SetStatus] Set status for object with name %s", hashedName)
	obj, err := c.client.Network().GetNetworkByName(ctx, hashedName)
	if err != nil {
		logger.Errorf("[networkNetworkEdgeV1Chainer SetStatus] Set status for object with name %s failed with error %v", hashedName, err)
		return err
	}
	_, err = c.client.Network().SetNetworkStatusByName(ctx, obj.Network, status)
	return err
}

func (group *OrgwatcherEdgeV1) GetOrgWatcherChildrenMap() map[string]baseorgwatcheredgeorchestratorintelcomv1.Child {
	return map[string]baseorgwatcheredgeorchestratorintelcomv1.Child{}
}

func (group *OrgwatcherEdgeV1) GetOrgWatcherChild(grp, kind, name string) baseorgwatcheredgeorchestratorintelcomv1.Child {
	return baseorgwatcheredgeorchestratorintelcomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetOrgWatcherByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *OrgwatcherEdgeV1) GetOrgWatcherByName(ctx context.Context, hashedName string) (*OrgwatcherOrgWatcher, error) {
	key := "orgwatchers.orgwatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			logger.Debugf("[GetOrgWatcherByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				logger.Fatalf("[GetOrgWatcherByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher).ResourceVersion)
				if writeCacheVersionErr != nil {
					logger.Fatalf("[GetOrgWatcherByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &OrgwatcherOrgWatcher{
					client:     group.client,
					OrgWatcher: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &OrgwatcherOrgWatcher{
				client:     group.client,
				OrgWatcher: resWrCache.(*baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			OrgwatcherEdgeV1().
			OrgWatchers().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &OrgwatcherOrgWatcher{
				client:     group.client,
				OrgWatcher: result,
			}, nil
		} else if errors.IsNotFound(err) {
			logger.Debugf("[GetOrgWatcherByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on Get OrgWatchers: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[GetOrgWatcherByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[GetOrgWatcherByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadOrgWatcherByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *OrgwatcherEdgeV1) ForceReadOrgWatcherByName(ctx context.Context, hashedName string) (*OrgwatcherOrgWatcher, error) {
	logger.Debugf("[ForceReadOrgWatcherByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			OrgwatcherEdgeV1().
			OrgWatchers().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[ForceReadOrgWatcherByName] Failed to Get OrgWatchers: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max Retry exceed on Get OrgWatchers: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[ForceReadOrgWatcherByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[ForceReadOrgWatcherByName]: %+v", err)
				return nil, err
			}
		} else {
			logger.Debugf("[ForceReadOrgWatcherByName] Executed Successfully :%s", hashedName)
			return &OrgwatcherOrgWatcher{
				client:     group.client,
				OrgWatcher: result,
			}, nil
		}
	}
}

// DeleteOrgWatcherByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *OrgwatcherEdgeV1) DeleteOrgWatcherByName(ctx context.Context, hashedName string) (err error) {
	logger.Debugf("[DeleteOrgWatcherByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			OrgwatcherEdgeV1().
			OrgWatchers().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[DeleteOrgWatcherByName] Failed to get OrgWatchers: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on get OrgWatchers: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteOrgWatcherByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteOrgWatcherByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteOrgWatcherByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			OrgwatcherEdgeV1().
			OrgWatchers().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			logger.Errorf("[DeleteOrgWatcherByName] failed to delete OrgWatchers: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on delete OrgWatchers: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteOrgWatcherByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteOrgWatcherByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteOrgWatcherByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("orgwatchers.orgwatcher.edge-orchestrator.intel.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	logger.Debugf("[DeleteOrgWatcherByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	if result.GetLabels() != nil {
		if parents[common.IsNameHashedLabel] == "true" {
			parentName = helper.GetHashedName("configs.config.edge-orchestrator.intel.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("configs.config.edge-orchestrator.intel.com", parents, parentName)
	}
	RemoveChild("configs.config.edge-orchestrator.intel.com", parentName, "orgwatchers.orgwatcher.edge-orchestrator.intel.com", hashedName)

	return nil
}

// CreateOrgWatcherByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *OrgwatcherEdgeV1) CreateOrgWatcherByName(ctx context.Context,
	objToCreate *baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher) (*OrgwatcherOrgWatcher, error) {
	logger.Debugf("[CreateOrgWatcherByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DisplayNameLabel]; !ok {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			OrgwatcherEdgeV1().
			OrgWatchers().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			logger.Errorf("[CreateOrgWatcherByName] Failed to create OrgWatcher: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on create OrgWatcher: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[CreateOrgWatcherByName] context canceled while creating OrgWatcher: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				logger.Debugf("[CreateOrgWatcherByName] OrgWatcher: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.OrgwatcherEdgeV1().OrgWatchers().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					logger.Fatalf("[CreateOrgWatcherByName] Unable to Get OrgWatcher %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				logger.Errorf("[CreateOrgWatcherByName] found unexpected error while creating OrgWatcher: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			logger.Debugf("[CreateOrgWatcherByName] OrgWatcher: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("orgwatchers.orgwatcher.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[CreateOrgWatcherByName] OrgWatcher: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	parentHashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", objToCreate.GetLabels(), parentName)

	AddChild("configs.config.edge-orchestrator.intel.com", parentHashedName, "orgwatchers.orgwatcher.edge-orchestrator.intel.com", objToCreate.Name)

	logger.Debugf("[CreateOrgWatcherByName] Executed Successfully: %s", objToCreate.GetName())
	return &OrgwatcherOrgWatcher{
		client:     group.client,
		OrgWatcher: result,
	}, nil
}

// UpdateOrgWatcherByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *OrgwatcherEdgeV1) UpdateOrgWatcherByName(ctx context.Context,
	objToUpdate *baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher) (*OrgwatcherOrgWatcher, error) {
	logger.Debugf("[UpdateOrgWatcherByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Orgwatcher().GetOrgWatcherByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["orgwatchers.orgwatcher.edge-orchestrator.intel.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IsNameHashedLabel] = current.Labels[common.IsNameHashedLabel]
			objToUpdate.Labels[common.DisplayNameLabel] = current.Labels[common.DisplayNameLabel]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			OrgwatcherEdgeV1().
			OrgWatchers().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			logger.Errorf("[UpdateOrgWatcherByName] Failed to patch OrgWatcher %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					logger.Debugf("Trigger OrgWatcher Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteOrgWatcherByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						logger.Debugf("Error occur while deleting OrgWatcher: %s", objToUpdate.GetName())
						return nil, delErr
					}
					logger.Debugf("OrgWatcher deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[UpdateOrgWatcherByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				logger.Errorf("[UpdateOrgWatcherByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				logger.Debugf("Trigger OrgWatcher Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteOrgWatcherByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					logger.Debugf("Error occur while deleting OrgWatcher: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				logger.Debugf("OrgWatcher Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			logger.Debugf("[UpdateOrgWatcherByName] Patch OrgWatcher Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("orgwatchers.orgwatcher.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[UpdateOrgWatcherByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	logger.Debugf("[UpdateOrgWatcherByName] Executed Successfully %s", objToUpdate.GetName())
	return &OrgwatcherOrgWatcher{
		client:     group.client,
		OrgWatcher: result,
	}, nil
}

// ListOrgWatchers returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *OrgwatcherEdgeV1) ListOrgWatchers(ctx context.Context,
	opts metav1.ListOptions) (result []*OrgwatcherOrgWatcher, err error) {
	key := "orgwatchers.orgwatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*OrgwatcherOrgWatcher, len(items))
		for k, v := range items {
			item, _ := v.(*baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher)
			result[k] = &OrgwatcherOrgWatcher{
				client:     group.client,
				OrgWatcher: item,
			}
		}
	} else {
		list, err := group.client.baseClient.OrgwatcherEdgeV1().
			OrgWatchers().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*OrgwatcherOrgWatcher, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &OrgwatcherOrgWatcher{
				client:     group.client,
				OrgWatcher: &item,
			}
		}
	}
	return
}

type OrgwatcherOrgWatcher struct {
	client *Clientset
	*baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher
}

// Delete removes obj and all it's children from the database.
func (obj *OrgwatcherOrgWatcher) Delete(ctx context.Context) error {
	err := obj.client.Orgwatcher().DeleteOrgWatcherByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.OrgWatcher = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *OrgwatcherOrgWatcher) Update(ctx context.Context) error {
	result, err := obj.client.Orgwatcher().UpdateOrgWatcherByName(ctx, obj.OrgWatcher)
	if err != nil {
		return err
	}
	obj.OrgWatcher = result.OrgWatcher
	return nil
}

func (obj *OrgwatcherOrgWatcher) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", obj.Labels, obj.Labels["configs.config.edge-orchestrator.intel.com"])
	logger.Debugf("[GetParent] Get parent of OrgwatcherOrgWatcher name %s [labels %#v] of parent type configs.config.edge-orchestrator.intel.com and name %s", obj.Name, obj.Labels, hashedName)
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type orgwatcherOrgwatcherEdgeV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *orgwatcherOrgwatcherEdgeV1Chainer) Subscribe() {
	key := "orgwatchers.orgwatcher.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerorgwatcheredgeorchestratorintelcomv1.NewOrgWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *orgwatcherOrgwatcherEdgeV1Chainer) Unsubscribe() {
	key := "orgwatchers.orgwatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *orgwatcherOrgwatcherEdgeV1Chainer) IsSubscribed() bool {
	key := "orgwatchers.orgwatcher.edge-orchestrator.intel.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *orgwatcherOrgwatcherEdgeV1Chainer) addCallback(obj *OrgwatcherOrgWatcher) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["configs.config.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[addCallback] received for orgwatchers.orgwatcher.edge-orchestrator.intel.com name %s displayName %s parent configs.config.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	AddChild("configs.config.edge-orchestrator.intel.com", parentHashName, "orgwatchers.orgwatcher.edge-orchestrator.intel.com", obj.Name)
}

func (c *orgwatcherOrgwatcherEdgeV1Chainer) deleteCallback(obj *OrgwatcherOrgWatcher) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["configs.config.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[deleteCallback] received for orgwatchers.orgwatcher.edge-orchestrator.intel.com name %s displayName %s parent configs.config.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	RemoveChild("configs.config.edge-orchestrator.intel.com", parentHashName, "orgwatchers.orgwatcher.edge-orchestrator.intel.com", obj.Name)
}

func (c *orgwatcherOrgwatcherEdgeV1Chainer) RegisterEventHandler(addCB func(obj *OrgwatcherOrgWatcher), updateCB func(oldObj, newObj *OrgwatcherOrgWatcher), deleteCB func(obj *OrgwatcherOrgWatcher)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for OrgwatcherOrgWatcher")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "orgwatchers.orgwatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for OrgwatcherOrgWatcher")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for OrgwatcherOrgWatcher, so creating a new one")
		informer = informerorgwatcheredgeorchestratorintelcomv1.NewOrgWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &OrgwatcherOrgWatcher{
				client:     c.client,
				OrgWatcher: obj.(*baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher),
			}
			logger.Debugf("[RegisterEventHandler AddFunc] Got Add event for orgwatchers.orgwatcher.edge-orchestrator.intel.com name %s", nc.OrgWatcher.Name)

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", nc.Labels, nc.Labels["configs.config.edge-orchestrator.intel.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("configs.config.edge-orchestrator.intel.com", parent.Name, "orgwatchers.orgwatcher.edge-orchestrator.intel.com", nc.Name) {
				AddChild("configs.config.edge-orchestrator.intel.com", parent.Name, "orgwatchers.orgwatcher.edge-orchestrator.intel.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &OrgwatcherOrgWatcher{
				client:     c.client,
				OrgWatcher: oldObj.(*baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher),
			}
			newData := &OrgwatcherOrgWatcher{
				client:     c.client,
				OrgWatcher: newObj.(*baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher),
			}
			logger.Debugf("[RegisterEventHandler UpdateFunc] Got Update event for orgwatchers.orgwatcher.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.OrgWatcher.Name, oldData.ResourceVersion, newData.ResourceVersion)
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &OrgwatcherOrgWatcher{
				client:     c.client,
				OrgWatcher: obj.(*baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher),
			}
			logger.Debugf("[RegisterEventHandler DeleteFunc] Got Delete event for orgwatchers.orgwatcher.edge-orchestrator.intel.com name %s", nc.OrgWatcher.Name)

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", nc.Labels, nc.Labels["configs.config.edge-orchestrator.intel.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("configs.config.edge-orchestrator.intel.com", parent.Name, "orgwatchers.orgwatcher.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("configs.config.edge-orchestrator.intel.com", parent.Name, "orgwatchers.orgwatcher.edge-orchestrator.intel.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *orgwatcherOrgwatcherEdgeV1Chainer) RegisterAddCallback(cbfn func(obj *OrgwatcherOrgWatcher)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterAddCallback] Received for OrgwatcherOrgWatcher")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "orgwatchers.orgwatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for OrgwatcherOrgWatcher")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for OrgwatcherOrgWatcher, so creating a new one")
		informer = informerorgwatcheredgeorchestratorintelcomv1.NewOrgWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &OrgwatcherOrgWatcher{
				client:     c.client,
				OrgWatcher: obj.(*baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher),
			}
			logger.Debugf("[RegisterAddCallback] Got Add event for orgwatchers.orgwatcher.edge-orchestrator.intel.com name %s", nc.OrgWatcher.Name)

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", nc.Labels, nc.Labels["configs.config.edge-orchestrator.intel.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("configs.config.edge-orchestrator.intel.com", parent.Name, "orgwatchers.orgwatcher.edge-orchestrator.intel.com", nc.Name) {
				AddChild("configs.config.edge-orchestrator.intel.com", parent.Name, "orgwatchers.orgwatcher.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *orgwatcherOrgwatcherEdgeV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *OrgwatcherOrgWatcher)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterUpdateCallback] Received for OrgwatcherOrgWatcher")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "orgwatchers.orgwatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for OrgwatcherOrgWatcher")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for OrgwatcherOrgWatcher, so creating a new one")
		informer = informerorgwatcheredgeorchestratorintelcomv1.NewOrgWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &OrgwatcherOrgWatcher{
				client:     c.client,
				OrgWatcher: oldObj.(*baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher),
			}
			newData := &OrgwatcherOrgWatcher{
				client:     c.client,
				OrgWatcher: newObj.(*baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher),
			}
			logger.Debugf("[RegisterUpdateCallback] Got Update event for orgwatchers.orgwatcher.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.OrgWatcher.Name, oldData.ResourceVersion, newData.ResourceVersion)
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *orgwatcherOrgwatcherEdgeV1Chainer) RegisterDeleteCallback(cbfn func(obj *OrgwatcherOrgWatcher)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterDeleteCallback] Received for OrgwatcherOrgWatcher")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "orgwatchers.orgwatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for OrgwatcherOrgWatcher")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for OrgwatcherOrgWatcher, so creating a new one")
		informer = informerorgwatcheredgeorchestratorintelcomv1.NewOrgWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &OrgwatcherOrgWatcher{
				client:     c.client,
				OrgWatcher: obj.(*baseorgwatcheredgeorchestratorintelcomv1.OrgWatcher),
			}
			logger.Debugf("[RegisterDeleteCallback] Got Delete event for orgwatchers.orgwatcher.edge-orchestrator.intel.com name %s", nc.OrgWatcher.Name)

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", nc.Labels, nc.Labels["configs.config.edge-orchestrator.intel.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("configs.config.edge-orchestrator.intel.com", parent.Name, "orgwatchers.orgwatcher.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("configs.config.edge-orchestrator.intel.com", parent.Name, "orgwatchers.orgwatcher.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (group *ProjectwatcherEdgeV1) GetProjectWatcherChildrenMap() map[string]baseprojectwatcheredgeorchestratorintelcomv1.Child {
	return map[string]baseprojectwatcheredgeorchestratorintelcomv1.Child{}
}

func (group *ProjectwatcherEdgeV1) GetProjectWatcherChild(grp, kind, name string) baseprojectwatcheredgeorchestratorintelcomv1.Child {
	return baseprojectwatcheredgeorchestratorintelcomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetProjectWatcherByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ProjectwatcherEdgeV1) GetProjectWatcherByName(ctx context.Context, hashedName string) (*ProjectwatcherProjectWatcher, error) {
	key := "projectwatchers.projectwatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			logger.Debugf("[GetProjectWatcherByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				logger.Fatalf("[GetProjectWatcherByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher).ResourceVersion)
				if writeCacheVersionErr != nil {
					logger.Fatalf("[GetProjectWatcherByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &ProjectwatcherProjectWatcher{
					client:         group.client,
					ProjectWatcher: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &ProjectwatcherProjectWatcher{
				client:         group.client,
				ProjectWatcher: resWrCache.(*baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ProjectwatcherEdgeV1().
			ProjectWatchers().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &ProjectwatcherProjectWatcher{
				client:         group.client,
				ProjectWatcher: result,
			}, nil
		} else if errors.IsNotFound(err) {
			logger.Debugf("[GetProjectWatcherByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on Get ProjectWatchers: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[GetProjectWatcherByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[GetProjectWatcherByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadProjectWatcherByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ProjectwatcherEdgeV1) ForceReadProjectWatcherByName(ctx context.Context, hashedName string) (*ProjectwatcherProjectWatcher, error) {
	logger.Debugf("[ForceReadProjectWatcherByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ProjectwatcherEdgeV1().
			ProjectWatchers().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[ForceReadProjectWatcherByName] Failed to Get ProjectWatchers: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max Retry exceed on Get ProjectWatchers: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[ForceReadProjectWatcherByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[ForceReadProjectWatcherByName]: %+v", err)
				return nil, err
			}
		} else {
			logger.Debugf("[ForceReadProjectWatcherByName] Executed Successfully :%s", hashedName)
			return &ProjectwatcherProjectWatcher{
				client:         group.client,
				ProjectWatcher: result,
			}, nil
		}
	}
}

// DeleteProjectWatcherByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ProjectwatcherEdgeV1) DeleteProjectWatcherByName(ctx context.Context, hashedName string) (err error) {
	logger.Debugf("[DeleteProjectWatcherByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ProjectwatcherEdgeV1().
			ProjectWatchers().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[DeleteProjectWatcherByName] Failed to get ProjectWatchers: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on get ProjectWatchers: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteProjectWatcherByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteProjectWatcherByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteProjectWatcherByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			ProjectwatcherEdgeV1().
			ProjectWatchers().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			logger.Errorf("[DeleteProjectWatcherByName] failed to delete ProjectWatchers: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on delete ProjectWatchers: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteProjectWatcherByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteProjectWatcherByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteProjectWatcherByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("projectwatchers.projectwatcher.edge-orchestrator.intel.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	logger.Debugf("[DeleteProjectWatcherByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	if result.GetLabels() != nil {
		if parents[common.IsNameHashedLabel] == "true" {
			parentName = helper.GetHashedName("configs.config.edge-orchestrator.intel.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("configs.config.edge-orchestrator.intel.com", parents, parentName)
	}
	RemoveChild("configs.config.edge-orchestrator.intel.com", parentName, "projectwatchers.projectwatcher.edge-orchestrator.intel.com", hashedName)

	return nil
}

// CreateProjectWatcherByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ProjectwatcherEdgeV1) CreateProjectWatcherByName(ctx context.Context,
	objToCreate *baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher) (*ProjectwatcherProjectWatcher, error) {
	logger.Debugf("[CreateProjectWatcherByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DisplayNameLabel]; !ok {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ProjectwatcherEdgeV1().
			ProjectWatchers().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			logger.Errorf("[CreateProjectWatcherByName] Failed to create ProjectWatcher: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on create ProjectWatcher: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[CreateProjectWatcherByName] context canceled while creating ProjectWatcher: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				logger.Debugf("[CreateProjectWatcherByName] ProjectWatcher: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.ProjectwatcherEdgeV1().ProjectWatchers().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					logger.Fatalf("[CreateProjectWatcherByName] Unable to Get ProjectWatcher %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				logger.Errorf("[CreateProjectWatcherByName] found unexpected error while creating ProjectWatcher: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			logger.Debugf("[CreateProjectWatcherByName] ProjectWatcher: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("projectwatchers.projectwatcher.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[CreateProjectWatcherByName] ProjectWatcher: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	parentHashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", objToCreate.GetLabels(), parentName)

	AddChild("configs.config.edge-orchestrator.intel.com", parentHashedName, "projectwatchers.projectwatcher.edge-orchestrator.intel.com", objToCreate.Name)

	logger.Debugf("[CreateProjectWatcherByName] Executed Successfully: %s", objToCreate.GetName())
	return &ProjectwatcherProjectWatcher{
		client:         group.client,
		ProjectWatcher: result,
	}, nil
}

// UpdateProjectWatcherByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ProjectwatcherEdgeV1) UpdateProjectWatcherByName(ctx context.Context,
	objToUpdate *baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher) (*ProjectwatcherProjectWatcher, error) {
	logger.Debugf("[UpdateProjectWatcherByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Projectwatcher().GetProjectWatcherByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["projectwatchers.projectwatcher.edge-orchestrator.intel.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IsNameHashedLabel] = current.Labels[common.IsNameHashedLabel]
			objToUpdate.Labels[common.DisplayNameLabel] = current.Labels[common.DisplayNameLabel]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			ProjectwatcherEdgeV1().
			ProjectWatchers().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			logger.Errorf("[UpdateProjectWatcherByName] Failed to patch ProjectWatcher %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					logger.Debugf("Trigger ProjectWatcher Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteProjectWatcherByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						logger.Debugf("Error occur while deleting ProjectWatcher: %s", objToUpdate.GetName())
						return nil, delErr
					}
					logger.Debugf("ProjectWatcher deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[UpdateProjectWatcherByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				logger.Errorf("[UpdateProjectWatcherByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				logger.Debugf("Trigger ProjectWatcher Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteProjectWatcherByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					logger.Debugf("Error occur while deleting ProjectWatcher: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				logger.Debugf("ProjectWatcher Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			logger.Debugf("[UpdateProjectWatcherByName] Patch ProjectWatcher Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("projectwatchers.projectwatcher.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[UpdateProjectWatcherByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	logger.Debugf("[UpdateProjectWatcherByName] Executed Successfully %s", objToUpdate.GetName())
	return &ProjectwatcherProjectWatcher{
		client:         group.client,
		ProjectWatcher: result,
	}, nil
}

// ListProjectWatchers returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ProjectwatcherEdgeV1) ListProjectWatchers(ctx context.Context,
	opts metav1.ListOptions) (result []*ProjectwatcherProjectWatcher, err error) {
	key := "projectwatchers.projectwatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*ProjectwatcherProjectWatcher, len(items))
		for k, v := range items {
			item, _ := v.(*baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher)
			result[k] = &ProjectwatcherProjectWatcher{
				client:         group.client,
				ProjectWatcher: item,
			}
		}
	} else {
		list, err := group.client.baseClient.ProjectwatcherEdgeV1().
			ProjectWatchers().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*ProjectwatcherProjectWatcher, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &ProjectwatcherProjectWatcher{
				client:         group.client,
				ProjectWatcher: &item,
			}
		}
	}
	return
}

type ProjectwatcherProjectWatcher struct {
	client *Clientset
	*baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher
}

// Delete removes obj and all it's children from the database.
func (obj *ProjectwatcherProjectWatcher) Delete(ctx context.Context) error {
	err := obj.client.Projectwatcher().DeleteProjectWatcherByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ProjectWatcher = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ProjectwatcherProjectWatcher) Update(ctx context.Context) error {
	result, err := obj.client.Projectwatcher().UpdateProjectWatcherByName(ctx, obj.ProjectWatcher)
	if err != nil {
		return err
	}
	obj.ProjectWatcher = result.ProjectWatcher
	return nil
}

func (obj *ProjectwatcherProjectWatcher) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", obj.Labels, obj.Labels["configs.config.edge-orchestrator.intel.com"])
	logger.Debugf("[GetParent] Get parent of ProjectwatcherProjectWatcher name %s [labels %#v] of parent type configs.config.edge-orchestrator.intel.com and name %s", obj.Name, obj.Labels, hashedName)
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type projectwatcherProjectwatcherEdgeV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *projectwatcherProjectwatcherEdgeV1Chainer) Subscribe() {
	key := "projectwatchers.projectwatcher.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerprojectwatcheredgeorchestratorintelcomv1.NewProjectWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *projectwatcherProjectwatcherEdgeV1Chainer) Unsubscribe() {
	key := "projectwatchers.projectwatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *projectwatcherProjectwatcherEdgeV1Chainer) IsSubscribed() bool {
	key := "projectwatchers.projectwatcher.edge-orchestrator.intel.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *projectwatcherProjectwatcherEdgeV1Chainer) addCallback(obj *ProjectwatcherProjectWatcher) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["configs.config.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[addCallback] received for projectwatchers.projectwatcher.edge-orchestrator.intel.com name %s displayName %s parent configs.config.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	AddChild("configs.config.edge-orchestrator.intel.com", parentHashName, "projectwatchers.projectwatcher.edge-orchestrator.intel.com", obj.Name)
}

func (c *projectwatcherProjectwatcherEdgeV1Chainer) deleteCallback(obj *ProjectwatcherProjectWatcher) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["configs.config.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[deleteCallback] received for projectwatchers.projectwatcher.edge-orchestrator.intel.com name %s displayName %s parent configs.config.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	RemoveChild("configs.config.edge-orchestrator.intel.com", parentHashName, "projectwatchers.projectwatcher.edge-orchestrator.intel.com", obj.Name)
}

func (c *projectwatcherProjectwatcherEdgeV1Chainer) RegisterEventHandler(addCB func(obj *ProjectwatcherProjectWatcher), updateCB func(oldObj, newObj *ProjectwatcherProjectWatcher), deleteCB func(obj *ProjectwatcherProjectWatcher)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for ProjectwatcherProjectWatcher")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "projectwatchers.projectwatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ProjectwatcherProjectWatcher")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ProjectwatcherProjectWatcher, so creating a new one")
		informer = informerprojectwatcheredgeorchestratorintelcomv1.NewProjectWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ProjectwatcherProjectWatcher{
				client:         c.client,
				ProjectWatcher: obj.(*baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher),
			}
			logger.Debugf("[RegisterEventHandler AddFunc] Got Add event for projectwatchers.projectwatcher.edge-orchestrator.intel.com name %s", nc.ProjectWatcher.Name)

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", nc.Labels, nc.Labels["configs.config.edge-orchestrator.intel.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("configs.config.edge-orchestrator.intel.com", parent.Name, "projectwatchers.projectwatcher.edge-orchestrator.intel.com", nc.Name) {
				AddChild("configs.config.edge-orchestrator.intel.com", parent.Name, "projectwatchers.projectwatcher.edge-orchestrator.intel.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ProjectwatcherProjectWatcher{
				client:         c.client,
				ProjectWatcher: oldObj.(*baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher),
			}
			newData := &ProjectwatcherProjectWatcher{
				client:         c.client,
				ProjectWatcher: newObj.(*baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher),
			}
			logger.Debugf("[RegisterEventHandler UpdateFunc] Got Update event for projectwatchers.projectwatcher.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.ProjectWatcher.Name, oldData.ResourceVersion, newData.ResourceVersion)
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &ProjectwatcherProjectWatcher{
				client:         c.client,
				ProjectWatcher: obj.(*baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher),
			}
			logger.Debugf("[RegisterEventHandler DeleteFunc] Got Delete event for projectwatchers.projectwatcher.edge-orchestrator.intel.com name %s", nc.ProjectWatcher.Name)

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", nc.Labels, nc.Labels["configs.config.edge-orchestrator.intel.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("configs.config.edge-orchestrator.intel.com", parent.Name, "projectwatchers.projectwatcher.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("configs.config.edge-orchestrator.intel.com", parent.Name, "projectwatchers.projectwatcher.edge-orchestrator.intel.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *projectwatcherProjectwatcherEdgeV1Chainer) RegisterAddCallback(cbfn func(obj *ProjectwatcherProjectWatcher)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterAddCallback] Received for ProjectwatcherProjectWatcher")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "projectwatchers.projectwatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ProjectwatcherProjectWatcher")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ProjectwatcherProjectWatcher, so creating a new one")
		informer = informerprojectwatcheredgeorchestratorintelcomv1.NewProjectWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ProjectwatcherProjectWatcher{
				client:         c.client,
				ProjectWatcher: obj.(*baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher),
			}
			logger.Debugf("[RegisterAddCallback] Got Add event for projectwatchers.projectwatcher.edge-orchestrator.intel.com name %s", nc.ProjectWatcher.Name)

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", nc.Labels, nc.Labels["configs.config.edge-orchestrator.intel.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("configs.config.edge-orchestrator.intel.com", parent.Name, "projectwatchers.projectwatcher.edge-orchestrator.intel.com", nc.Name) {
				AddChild("configs.config.edge-orchestrator.intel.com", parent.Name, "projectwatchers.projectwatcher.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *projectwatcherProjectwatcherEdgeV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *ProjectwatcherProjectWatcher)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterUpdateCallback] Received for ProjectwatcherProjectWatcher")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "projectwatchers.projectwatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ProjectwatcherProjectWatcher")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ProjectwatcherProjectWatcher, so creating a new one")
		informer = informerprojectwatcheredgeorchestratorintelcomv1.NewProjectWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ProjectwatcherProjectWatcher{
				client:         c.client,
				ProjectWatcher: oldObj.(*baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher),
			}
			newData := &ProjectwatcherProjectWatcher{
				client:         c.client,
				ProjectWatcher: newObj.(*baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher),
			}
			logger.Debugf("[RegisterUpdateCallback] Got Update event for projectwatchers.projectwatcher.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.ProjectWatcher.Name, oldData.ResourceVersion, newData.ResourceVersion)
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *projectwatcherProjectwatcherEdgeV1Chainer) RegisterDeleteCallback(cbfn func(obj *ProjectwatcherProjectWatcher)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterDeleteCallback] Received for ProjectwatcherProjectWatcher")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "projectwatchers.projectwatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ProjectwatcherProjectWatcher")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ProjectwatcherProjectWatcher, so creating a new one")
		informer = informerprojectwatcheredgeorchestratorintelcomv1.NewProjectWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &ProjectwatcherProjectWatcher{
				client:         c.client,
				ProjectWatcher: obj.(*baseprojectwatcheredgeorchestratorintelcomv1.ProjectWatcher),
			}
			logger.Debugf("[RegisterDeleteCallback] Got Delete event for projectwatchers.projectwatcher.edge-orchestrator.intel.com name %s", nc.ProjectWatcher.Name)

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.edge-orchestrator.intel.com", nc.Labels, nc.Labels["configs.config.edge-orchestrator.intel.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("configs.config.edge-orchestrator.intel.com", parent.Name, "projectwatchers.projectwatcher.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("configs.config.edge-orchestrator.intel.com", parent.Name, "projectwatchers.projectwatcher.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (group *RuntimeEdgeV1) GetRuntimeChildrenMap() map[string]baseruntimeedgeorchestratorintelcomv1.Child {
	return map[string]baseruntimeedgeorchestratorintelcomv1.Child{}
}

func (group *RuntimeEdgeV1) GetRuntimeChild(grp, kind, name string) baseruntimeedgeorchestratorintelcomv1.Child {
	return baseruntimeedgeorchestratorintelcomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetRuntimeByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RuntimeEdgeV1) GetRuntimeByName(ctx context.Context, hashedName string) (*RuntimeRuntime, error) {
	key := "runtimes.runtime.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			logger.Debugf("[GetRuntimeByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseruntimeedgeorchestratorintelcomv1.Runtime)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				logger.Fatalf("[GetRuntimeByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseruntimeedgeorchestratorintelcomv1.Runtime).ResourceVersion)
				if writeCacheVersionErr != nil {
					logger.Fatalf("[GetRuntimeByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &RuntimeRuntime{
					client:  group.client,
					Runtime: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &RuntimeRuntime{
				client:  group.client,
				Runtime: resWrCache.(*baseruntimeedgeorchestratorintelcomv1.Runtime),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RuntimeEdgeV1().
			Runtimes().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &RuntimeRuntime{
				client:  group.client,
				Runtime: result,
			}, nil
		} else if errors.IsNotFound(err) {
			logger.Debugf("[GetRuntimeByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on Get Runtimes: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[GetRuntimeByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[GetRuntimeByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadRuntimeByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RuntimeEdgeV1) ForceReadRuntimeByName(ctx context.Context, hashedName string) (*RuntimeRuntime, error) {
	logger.Debugf("[ForceReadRuntimeByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RuntimeEdgeV1().
			Runtimes().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[ForceReadRuntimeByName] Failed to Get Runtimes: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max Retry exceed on Get Runtimes: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[ForceReadRuntimeByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[ForceReadRuntimeByName]: %+v", err)
				return nil, err
			}
		} else {
			logger.Debugf("[ForceReadRuntimeByName] Executed Successfully :%s", hashedName)
			return &RuntimeRuntime{
				client:  group.client,
				Runtime: result,
			}, nil
		}
	}
}

// DeleteRuntimeByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RuntimeEdgeV1) DeleteRuntimeByName(ctx context.Context, hashedName string) (err error) {
	logger.Debugf("[DeleteRuntimeByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseruntimeedgeorchestratorintelcomv1.Runtime
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RuntimeEdgeV1().
			Runtimes().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[DeleteRuntimeByName] Failed to get Runtimes: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on get Runtimes: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteRuntimeByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteRuntimeByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteRuntimeByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("runtimes.runtime.edge-orchestrator.intel.com", hashedName, "runtimeorgs.runtimeorg.edge-orchestrator.intel.com") {
		err := group.client.Runtimeorg().DeleteRuntimeOrgByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("runtimes.runtime.edge-orchestrator.intel.com", hashedName, "runtimeorgs.runtimeorg.edge-orchestrator.intel.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			RuntimeEdgeV1().
			Runtimes().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			logger.Errorf("[DeleteRuntimeByName] failed to delete Runtimes: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on delete Runtimes: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteRuntimeByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteRuntimeByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteRuntimeByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("runtimes.runtime.edge-orchestrator.intel.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	logger.Debugf("[DeleteRuntimeByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["multitenancies.tenancy.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	if result.GetLabels() != nil {
		if parents[common.IsNameHashedLabel] == "true" {
			parentName = helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", parents, parentName)
	}
	RemoveChild("multitenancies.tenancy.edge-orchestrator.intel.com", parentName, "runtimes.runtime.edge-orchestrator.intel.com", hashedName)

	return nil
}

// CreateRuntimeByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RuntimeEdgeV1) CreateRuntimeByName(ctx context.Context,
	objToCreate *baseruntimeedgeorchestratorintelcomv1.Runtime) (*RuntimeRuntime, error) {
	logger.Debugf("[CreateRuntimeByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DisplayNameLabel]; !ok {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DisplayNameLabel] == "" {
		objToCreate.Labels[common.DisplayNameLabel] = helper.DefaultKey
	}
	if objToCreate.Labels[common.DisplayNameLabel] != helper.DefaultKey {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DisplayNameLabel])
	}

	objToCreate.Spec.OrgsGvk = nil

	var (
		retryCount int
		result     *baseruntimeedgeorchestratorintelcomv1.Runtime
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RuntimeEdgeV1().
			Runtimes().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			logger.Errorf("[CreateRuntimeByName] Failed to create Runtime: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on create Runtime: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[CreateRuntimeByName] context canceled while creating Runtime: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				logger.Debugf("[CreateRuntimeByName] Runtime: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.RuntimeEdgeV1().Runtimes().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					logger.Fatalf("[CreateRuntimeByName] Unable to Get Runtime %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				logger.Errorf("[CreateRuntimeByName] found unexpected error while creating Runtime: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			logger.Debugf("[CreateRuntimeByName] Runtime: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("runtimes.runtime.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[CreateRuntimeByName] Runtime: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["multitenancies.tenancy.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	parentHashedName := helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", objToCreate.GetLabels(), parentName)

	AddChild("multitenancies.tenancy.edge-orchestrator.intel.com", parentHashedName, "runtimes.runtime.edge-orchestrator.intel.com", objToCreate.Name)

	logger.Debugf("[CreateRuntimeByName] Executed Successfully: %s", objToCreate.GetName())
	return &RuntimeRuntime{
		client:  group.client,
		Runtime: result,
	}, nil
}

// UpdateRuntimeByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RuntimeEdgeV1) UpdateRuntimeByName(ctx context.Context,
	objToUpdate *baseruntimeedgeorchestratorintelcomv1.Runtime) (*RuntimeRuntime, error) {
	logger.Debugf("[UpdateRuntimeByName] Received objToUpdate: %s", objToUpdate.GetName())
	if objToUpdate.Labels[common.DisplayNameLabel] != helper.DefaultKey {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DisplayNameLabel])
	}

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Runtime().GetRuntimeByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["runtimes.runtime.edge-orchestrator.intel.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IsNameHashedLabel] = current.Labels[common.IsNameHashedLabel]
			objToUpdate.Labels[common.DisplayNameLabel] = current.Labels[common.DisplayNameLabel]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseruntimeedgeorchestratorintelcomv1.Runtime
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			RuntimeEdgeV1().
			Runtimes().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			logger.Errorf("[UpdateRuntimeByName] Failed to patch Runtime %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					logger.Debugf("Trigger Runtime Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteRuntimeByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						logger.Debugf("Error occur while deleting Runtime: %s", objToUpdate.GetName())
						return nil, delErr
					}
					logger.Debugf("Runtime deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[UpdateRuntimeByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				logger.Errorf("[UpdateRuntimeByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				logger.Debugf("Trigger Runtime Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteRuntimeByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					logger.Debugf("Error occur while deleting Runtime: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				logger.Debugf("Runtime Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			logger.Debugf("[UpdateRuntimeByName] Patch Runtime Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("runtimes.runtime.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[UpdateRuntimeByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	logger.Debugf("[UpdateRuntimeByName] Executed Successfully %s", objToUpdate.GetName())
	return &RuntimeRuntime{
		client:  group.client,
		Runtime: result,
	}, nil
}

// ListRuntimes returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RuntimeEdgeV1) ListRuntimes(ctx context.Context,
	opts metav1.ListOptions) (result []*RuntimeRuntime, err error) {
	key := "runtimes.runtime.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*RuntimeRuntime, len(items))
		for k, v := range items {
			item, _ := v.(*baseruntimeedgeorchestratorintelcomv1.Runtime)
			result[k] = &RuntimeRuntime{
				client:  group.client,
				Runtime: item,
			}
		}
	} else {
		list, err := group.client.baseClient.RuntimeEdgeV1().
			Runtimes().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*RuntimeRuntime, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &RuntimeRuntime{
				client:  group.client,
				Runtime: &item,
			}
		}
	}
	return
}

type RuntimeRuntime struct {
	client *Clientset
	*baseruntimeedgeorchestratorintelcomv1.Runtime
}

// Delete removes obj and all it's children from the database.
func (obj *RuntimeRuntime) Delete(ctx context.Context) error {
	err := obj.client.Runtime().DeleteRuntimeByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Runtime = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RuntimeRuntime) Update(ctx context.Context) error {
	result, err := obj.client.Runtime().UpdateRuntimeByName(ctx, obj.Runtime)
	if err != nil {
		return err
	}
	obj.Runtime = result.Runtime
	return nil
}

func (obj *RuntimeRuntime) GetParent(ctx context.Context) (result *TenancyMultiTenancy, err error) {
	hashedName := helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", obj.Labels, obj.Labels["multitenancies.tenancy.edge-orchestrator.intel.com"])
	logger.Debugf("[GetParent] Get parent of RuntimeRuntime name %s [labels %#v] of parent type multitenancies.tenancy.edge-orchestrator.intel.com and name %s", obj.Name, obj.Labels, hashedName)
	return obj.client.Tenancy().GetMultiTenancyByName(ctx, hashedName)
}

type RuntimeRuntimeOrgs struct {
	client *Clientset
	Orgs   []baseruntimeedgeorchestratorintelcomv1.Child
}

func (n *RuntimeRuntimeOrgs) Next(ctx context.Context) (*RuntimeorgRuntimeOrg, error) {
	for index, child := range n.Orgs {
		logger.Debugf("[RuntimeRuntimeOrgs Next] Get next Orgs with name %s", child.Name)
		obj, err := n.client.Runtimeorg().GetRuntimeOrgByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Orgs)-1 {
				n.Orgs = nil
			} else {
				n.Orgs = n.Orgs[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllOrgsIter returns an iterator for all children of given type
func (obj *RuntimeRuntime) GetAllOrgsIter(ctx context.Context) (
	result RuntimeRuntimeOrgs) {
	result.client = obj.client
	for _, v := range GetChildren("runtimes.runtime.edge-orchestrator.intel.com", obj.Name, "runtimeorgs.runtimeorg.edge-orchestrator.intel.com") {
		result.Orgs = append(result.Orgs, baseruntimeedgeorchestratorintelcomv1.Child{
			Group: "runtimeorg.edge-orchestrator.intel.com",
			Kind:  "RuntimeOrg",
			Name:  v,
		})
	}
	return
}

// GetAllOrgs returns all children of a given type
func (obj *RuntimeRuntime) GetAllOrgs(ctx context.Context) (
	result []*RuntimeorgRuntimeOrg, err error) {
	for _, v := range GetChildren("runtimes.runtime.edge-orchestrator.intel.com", obj.Name, "runtimeorgs.runtimeorg.edge-orchestrator.intel.com") {
		logger.Debugf("[RuntimeRuntime GetAllOrgs] Get next Orgs with name %s", v)
		l, err := obj.client.Runtimeorg().GetRuntimeOrgByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetOrgs returns child which has given displayName
func (obj *RuntimeRuntime) GetOrgs(ctx context.Context,
	displayName string) (result *RuntimeorgRuntimeOrg, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["runtimes.runtime.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parentLabels, displayName)
	logger.Debugf("[GetOrgs] in RuntimeRuntime with name %s, displayName %s, parentLabels %#v", childHashName, displayName, parentLabels)
	if IsChildExists("runtimes.runtime.edge-orchestrator.intel.com", obj.Name, "runtimeorgs.runtimeorg.edge-orchestrator.intel.com", childHashName) == false {
		logger.Debugf("[GetOrgs] ChildNotFound Orgs with name %s, displayName %s ", childHashName, displayName)
		return nil, NewChildNotFound(obj.DisplayName(), "Runtime.Runtime", "Orgs", displayName)
	}

	logger.Debugf("[GetOrgs] invoke GetRuntimeOrgByName name %s, displayName %s", childHashName, displayName)
	result, err = obj.client.Runtimeorg().GetRuntimeOrgByName(ctx, childHashName)
	return
}

// AddOrgs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RuntimeRuntime) AddOrgs(ctx context.Context,
	objToCreate *baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg) (result *RuntimeorgRuntimeOrg, err error) {
	logger.Debugf("[AddOrgs] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimes.runtime.edge-orchestrator.intel.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimes.runtime.edge-orchestrator.intel.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Runtimeorg().CreateRuntimeOrgByName(ctx, objToCreate)
	logger.Debugf("[AddOrgs] RuntimeOrg created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Runtime().GetRuntimeByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Runtime = updatedObj.Runtime
	}
	logger.Debugf("[AddOrgs] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteOrgs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RuntimeRuntime) DeleteOrgs(ctx context.Context, displayName string) (err error) {
	logger.Debugf("[ DeleteOrgs] Received for RuntimeOrg object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["runtimes.runtime.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parentLabels, displayName)
	if IsChildExists("runtimes.runtime.edge-orchestrator.intel.com", obj.Name, "runtimeorgs.runtimeorg.edge-orchestrator.intel.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Runtime.Runtime", "Orgs", displayName)
	}

	err = obj.client.Runtimeorg().DeleteRuntimeOrgByName(ctx, childHashName)
	if err != nil {
		return err
	}
	logger.Debugf("[ DeleteOrgs] RuntimeOrg object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Runtime().GetRuntimeByName(ctx, obj.GetName())
	if err == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

type runtimeRuntimeEdgeV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *runtimeRuntimeEdgeV1Chainer) Subscribe() {
	key := "runtimes.runtime.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerruntimeedgeorchestratorintelcomv1.NewRuntimeInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *runtimeRuntimeEdgeV1Chainer) Unsubscribe() {
	key := "runtimes.runtime.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *runtimeRuntimeEdgeV1Chainer) IsSubscribed() bool {
	key := "runtimes.runtime.edge-orchestrator.intel.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *runtimeRuntimeEdgeV1Chainer) addCallback(obj *RuntimeRuntime) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["multitenancies.tenancy.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[addCallback] received for runtimes.runtime.edge-orchestrator.intel.com name %s displayName %s parent multitenancies.tenancy.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	AddChild("multitenancies.tenancy.edge-orchestrator.intel.com", parentHashName, "runtimes.runtime.edge-orchestrator.intel.com", obj.Name)
}

func (c *runtimeRuntimeEdgeV1Chainer) deleteCallback(obj *RuntimeRuntime) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["multitenancies.tenancy.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[deleteCallback] received for runtimes.runtime.edge-orchestrator.intel.com name %s displayName %s parent multitenancies.tenancy.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	RemoveChild("multitenancies.tenancy.edge-orchestrator.intel.com", parentHashName, "runtimes.runtime.edge-orchestrator.intel.com", obj.Name)
}

func (c *runtimeRuntimeEdgeV1Chainer) RegisterEventHandler(addCB func(obj *RuntimeRuntime), updateCB func(oldObj, newObj *RuntimeRuntime), deleteCB func(obj *RuntimeRuntime)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for RuntimeRuntime")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "runtimes.runtime.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimeRuntime")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimeRuntime, so creating a new one")
		informer = informerruntimeedgeorchestratorintelcomv1.NewRuntimeInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RuntimeRuntime{
				client:  c.client,
				Runtime: obj.(*baseruntimeedgeorchestratorintelcomv1.Runtime),
			}
			logger.Debugf("[RegisterEventHandler AddFunc] Got Add event for runtimes.runtime.edge-orchestrator.intel.com name %s", nc.Runtime.Name)

			var parent *TenancyMultiTenancy
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", nc.Labels, nc.Labels["multitenancies.tenancy.edge-orchestrator.intel.com"])
				parent, err = c.client.Tenancy().ForceReadMultiTenancyByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("multitenancies.tenancy.edge-orchestrator.intel.com", parent.Name, "runtimes.runtime.edge-orchestrator.intel.com", nc.Name) {
				AddChild("multitenancies.tenancy.edge-orchestrator.intel.com", parent.Name, "runtimes.runtime.edge-orchestrator.intel.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RuntimeRuntime{
				client:  c.client,
				Runtime: oldObj.(*baseruntimeedgeorchestratorintelcomv1.Runtime),
			}
			newData := &RuntimeRuntime{
				client:  c.client,
				Runtime: newObj.(*baseruntimeedgeorchestratorintelcomv1.Runtime),
			}
			logger.Debugf("[RegisterEventHandler UpdateFunc] Got Update event for runtimes.runtime.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.Runtime.Name, oldData.ResourceVersion, newData.ResourceVersion)
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &RuntimeRuntime{
				client:  c.client,
				Runtime: obj.(*baseruntimeedgeorchestratorintelcomv1.Runtime),
			}
			logger.Debugf("[RegisterEventHandler DeleteFunc] Got Delete event for runtimes.runtime.edge-orchestrator.intel.com name %s", nc.Runtime.Name)

			var parent *TenancyMultiTenancy
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", nc.Labels, nc.Labels["multitenancies.tenancy.edge-orchestrator.intel.com"])
				parent, err = c.client.Tenancy().ForceReadMultiTenancyByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("multitenancies.tenancy.edge-orchestrator.intel.com", parent.Name, "runtimes.runtime.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("multitenancies.tenancy.edge-orchestrator.intel.com", parent.Name, "runtimes.runtime.edge-orchestrator.intel.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *runtimeRuntimeEdgeV1Chainer) RegisterAddCallback(cbfn func(obj *RuntimeRuntime)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterAddCallback] Received for RuntimeRuntime")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "runtimes.runtime.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimeRuntime")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimeRuntime, so creating a new one")
		informer = informerruntimeedgeorchestratorintelcomv1.NewRuntimeInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RuntimeRuntime{
				client:  c.client,
				Runtime: obj.(*baseruntimeedgeorchestratorintelcomv1.Runtime),
			}
			logger.Debugf("[RegisterAddCallback] Got Add event for runtimes.runtime.edge-orchestrator.intel.com name %s", nc.Runtime.Name)

			var parent *TenancyMultiTenancy
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", nc.Labels, nc.Labels["multitenancies.tenancy.edge-orchestrator.intel.com"])
				parent, err = c.client.Tenancy().ForceReadMultiTenancyByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("multitenancies.tenancy.edge-orchestrator.intel.com", parent.Name, "runtimes.runtime.edge-orchestrator.intel.com", nc.Name) {
				AddChild("multitenancies.tenancy.edge-orchestrator.intel.com", parent.Name, "runtimes.runtime.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *runtimeRuntimeEdgeV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *RuntimeRuntime)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterUpdateCallback] Received for RuntimeRuntime")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "runtimes.runtime.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimeRuntime")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimeRuntime, so creating a new one")
		informer = informerruntimeedgeorchestratorintelcomv1.NewRuntimeInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RuntimeRuntime{
				client:  c.client,
				Runtime: oldObj.(*baseruntimeedgeorchestratorintelcomv1.Runtime),
			}
			newData := &RuntimeRuntime{
				client:  c.client,
				Runtime: newObj.(*baseruntimeedgeorchestratorintelcomv1.Runtime),
			}
			logger.Debugf("[RegisterUpdateCallback] Got Update event for runtimes.runtime.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.Runtime.Name, oldData.ResourceVersion, newData.ResourceVersion)
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *runtimeRuntimeEdgeV1Chainer) RegisterDeleteCallback(cbfn func(obj *RuntimeRuntime)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterDeleteCallback] Received for RuntimeRuntime")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "runtimes.runtime.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimeRuntime")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimeRuntime, so creating a new one")
		informer = informerruntimeedgeorchestratorintelcomv1.NewRuntimeInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &RuntimeRuntime{
				client:  c.client,
				Runtime: obj.(*baseruntimeedgeorchestratorintelcomv1.Runtime),
			}
			logger.Debugf("[RegisterDeleteCallback] Got Delete event for runtimes.runtime.edge-orchestrator.intel.com name %s", nc.Runtime.Name)

			var parent *TenancyMultiTenancy
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("multitenancies.tenancy.edge-orchestrator.intel.com", nc.Labels, nc.Labels["multitenancies.tenancy.edge-orchestrator.intel.com"])
				parent, err = c.client.Tenancy().ForceReadMultiTenancyByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("multitenancies.tenancy.edge-orchestrator.intel.com", parent.Name, "runtimes.runtime.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("multitenancies.tenancy.edge-orchestrator.intel.com", parent.Name, "runtimes.runtime.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *runtimeRuntimeEdgeV1Chainer) Orgs(name string) *runtimeorgRuntimeorgEdgeV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"] = name
	return &runtimeorgRuntimeorgEdgeV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetOrgs calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *runtimeRuntimeEdgeV1Chainer) GetOrgs(ctx context.Context, displayName string) (result *RuntimeorgRuntimeOrg, err error) {
	hashedName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", c.parentLabels, displayName)
	logger.Debugf("[GetOrgs] using chainer for name %s, displayName %s, labels %#v", hashedName, displayName, c.parentLabels)
	return c.client.Runtimeorg().GetRuntimeOrgByName(ctx, hashedName)
}

// AddOrgs calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimeRuntimeEdgeV1Chainer) AddOrgs(ctx context.Context,
	objToCreate *baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg) (result *RuntimeorgRuntimeOrg, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Runtimeorg().CreateRuntimeOrgByName(ctx, objToCreate)
}

// DeleteOrgs calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimeRuntimeEdgeV1Chainer) DeleteOrgs(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IsNameHashedLabel] = "true"
	hashedName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", c.parentLabels, name)
	return c.client.Runtimeorg().DeleteRuntimeOrgByName(ctx, hashedName)
}

func (group *RuntimeorgEdgeV1) GetRuntimeOrgChildrenMap() map[string]baseruntimeorgedgeorchestratorintelcomv1.Child {
	return map[string]baseruntimeorgedgeorchestratorintelcomv1.Child{}
}

func (group *RuntimeorgEdgeV1) GetRuntimeOrgChild(grp, kind, name string) baseruntimeorgedgeorchestratorintelcomv1.Child {
	return baseruntimeorgedgeorchestratorintelcomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetRuntimeOrgByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RuntimeorgEdgeV1) GetRuntimeOrgByName(ctx context.Context, hashedName string) (*RuntimeorgRuntimeOrg, error) {
	key := "runtimeorgs.runtimeorg.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			logger.Debugf("[GetRuntimeOrgByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				logger.Fatalf("[GetRuntimeOrgByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg).ResourceVersion)
				if writeCacheVersionErr != nil {
					logger.Fatalf("[GetRuntimeOrgByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &RuntimeorgRuntimeOrg{
					client:     group.client,
					RuntimeOrg: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &RuntimeorgRuntimeOrg{
				client:     group.client,
				RuntimeOrg: resWrCache.(*baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RuntimeorgEdgeV1().
			RuntimeOrgs().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &RuntimeorgRuntimeOrg{
				client:     group.client,
				RuntimeOrg: result,
			}, nil
		} else if errors.IsNotFound(err) {
			logger.Debugf("[GetRuntimeOrgByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on Get RuntimeOrgs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[GetRuntimeOrgByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[GetRuntimeOrgByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadRuntimeOrgByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RuntimeorgEdgeV1) ForceReadRuntimeOrgByName(ctx context.Context, hashedName string) (*RuntimeorgRuntimeOrg, error) {
	logger.Debugf("[ForceReadRuntimeOrgByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RuntimeorgEdgeV1().
			RuntimeOrgs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[ForceReadRuntimeOrgByName] Failed to Get RuntimeOrgs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max Retry exceed on Get RuntimeOrgs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[ForceReadRuntimeOrgByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[ForceReadRuntimeOrgByName]: %+v", err)
				return nil, err
			}
		} else {
			logger.Debugf("[ForceReadRuntimeOrgByName] Executed Successfully :%s", hashedName)
			return &RuntimeorgRuntimeOrg{
				client:     group.client,
				RuntimeOrg: result,
			}, nil
		}
	}
}

// DeleteRuntimeOrgByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RuntimeorgEdgeV1) DeleteRuntimeOrgByName(ctx context.Context, hashedName string) (err error) {
	logger.Debugf("[DeleteRuntimeOrgByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RuntimeorgEdgeV1().
			RuntimeOrgs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[DeleteRuntimeOrgByName] Failed to get RuntimeOrgs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on get RuntimeOrgs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteRuntimeOrgByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteRuntimeOrgByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteRuntimeOrgByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", hashedName, "runtimefolders.runtimefolder.edge-orchestrator.intel.com") {
		err := group.client.Runtimefolder().DeleteRuntimeFolderByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", hashedName, "runtimefolders.runtimefolder.edge-orchestrator.intel.com", child)
	}

	for _, child := range GetChildren("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", hashedName, "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com") {
		err := group.client.Orgactivewatcher().DeleteOrgActiveWatcherByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", hashedName, "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			RuntimeorgEdgeV1().
			RuntimeOrgs().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			logger.Errorf("[DeleteRuntimeOrgByName] failed to delete RuntimeOrgs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on delete RuntimeOrgs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteRuntimeOrgByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteRuntimeOrgByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteRuntimeOrgByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("runtimeorgs.runtimeorg.edge-orchestrator.intel.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	logger.Debugf("[DeleteRuntimeOrgByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimes.runtime.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	if result.GetLabels() != nil {
		if parents[common.IsNameHashedLabel] == "true" {
			parentName = helper.GetHashedName("runtimes.runtime.edge-orchestrator.intel.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("runtimes.runtime.edge-orchestrator.intel.com", parents, parentName)
	}
	RemoveChild("runtimes.runtime.edge-orchestrator.intel.com", parentName, "runtimeorgs.runtimeorg.edge-orchestrator.intel.com", hashedName)

	return nil
}

// CreateRuntimeOrgByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RuntimeorgEdgeV1) CreateRuntimeOrgByName(ctx context.Context,
	objToCreate *baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg) (*RuntimeorgRuntimeOrg, error) {
	logger.Debugf("[CreateRuntimeOrgByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DisplayNameLabel]; !ok {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
	}

	objToCreate.Spec.FoldersGvk = nil
	objToCreate.Spec.ActiveWatchersGvk = nil

	var (
		retryCount int
		result     *baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RuntimeorgEdgeV1().
			RuntimeOrgs().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			logger.Errorf("[CreateRuntimeOrgByName] Failed to create RuntimeOrg: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on create RuntimeOrg: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[CreateRuntimeOrgByName] context canceled while creating RuntimeOrg: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				logger.Debugf("[CreateRuntimeOrgByName] RuntimeOrg: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.RuntimeorgEdgeV1().RuntimeOrgs().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					logger.Fatalf("[CreateRuntimeOrgByName] Unable to Get RuntimeOrg %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				logger.Errorf("[CreateRuntimeOrgByName] found unexpected error while creating RuntimeOrg: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			logger.Debugf("[CreateRuntimeOrgByName] RuntimeOrg: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("runtimeorgs.runtimeorg.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[CreateRuntimeOrgByName] RuntimeOrg: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["runtimes.runtime.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	parentHashedName := helper.GetHashedName("runtimes.runtime.edge-orchestrator.intel.com", objToCreate.GetLabels(), parentName)

	AddChild("runtimes.runtime.edge-orchestrator.intel.com", parentHashedName, "runtimeorgs.runtimeorg.edge-orchestrator.intel.com", objToCreate.Name)

	logger.Debugf("[CreateRuntimeOrgByName] Executed Successfully: %s", objToCreate.GetName())
	return &RuntimeorgRuntimeOrg{
		client:     group.client,
		RuntimeOrg: result,
	}, nil
}

// UpdateRuntimeOrgByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RuntimeorgEdgeV1) UpdateRuntimeOrgByName(ctx context.Context,
	objToUpdate *baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg) (*RuntimeorgRuntimeOrg, error) {
	logger.Debugf("[UpdateRuntimeOrgByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Runtimeorg().GetRuntimeOrgByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IsNameHashedLabel] = current.Labels[common.IsNameHashedLabel]
			objToUpdate.Labels[common.DisplayNameLabel] = current.Labels[common.DisplayNameLabel]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Deleted)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Deleted).IsNil() {
			patchValueDeleted := objToUpdate.Spec.Deleted
			patchOpDeleted := PatchOp{
				Op:    "replace",
				Path:  "/spec/deleted",
				Value: patchValueDeleted,
			}
			patch = append(patch, patchOpDeleted)
		}
	} else {
		patchValueDeleted := objToUpdate.Spec.Deleted
		patchOpDeleted := PatchOp{
			Op:    "replace",
			Path:  "/spec/deleted",
			Value: patchValueDeleted,
		}
		patch = append(patch, patchOpDeleted)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			RuntimeorgEdgeV1().
			RuntimeOrgs().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			logger.Errorf("[UpdateRuntimeOrgByName] Failed to patch RuntimeOrg %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					logger.Debugf("Trigger RuntimeOrg Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteRuntimeOrgByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						logger.Debugf("Error occur while deleting RuntimeOrg: %s", objToUpdate.GetName())
						return nil, delErr
					}
					logger.Debugf("RuntimeOrg deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[UpdateRuntimeOrgByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				logger.Errorf("[UpdateRuntimeOrgByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				logger.Debugf("Trigger RuntimeOrg Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteRuntimeOrgByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					logger.Debugf("Error occur while deleting RuntimeOrg: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				logger.Debugf("RuntimeOrg Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			logger.Debugf("[UpdateRuntimeOrgByName] Patch RuntimeOrg Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("runtimeorgs.runtimeorg.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[UpdateRuntimeOrgByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	logger.Debugf("[UpdateRuntimeOrgByName] Executed Successfully %s", objToUpdate.GetName())
	return &RuntimeorgRuntimeOrg{
		client:     group.client,
		RuntimeOrg: result,
	}, nil
}

// ListRuntimeOrgs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RuntimeorgEdgeV1) ListRuntimeOrgs(ctx context.Context,
	opts metav1.ListOptions) (result []*RuntimeorgRuntimeOrg, err error) {
	key := "runtimeorgs.runtimeorg.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*RuntimeorgRuntimeOrg, len(items))
		for k, v := range items {
			item, _ := v.(*baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg)
			result[k] = &RuntimeorgRuntimeOrg{
				client:     group.client,
				RuntimeOrg: item,
			}
		}
	} else {
		list, err := group.client.baseClient.RuntimeorgEdgeV1().
			RuntimeOrgs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*RuntimeorgRuntimeOrg, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &RuntimeorgRuntimeOrg{
				client:     group.client,
				RuntimeOrg: &item,
			}
		}
	}
	return
}

type RuntimeorgRuntimeOrg struct {
	client *Clientset
	*baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg
}

// Delete removes obj and all it's children from the database.
func (obj *RuntimeorgRuntimeOrg) Delete(ctx context.Context) error {
	err := obj.client.Runtimeorg().DeleteRuntimeOrgByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.RuntimeOrg = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RuntimeorgRuntimeOrg) Update(ctx context.Context) error {
	result, err := obj.client.Runtimeorg().UpdateRuntimeOrgByName(ctx, obj.RuntimeOrg)
	if err != nil {
		return err
	}
	obj.RuntimeOrg = result.RuntimeOrg
	return nil
}

func (obj *RuntimeorgRuntimeOrg) GetParent(ctx context.Context) (result *RuntimeRuntime, err error) {
	hashedName := helper.GetHashedName("runtimes.runtime.edge-orchestrator.intel.com", obj.Labels, obj.Labels["runtimes.runtime.edge-orchestrator.intel.com"])
	logger.Debugf("[GetParent] Get parent of RuntimeorgRuntimeOrg name %s [labels %#v] of parent type runtimes.runtime.edge-orchestrator.intel.com and name %s", obj.Name, obj.Labels, hashedName)
	return obj.client.Runtime().GetRuntimeByName(ctx, hashedName)
}

type RuntimeorgRuntimeOrgFolders struct {
	client  *Clientset
	Folders []baseruntimeorgedgeorchestratorintelcomv1.Child
}

func (n *RuntimeorgRuntimeOrgFolders) Next(ctx context.Context) (*RuntimefolderRuntimeFolder, error) {
	for index, child := range n.Folders {
		logger.Debugf("[RuntimeorgRuntimeOrgFolders Next] Get next Folders with name %s", child.Name)
		obj, err := n.client.Runtimefolder().GetRuntimeFolderByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Folders)-1 {
				n.Folders = nil
			} else {
				n.Folders = n.Folders[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllFoldersIter returns an iterator for all children of given type
func (obj *RuntimeorgRuntimeOrg) GetAllFoldersIter(ctx context.Context) (
	result RuntimeorgRuntimeOrgFolders) {
	result.client = obj.client
	for _, v := range GetChildren("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", obj.Name, "runtimefolders.runtimefolder.edge-orchestrator.intel.com") {
		result.Folders = append(result.Folders, baseruntimeorgedgeorchestratorintelcomv1.Child{
			Group: "runtimefolder.edge-orchestrator.intel.com",
			Kind:  "RuntimeFolder",
			Name:  v,
		})
	}
	return
}

// GetAllFolders returns all children of a given type
func (obj *RuntimeorgRuntimeOrg) GetAllFolders(ctx context.Context) (
	result []*RuntimefolderRuntimeFolder, err error) {
	for _, v := range GetChildren("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", obj.Name, "runtimefolders.runtimefolder.edge-orchestrator.intel.com") {
		logger.Debugf("[RuntimeorgRuntimeOrg GetAllFolders] Get next Folders with name %s", v)
		l, err := obj.client.Runtimefolder().GetRuntimeFolderByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetFolders returns child which has given displayName
func (obj *RuntimeorgRuntimeOrg) GetFolders(ctx context.Context,
	displayName string) (result *RuntimefolderRuntimeFolder, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("runtimefolders.runtimefolder.edge-orchestrator.intel.com", parentLabels, displayName)
	logger.Debugf("[GetFolders] in RuntimeorgRuntimeOrg with name %s, displayName %s, parentLabels %#v", childHashName, displayName, parentLabels)
	if IsChildExists("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", obj.Name, "runtimefolders.runtimefolder.edge-orchestrator.intel.com", childHashName) == false {
		logger.Debugf("[GetFolders] ChildNotFound Folders with name %s, displayName %s ", childHashName, displayName)
		return nil, NewChildNotFound(obj.DisplayName(), "Runtimeorg.RuntimeOrg", "Folders", displayName)
	}

	logger.Debugf("[GetFolders] invoke GetRuntimeFolderByName name %s, displayName %s", childHashName, displayName)
	result, err = obj.client.Runtimefolder().GetRuntimeFolderByName(ctx, childHashName)
	return
}

// AddFolders calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RuntimeorgRuntimeOrg) AddFolders(ctx context.Context,
	objToCreate *baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder) (result *RuntimefolderRuntimeFolder, err error) {
	logger.Debugf("[AddFolders] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Runtimefolder().CreateRuntimeFolderByName(ctx, objToCreate)
	logger.Debugf("[AddFolders] RuntimeFolder created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Runtimeorg().GetRuntimeOrgByName(ctx, obj.GetName())
	if getErr == nil {
		obj.RuntimeOrg = updatedObj.RuntimeOrg
	}
	logger.Debugf("[AddFolders] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteFolders calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RuntimeorgRuntimeOrg) DeleteFolders(ctx context.Context, displayName string) (err error) {
	logger.Debugf("[ DeleteFolders] Received for RuntimeFolder object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("runtimefolders.runtimefolder.edge-orchestrator.intel.com", parentLabels, displayName)
	if IsChildExists("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", obj.Name, "runtimefolders.runtimefolder.edge-orchestrator.intel.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Runtimeorg.RuntimeOrg", "Folders", displayName)
	}

	err = obj.client.Runtimefolder().DeleteRuntimeFolderByName(ctx, childHashName)
	if err != nil {
		return err
	}
	logger.Debugf("[ DeleteFolders] RuntimeFolder object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Runtimeorg().GetRuntimeOrgByName(ctx, obj.GetName())
	if err == nil {
		obj.RuntimeOrg = updatedObj.RuntimeOrg
	}
	return
}

type RuntimeorgRuntimeOrgActiveWatchers struct {
	client         *Clientset
	ActiveWatchers []baseruntimeorgedgeorchestratorintelcomv1.Child
}

func (n *RuntimeorgRuntimeOrgActiveWatchers) Next(ctx context.Context) (*OrgactivewatcherOrgActiveWatcher, error) {
	for index, child := range n.ActiveWatchers {
		logger.Debugf("[RuntimeorgRuntimeOrgActiveWatchers Next] Get next ActiveWatchers with name %s", child.Name)
		obj, err := n.client.Orgactivewatcher().GetOrgActiveWatcherByName(ctx, child.Name)
		if err == nil {
			if index == len(n.ActiveWatchers)-1 {
				n.ActiveWatchers = nil
			} else {
				n.ActiveWatchers = n.ActiveWatchers[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllActiveWatchersIter returns an iterator for all children of given type
func (obj *RuntimeorgRuntimeOrg) GetAllActiveWatchersIter(ctx context.Context) (
	result RuntimeorgRuntimeOrgActiveWatchers) {
	result.client = obj.client
	for _, v := range GetChildren("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", obj.Name, "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com") {
		result.ActiveWatchers = append(result.ActiveWatchers, baseruntimeorgedgeorchestratorintelcomv1.Child{
			Group: "orgactivewatcher.edge-orchestrator.intel.com",
			Kind:  "OrgActiveWatcher",
			Name:  v,
		})
	}
	return
}

// GetAllActiveWatchers returns all children of a given type
func (obj *RuntimeorgRuntimeOrg) GetAllActiveWatchers(ctx context.Context) (
	result []*OrgactivewatcherOrgActiveWatcher, err error) {
	for _, v := range GetChildren("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", obj.Name, "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com") {
		logger.Debugf("[RuntimeorgRuntimeOrg GetAllActiveWatchers] Get next ActiveWatchers with name %s", v)
		l, err := obj.client.Orgactivewatcher().GetOrgActiveWatcherByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetActiveWatchers returns child which has given displayName
func (obj *RuntimeorgRuntimeOrg) GetActiveWatchers(ctx context.Context,
	displayName string) (result *OrgactivewatcherOrgActiveWatcher, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", parentLabels, displayName)
	logger.Debugf("[GetActiveWatchers] in RuntimeorgRuntimeOrg with name %s, displayName %s, parentLabels %#v", childHashName, displayName, parentLabels)
	if IsChildExists("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", obj.Name, "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", childHashName) == false {
		logger.Debugf("[GetActiveWatchers] ChildNotFound ActiveWatchers with name %s, displayName %s ", childHashName, displayName)
		return nil, NewChildNotFound(obj.DisplayName(), "Runtimeorg.RuntimeOrg", "ActiveWatchers", displayName)
	}

	logger.Debugf("[GetActiveWatchers] invoke GetOrgActiveWatcherByName name %s, displayName %s", childHashName, displayName)
	result, err = obj.client.Orgactivewatcher().GetOrgActiveWatcherByName(ctx, childHashName)
	return
}

// AddActiveWatchers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RuntimeorgRuntimeOrg) AddActiveWatchers(ctx context.Context,
	objToCreate *baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher) (result *OrgactivewatcherOrgActiveWatcher, err error) {
	logger.Debugf("[AddActiveWatchers] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Orgactivewatcher().CreateOrgActiveWatcherByName(ctx, objToCreate)
	logger.Debugf("[AddActiveWatchers] OrgActiveWatcher created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Runtimeorg().GetRuntimeOrgByName(ctx, obj.GetName())
	if getErr == nil {
		obj.RuntimeOrg = updatedObj.RuntimeOrg
	}
	logger.Debugf("[AddActiveWatchers] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteActiveWatchers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RuntimeorgRuntimeOrg) DeleteActiveWatchers(ctx context.Context, displayName string) (err error) {
	logger.Debugf("[ DeleteActiveWatchers] Received for OrgActiveWatcher object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", parentLabels, displayName)
	if IsChildExists("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", obj.Name, "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Runtimeorg.RuntimeOrg", "ActiveWatchers", displayName)
	}

	err = obj.client.Orgactivewatcher().DeleteOrgActiveWatcherByName(ctx, childHashName)
	if err != nil {
		return err
	}
	logger.Debugf("[ DeleteActiveWatchers] OrgActiveWatcher object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Runtimeorg().GetRuntimeOrgByName(ctx, obj.GetName())
	if err == nil {
		obj.RuntimeOrg = updatedObj.RuntimeOrg
	}
	return
}

type runtimeorgRuntimeorgEdgeV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *runtimeorgRuntimeorgEdgeV1Chainer) Subscribe() {
	key := "runtimeorgs.runtimeorg.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerruntimeorgedgeorchestratorintelcomv1.NewRuntimeOrgInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *runtimeorgRuntimeorgEdgeV1Chainer) Unsubscribe() {
	key := "runtimeorgs.runtimeorg.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *runtimeorgRuntimeorgEdgeV1Chainer) IsSubscribed() bool {
	key := "runtimeorgs.runtimeorg.edge-orchestrator.intel.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *runtimeorgRuntimeorgEdgeV1Chainer) addCallback(obj *RuntimeorgRuntimeOrg) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["runtimes.runtime.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("runtimes.runtime.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[addCallback] received for runtimeorgs.runtimeorg.edge-orchestrator.intel.com name %s displayName %s parent runtimes.runtime.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	AddChild("runtimes.runtime.edge-orchestrator.intel.com", parentHashName, "runtimeorgs.runtimeorg.edge-orchestrator.intel.com", obj.Name)
}

func (c *runtimeorgRuntimeorgEdgeV1Chainer) deleteCallback(obj *RuntimeorgRuntimeOrg) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["runtimes.runtime.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("runtimes.runtime.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[deleteCallback] received for runtimeorgs.runtimeorg.edge-orchestrator.intel.com name %s displayName %s parent runtimes.runtime.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	RemoveChild("runtimes.runtime.edge-orchestrator.intel.com", parentHashName, "runtimeorgs.runtimeorg.edge-orchestrator.intel.com", obj.Name)
}

func (c *runtimeorgRuntimeorgEdgeV1Chainer) RegisterEventHandler(addCB func(obj *RuntimeorgRuntimeOrg), updateCB func(oldObj, newObj *RuntimeorgRuntimeOrg), deleteCB func(obj *RuntimeorgRuntimeOrg)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for RuntimeorgRuntimeOrg")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "runtimeorgs.runtimeorg.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimeorgRuntimeOrg")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimeorgRuntimeOrg, so creating a new one")
		informer = informerruntimeorgedgeorchestratorintelcomv1.NewRuntimeOrgInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RuntimeorgRuntimeOrg{
				client:     c.client,
				RuntimeOrg: obj.(*baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg),
			}
			logger.Debugf("[RegisterEventHandler AddFunc] Got Add event for runtimeorgs.runtimeorg.edge-orchestrator.intel.com name %s", nc.RuntimeOrg.Name)

			var parent *RuntimeRuntime
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimes.runtime.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimes.runtime.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtime().ForceReadRuntimeByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("runtimes.runtime.edge-orchestrator.intel.com", parent.Name, "runtimeorgs.runtimeorg.edge-orchestrator.intel.com", nc.Name) {
				AddChild("runtimes.runtime.edge-orchestrator.intel.com", parent.Name, "runtimeorgs.runtimeorg.edge-orchestrator.intel.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RuntimeorgRuntimeOrg{
				client:     c.client,
				RuntimeOrg: oldObj.(*baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg),
			}
			newData := &RuntimeorgRuntimeOrg{
				client:     c.client,
				RuntimeOrg: newObj.(*baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg),
			}
			logger.Debugf("[RegisterEventHandler UpdateFunc] Got Update event for runtimeorgs.runtimeorg.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.RuntimeOrg.Name, oldData.ResourceVersion, newData.ResourceVersion)
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &RuntimeorgRuntimeOrg{
				client:     c.client,
				RuntimeOrg: obj.(*baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg),
			}
			logger.Debugf("[RegisterEventHandler DeleteFunc] Got Delete event for runtimeorgs.runtimeorg.edge-orchestrator.intel.com name %s", nc.RuntimeOrg.Name)

			var parent *RuntimeRuntime
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimes.runtime.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimes.runtime.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtime().ForceReadRuntimeByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("runtimes.runtime.edge-orchestrator.intel.com", parent.Name, "runtimeorgs.runtimeorg.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("runtimes.runtime.edge-orchestrator.intel.com", parent.Name, "runtimeorgs.runtimeorg.edge-orchestrator.intel.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *runtimeorgRuntimeorgEdgeV1Chainer) RegisterAddCallback(cbfn func(obj *RuntimeorgRuntimeOrg)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterAddCallback] Received for RuntimeorgRuntimeOrg")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "runtimeorgs.runtimeorg.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimeorgRuntimeOrg")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimeorgRuntimeOrg, so creating a new one")
		informer = informerruntimeorgedgeorchestratorintelcomv1.NewRuntimeOrgInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RuntimeorgRuntimeOrg{
				client:     c.client,
				RuntimeOrg: obj.(*baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg),
			}
			logger.Debugf("[RegisterAddCallback] Got Add event for runtimeorgs.runtimeorg.edge-orchestrator.intel.com name %s", nc.RuntimeOrg.Name)

			var parent *RuntimeRuntime
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimes.runtime.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimes.runtime.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtime().ForceReadRuntimeByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("runtimes.runtime.edge-orchestrator.intel.com", parent.Name, "runtimeorgs.runtimeorg.edge-orchestrator.intel.com", nc.Name) {
				AddChild("runtimes.runtime.edge-orchestrator.intel.com", parent.Name, "runtimeorgs.runtimeorg.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *runtimeorgRuntimeorgEdgeV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *RuntimeorgRuntimeOrg)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterUpdateCallback] Received for RuntimeorgRuntimeOrg")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "runtimeorgs.runtimeorg.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimeorgRuntimeOrg")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimeorgRuntimeOrg, so creating a new one")
		informer = informerruntimeorgedgeorchestratorintelcomv1.NewRuntimeOrgInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RuntimeorgRuntimeOrg{
				client:     c.client,
				RuntimeOrg: oldObj.(*baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg),
			}
			newData := &RuntimeorgRuntimeOrg{
				client:     c.client,
				RuntimeOrg: newObj.(*baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg),
			}
			logger.Debugf("[RegisterUpdateCallback] Got Update event for runtimeorgs.runtimeorg.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.RuntimeOrg.Name, oldData.ResourceVersion, newData.ResourceVersion)
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *runtimeorgRuntimeorgEdgeV1Chainer) RegisterDeleteCallback(cbfn func(obj *RuntimeorgRuntimeOrg)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterDeleteCallback] Received for RuntimeorgRuntimeOrg")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "runtimeorgs.runtimeorg.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimeorgRuntimeOrg")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimeorgRuntimeOrg, so creating a new one")
		informer = informerruntimeorgedgeorchestratorintelcomv1.NewRuntimeOrgInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &RuntimeorgRuntimeOrg{
				client:     c.client,
				RuntimeOrg: obj.(*baseruntimeorgedgeorchestratorintelcomv1.RuntimeOrg),
			}
			logger.Debugf("[RegisterDeleteCallback] Got Delete event for runtimeorgs.runtimeorg.edge-orchestrator.intel.com name %s", nc.RuntimeOrg.Name)

			var parent *RuntimeRuntime
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("runtimes.runtime.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimes.runtime.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtime().ForceReadRuntimeByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("runtimes.runtime.edge-orchestrator.intel.com", parent.Name, "runtimeorgs.runtimeorg.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("runtimes.runtime.edge-orchestrator.intel.com", parent.Name, "runtimeorgs.runtimeorg.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *runtimeorgRuntimeorgEdgeV1Chainer) Folders(name string) *runtimefolderRuntimefolderEdgeV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["runtimefolders.runtimefolder.edge-orchestrator.intel.com"] = name
	return &runtimefolderRuntimefolderEdgeV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetFolders calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *runtimeorgRuntimeorgEdgeV1Chainer) GetFolders(ctx context.Context, displayName string) (result *RuntimefolderRuntimeFolder, err error) {
	hashedName := helper.GetHashedName("runtimefolders.runtimefolder.edge-orchestrator.intel.com", c.parentLabels, displayName)
	logger.Debugf("[GetFolders] using chainer for name %s, displayName %s, labels %#v", hashedName, displayName, c.parentLabels)
	return c.client.Runtimefolder().GetRuntimeFolderByName(ctx, hashedName)
}

// AddFolders calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimeorgRuntimeorgEdgeV1Chainer) AddFolders(ctx context.Context,
	objToCreate *baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder) (result *RuntimefolderRuntimeFolder, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName("runtimefolders.runtimefolder.edge-orchestrator.intel.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Runtimefolder().CreateRuntimeFolderByName(ctx, objToCreate)
}

// DeleteFolders calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimeorgRuntimeorgEdgeV1Chainer) DeleteFolders(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IsNameHashedLabel] = "true"
	hashedName := helper.GetHashedName("runtimefolders.runtimefolder.edge-orchestrator.intel.com", c.parentLabels, name)
	return c.client.Runtimefolder().DeleteRuntimeFolderByName(ctx, hashedName)
}

func (c *runtimeorgRuntimeorgEdgeV1Chainer) ActiveWatchers(name string) *orgactivewatcherOrgactivewatcherEdgeV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com"] = name
	return &orgactivewatcherOrgactivewatcherEdgeV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetActiveWatchers calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *runtimeorgRuntimeorgEdgeV1Chainer) GetActiveWatchers(ctx context.Context, displayName string) (result *OrgactivewatcherOrgActiveWatcher, err error) {
	hashedName := helper.GetHashedName("orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", c.parentLabels, displayName)
	logger.Debugf("[GetActiveWatchers] using chainer for name %s, displayName %s, labels %#v", hashedName, displayName, c.parentLabels)
	return c.client.Orgactivewatcher().GetOrgActiveWatcherByName(ctx, hashedName)
}

// AddActiveWatchers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimeorgRuntimeorgEdgeV1Chainer) AddActiveWatchers(ctx context.Context,
	objToCreate *baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher) (result *OrgactivewatcherOrgActiveWatcher, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName("orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Orgactivewatcher().CreateOrgActiveWatcherByName(ctx, objToCreate)
}

// DeleteActiveWatchers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimeorgRuntimeorgEdgeV1Chainer) DeleteActiveWatchers(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IsNameHashedLabel] = "true"
	hashedName := helper.GetHashedName("orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", c.parentLabels, name)
	return c.client.Orgactivewatcher().DeleteOrgActiveWatcherByName(ctx, hashedName)
}

func (group *RuntimefolderEdgeV1) GetRuntimeFolderChildrenMap() map[string]baseruntimefolderedgeorchestratorintelcomv1.Child {
	return map[string]baseruntimefolderedgeorchestratorintelcomv1.Child{}
}

func (group *RuntimefolderEdgeV1) GetRuntimeFolderChild(grp, kind, name string) baseruntimefolderedgeorchestratorintelcomv1.Child {
	return baseruntimefolderedgeorchestratorintelcomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetRuntimeFolderByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RuntimefolderEdgeV1) GetRuntimeFolderByName(ctx context.Context, hashedName string) (*RuntimefolderRuntimeFolder, error) {
	key := "runtimefolders.runtimefolder.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			logger.Debugf("[GetRuntimeFolderByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				logger.Fatalf("[GetRuntimeFolderByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder).ResourceVersion)
				if writeCacheVersionErr != nil {
					logger.Fatalf("[GetRuntimeFolderByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &RuntimefolderRuntimeFolder{
					client:        group.client,
					RuntimeFolder: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &RuntimefolderRuntimeFolder{
				client:        group.client,
				RuntimeFolder: resWrCache.(*baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RuntimefolderEdgeV1().
			RuntimeFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &RuntimefolderRuntimeFolder{
				client:        group.client,
				RuntimeFolder: result,
			}, nil
		} else if errors.IsNotFound(err) {
			logger.Debugf("[GetRuntimeFolderByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on Get RuntimeFolders: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[GetRuntimeFolderByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[GetRuntimeFolderByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadRuntimeFolderByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RuntimefolderEdgeV1) ForceReadRuntimeFolderByName(ctx context.Context, hashedName string) (*RuntimefolderRuntimeFolder, error) {
	logger.Debugf("[ForceReadRuntimeFolderByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RuntimefolderEdgeV1().
			RuntimeFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[ForceReadRuntimeFolderByName] Failed to Get RuntimeFolders: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max Retry exceed on Get RuntimeFolders: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[ForceReadRuntimeFolderByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[ForceReadRuntimeFolderByName]: %+v", err)
				return nil, err
			}
		} else {
			logger.Debugf("[ForceReadRuntimeFolderByName] Executed Successfully :%s", hashedName)
			return &RuntimefolderRuntimeFolder{
				client:        group.client,
				RuntimeFolder: result,
			}, nil
		}
	}
}

// DeleteRuntimeFolderByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RuntimefolderEdgeV1) DeleteRuntimeFolderByName(ctx context.Context, hashedName string) (err error) {
	logger.Debugf("[DeleteRuntimeFolderByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RuntimefolderEdgeV1().
			RuntimeFolders().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[DeleteRuntimeFolderByName] Failed to get RuntimeFolders: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on get RuntimeFolders: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteRuntimeFolderByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteRuntimeFolderByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteRuntimeFolderByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("runtimefolders.runtimefolder.edge-orchestrator.intel.com", hashedName, "runtimeprojects.runtimeproject.edge-orchestrator.intel.com") {
		err := group.client.Runtimeproject().DeleteRuntimeProjectByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("runtimefolders.runtimefolder.edge-orchestrator.intel.com", hashedName, "runtimeprojects.runtimeproject.edge-orchestrator.intel.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			RuntimefolderEdgeV1().
			RuntimeFolders().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			logger.Errorf("[DeleteRuntimeFolderByName] failed to delete RuntimeFolders: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on delete RuntimeFolders: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteRuntimeFolderByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteRuntimeFolderByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteRuntimeFolderByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("runtimefolders.runtimefolder.edge-orchestrator.intel.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	logger.Debugf("[DeleteRuntimeFolderByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	if result.GetLabels() != nil {
		if parents[common.IsNameHashedLabel] == "true" {
			parentName = helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parents, parentName)
	}
	RemoveChild("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parentName, "runtimefolders.runtimefolder.edge-orchestrator.intel.com", hashedName)

	return nil
}

// CreateRuntimeFolderByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RuntimefolderEdgeV1) CreateRuntimeFolderByName(ctx context.Context,
	objToCreate *baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder) (*RuntimefolderRuntimeFolder, error) {
	logger.Debugf("[CreateRuntimeFolderByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DisplayNameLabel]; !ok {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
	}

	objToCreate.Spec.ProjectsGvk = nil

	var (
		retryCount int
		result     *baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RuntimefolderEdgeV1().
			RuntimeFolders().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			logger.Errorf("[CreateRuntimeFolderByName] Failed to create RuntimeFolder: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on create RuntimeFolder: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[CreateRuntimeFolderByName] context canceled while creating RuntimeFolder: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				logger.Debugf("[CreateRuntimeFolderByName] RuntimeFolder: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.RuntimefolderEdgeV1().RuntimeFolders().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					logger.Fatalf("[CreateRuntimeFolderByName] Unable to Get RuntimeFolder %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				logger.Errorf("[CreateRuntimeFolderByName] found unexpected error while creating RuntimeFolder: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			logger.Debugf("[CreateRuntimeFolderByName] RuntimeFolder: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("runtimefolders.runtimefolder.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[CreateRuntimeFolderByName] RuntimeFolder: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	parentHashedName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", objToCreate.GetLabels(), parentName)

	AddChild("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parentHashedName, "runtimefolders.runtimefolder.edge-orchestrator.intel.com", objToCreate.Name)

	logger.Debugf("[CreateRuntimeFolderByName] Executed Successfully: %s", objToCreate.GetName())
	return &RuntimefolderRuntimeFolder{
		client:        group.client,
		RuntimeFolder: result,
	}, nil
}

// UpdateRuntimeFolderByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RuntimefolderEdgeV1) UpdateRuntimeFolderByName(ctx context.Context,
	objToUpdate *baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder) (*RuntimefolderRuntimeFolder, error) {
	logger.Debugf("[UpdateRuntimeFolderByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Runtimefolder().GetRuntimeFolderByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["runtimefolders.runtimefolder.edge-orchestrator.intel.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IsNameHashedLabel] = current.Labels[common.IsNameHashedLabel]
			objToUpdate.Labels[common.DisplayNameLabel] = current.Labels[common.DisplayNameLabel]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			RuntimefolderEdgeV1().
			RuntimeFolders().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			logger.Errorf("[UpdateRuntimeFolderByName] Failed to patch RuntimeFolder %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					logger.Debugf("Trigger RuntimeFolder Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteRuntimeFolderByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						logger.Debugf("Error occur while deleting RuntimeFolder: %s", objToUpdate.GetName())
						return nil, delErr
					}
					logger.Debugf("RuntimeFolder deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[UpdateRuntimeFolderByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				logger.Errorf("[UpdateRuntimeFolderByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				logger.Debugf("Trigger RuntimeFolder Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteRuntimeFolderByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					logger.Debugf("Error occur while deleting RuntimeFolder: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				logger.Debugf("RuntimeFolder Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			logger.Debugf("[UpdateRuntimeFolderByName] Patch RuntimeFolder Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("runtimefolders.runtimefolder.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[UpdateRuntimeFolderByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	logger.Debugf("[UpdateRuntimeFolderByName] Executed Successfully %s", objToUpdate.GetName())
	return &RuntimefolderRuntimeFolder{
		client:        group.client,
		RuntimeFolder: result,
	}, nil
}

// ListRuntimeFolders returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RuntimefolderEdgeV1) ListRuntimeFolders(ctx context.Context,
	opts metav1.ListOptions) (result []*RuntimefolderRuntimeFolder, err error) {
	key := "runtimefolders.runtimefolder.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*RuntimefolderRuntimeFolder, len(items))
		for k, v := range items {
			item, _ := v.(*baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder)
			result[k] = &RuntimefolderRuntimeFolder{
				client:        group.client,
				RuntimeFolder: item,
			}
		}
	} else {
		list, err := group.client.baseClient.RuntimefolderEdgeV1().
			RuntimeFolders().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*RuntimefolderRuntimeFolder, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &RuntimefolderRuntimeFolder{
				client:        group.client,
				RuntimeFolder: &item,
			}
		}
	}
	return
}

type RuntimefolderRuntimeFolder struct {
	client *Clientset
	*baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder
}

// Delete removes obj and all it's children from the database.
func (obj *RuntimefolderRuntimeFolder) Delete(ctx context.Context) error {
	err := obj.client.Runtimefolder().DeleteRuntimeFolderByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.RuntimeFolder = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RuntimefolderRuntimeFolder) Update(ctx context.Context) error {
	result, err := obj.client.Runtimefolder().UpdateRuntimeFolderByName(ctx, obj.RuntimeFolder)
	if err != nil {
		return err
	}
	obj.RuntimeFolder = result.RuntimeFolder
	return nil
}

func (obj *RuntimefolderRuntimeFolder) GetParent(ctx context.Context) (result *RuntimeorgRuntimeOrg, err error) {
	hashedName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", obj.Labels, obj.Labels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"])
	logger.Debugf("[GetParent] Get parent of RuntimefolderRuntimeFolder name %s [labels %#v] of parent type runtimeorgs.runtimeorg.edge-orchestrator.intel.com and name %s", obj.Name, obj.Labels, hashedName)
	return obj.client.Runtimeorg().GetRuntimeOrgByName(ctx, hashedName)
}

type RuntimefolderRuntimeFolderProjects struct {
	client   *Clientset
	Projects []baseruntimefolderedgeorchestratorintelcomv1.Child
}

func (n *RuntimefolderRuntimeFolderProjects) Next(ctx context.Context) (*RuntimeprojectRuntimeProject, error) {
	for index, child := range n.Projects {
		logger.Debugf("[RuntimefolderRuntimeFolderProjects Next] Get next Projects with name %s", child.Name)
		obj, err := n.client.Runtimeproject().GetRuntimeProjectByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Projects)-1 {
				n.Projects = nil
			} else {
				n.Projects = n.Projects[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllProjectsIter returns an iterator for all children of given type
func (obj *RuntimefolderRuntimeFolder) GetAllProjectsIter(ctx context.Context) (
	result RuntimefolderRuntimeFolderProjects) {
	result.client = obj.client
	for _, v := range GetChildren("runtimefolders.runtimefolder.edge-orchestrator.intel.com", obj.Name, "runtimeprojects.runtimeproject.edge-orchestrator.intel.com") {
		result.Projects = append(result.Projects, baseruntimefolderedgeorchestratorintelcomv1.Child{
			Group: "runtimeproject.edge-orchestrator.intel.com",
			Kind:  "RuntimeProject",
			Name:  v,
		})
	}
	return
}

// GetAllProjects returns all children of a given type
func (obj *RuntimefolderRuntimeFolder) GetAllProjects(ctx context.Context) (
	result []*RuntimeprojectRuntimeProject, err error) {
	for _, v := range GetChildren("runtimefolders.runtimefolder.edge-orchestrator.intel.com", obj.Name, "runtimeprojects.runtimeproject.edge-orchestrator.intel.com") {
		logger.Debugf("[RuntimefolderRuntimeFolder GetAllProjects] Get next Projects with name %s", v)
		l, err := obj.client.Runtimeproject().GetRuntimeProjectByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetProjects returns child which has given displayName
func (obj *RuntimefolderRuntimeFolder) GetProjects(ctx context.Context,
	displayName string) (result *RuntimeprojectRuntimeProject, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["runtimefolders.runtimefolder.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", parentLabels, displayName)
	logger.Debugf("[GetProjects] in RuntimefolderRuntimeFolder with name %s, displayName %s, parentLabels %#v", childHashName, displayName, parentLabels)
	if IsChildExists("runtimefolders.runtimefolder.edge-orchestrator.intel.com", obj.Name, "runtimeprojects.runtimeproject.edge-orchestrator.intel.com", childHashName) == false {
		logger.Debugf("[GetProjects] ChildNotFound Projects with name %s, displayName %s ", childHashName, displayName)
		return nil, NewChildNotFound(obj.DisplayName(), "Runtimefolder.RuntimeFolder", "Projects", displayName)
	}

	logger.Debugf("[GetProjects] invoke GetRuntimeProjectByName name %s, displayName %s", childHashName, displayName)
	result, err = obj.client.Runtimeproject().GetRuntimeProjectByName(ctx, childHashName)
	return
}

// AddProjects calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RuntimefolderRuntimeFolder) AddProjects(ctx context.Context,
	objToCreate *baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject) (result *RuntimeprojectRuntimeProject, err error) {
	logger.Debugf("[AddProjects] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimefolders.runtimefolder.edge-orchestrator.intel.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimefolders.runtimefolder.edge-orchestrator.intel.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Runtimeproject().CreateRuntimeProjectByName(ctx, objToCreate)
	logger.Debugf("[AddProjects] RuntimeProject created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Runtimefolder().GetRuntimeFolderByName(ctx, obj.GetName())
	if getErr == nil {
		obj.RuntimeFolder = updatedObj.RuntimeFolder
	}
	logger.Debugf("[AddProjects] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteProjects calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RuntimefolderRuntimeFolder) DeleteProjects(ctx context.Context, displayName string) (err error) {
	logger.Debugf("[ DeleteProjects] Received for RuntimeProject object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["runtimefolders.runtimefolder.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", parentLabels, displayName)
	if IsChildExists("runtimefolders.runtimefolder.edge-orchestrator.intel.com", obj.Name, "runtimeprojects.runtimeproject.edge-orchestrator.intel.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Runtimefolder.RuntimeFolder", "Projects", displayName)
	}

	err = obj.client.Runtimeproject().DeleteRuntimeProjectByName(ctx, childHashName)
	if err != nil {
		return err
	}
	logger.Debugf("[ DeleteProjects] RuntimeProject object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Runtimefolder().GetRuntimeFolderByName(ctx, obj.GetName())
	if err == nil {
		obj.RuntimeFolder = updatedObj.RuntimeFolder
	}
	return
}

type runtimefolderRuntimefolderEdgeV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *runtimefolderRuntimefolderEdgeV1Chainer) Subscribe() {
	key := "runtimefolders.runtimefolder.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerruntimefolderedgeorchestratorintelcomv1.NewRuntimeFolderInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *runtimefolderRuntimefolderEdgeV1Chainer) Unsubscribe() {
	key := "runtimefolders.runtimefolder.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *runtimefolderRuntimefolderEdgeV1Chainer) IsSubscribed() bool {
	key := "runtimefolders.runtimefolder.edge-orchestrator.intel.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *runtimefolderRuntimefolderEdgeV1Chainer) addCallback(obj *RuntimefolderRuntimeFolder) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[addCallback] received for runtimefolders.runtimefolder.edge-orchestrator.intel.com name %s displayName %s parent runtimeorgs.runtimeorg.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	AddChild("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parentHashName, "runtimefolders.runtimefolder.edge-orchestrator.intel.com", obj.Name)
}

func (c *runtimefolderRuntimefolderEdgeV1Chainer) deleteCallback(obj *RuntimefolderRuntimeFolder) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[deleteCallback] received for runtimefolders.runtimefolder.edge-orchestrator.intel.com name %s displayName %s parent runtimeorgs.runtimeorg.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	RemoveChild("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parentHashName, "runtimefolders.runtimefolder.edge-orchestrator.intel.com", obj.Name)
}

func (c *runtimefolderRuntimefolderEdgeV1Chainer) RegisterEventHandler(addCB func(obj *RuntimefolderRuntimeFolder), updateCB func(oldObj, newObj *RuntimefolderRuntimeFolder), deleteCB func(obj *RuntimefolderRuntimeFolder)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for RuntimefolderRuntimeFolder")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "runtimefolders.runtimefolder.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimefolderRuntimeFolder")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimefolderRuntimeFolder, so creating a new one")
		informer = informerruntimefolderedgeorchestratorintelcomv1.NewRuntimeFolderInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RuntimefolderRuntimeFolder{
				client:        c.client,
				RuntimeFolder: obj.(*baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder),
			}
			logger.Debugf("[RegisterEventHandler AddFunc] Got Add event for runtimefolders.runtimefolder.edge-orchestrator.intel.com name %s", nc.RuntimeFolder.Name)

			var parent *RuntimeorgRuntimeOrg
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtimeorg().ForceReadRuntimeOrgByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parent.Name, "runtimefolders.runtimefolder.edge-orchestrator.intel.com", nc.Name) {
				AddChild("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parent.Name, "runtimefolders.runtimefolder.edge-orchestrator.intel.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RuntimefolderRuntimeFolder{
				client:        c.client,
				RuntimeFolder: oldObj.(*baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder),
			}
			newData := &RuntimefolderRuntimeFolder{
				client:        c.client,
				RuntimeFolder: newObj.(*baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder),
			}
			logger.Debugf("[RegisterEventHandler UpdateFunc] Got Update event for runtimefolders.runtimefolder.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.RuntimeFolder.Name, oldData.ResourceVersion, newData.ResourceVersion)
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &RuntimefolderRuntimeFolder{
				client:        c.client,
				RuntimeFolder: obj.(*baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder),
			}
			logger.Debugf("[RegisterEventHandler DeleteFunc] Got Delete event for runtimefolders.runtimefolder.edge-orchestrator.intel.com name %s", nc.RuntimeFolder.Name)

			var parent *RuntimeorgRuntimeOrg
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtimeorg().ForceReadRuntimeOrgByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parent.Name, "runtimefolders.runtimefolder.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parent.Name, "runtimefolders.runtimefolder.edge-orchestrator.intel.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *runtimefolderRuntimefolderEdgeV1Chainer) RegisterAddCallback(cbfn func(obj *RuntimefolderRuntimeFolder)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterAddCallback] Received for RuntimefolderRuntimeFolder")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "runtimefolders.runtimefolder.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimefolderRuntimeFolder")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimefolderRuntimeFolder, so creating a new one")
		informer = informerruntimefolderedgeorchestratorintelcomv1.NewRuntimeFolderInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RuntimefolderRuntimeFolder{
				client:        c.client,
				RuntimeFolder: obj.(*baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder),
			}
			logger.Debugf("[RegisterAddCallback] Got Add event for runtimefolders.runtimefolder.edge-orchestrator.intel.com name %s", nc.RuntimeFolder.Name)

			var parent *RuntimeorgRuntimeOrg
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtimeorg().ForceReadRuntimeOrgByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parent.Name, "runtimefolders.runtimefolder.edge-orchestrator.intel.com", nc.Name) {
				AddChild("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parent.Name, "runtimefolders.runtimefolder.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *runtimefolderRuntimefolderEdgeV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *RuntimefolderRuntimeFolder)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterUpdateCallback] Received for RuntimefolderRuntimeFolder")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "runtimefolders.runtimefolder.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimefolderRuntimeFolder")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimefolderRuntimeFolder, so creating a new one")
		informer = informerruntimefolderedgeorchestratorintelcomv1.NewRuntimeFolderInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RuntimefolderRuntimeFolder{
				client:        c.client,
				RuntimeFolder: oldObj.(*baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder),
			}
			newData := &RuntimefolderRuntimeFolder{
				client:        c.client,
				RuntimeFolder: newObj.(*baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder),
			}
			logger.Debugf("[RegisterUpdateCallback] Got Update event for runtimefolders.runtimefolder.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.RuntimeFolder.Name, oldData.ResourceVersion, newData.ResourceVersion)
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *runtimefolderRuntimefolderEdgeV1Chainer) RegisterDeleteCallback(cbfn func(obj *RuntimefolderRuntimeFolder)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterDeleteCallback] Received for RuntimefolderRuntimeFolder")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "runtimefolders.runtimefolder.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimefolderRuntimeFolder")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimefolderRuntimeFolder, so creating a new one")
		informer = informerruntimefolderedgeorchestratorintelcomv1.NewRuntimeFolderInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &RuntimefolderRuntimeFolder{
				client:        c.client,
				RuntimeFolder: obj.(*baseruntimefolderedgeorchestratorintelcomv1.RuntimeFolder),
			}
			logger.Debugf("[RegisterDeleteCallback] Got Delete event for runtimefolders.runtimefolder.edge-orchestrator.intel.com name %s", nc.RuntimeFolder.Name)

			var parent *RuntimeorgRuntimeOrg
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtimeorg().ForceReadRuntimeOrgByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parent.Name, "runtimefolders.runtimefolder.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parent.Name, "runtimefolders.runtimefolder.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *runtimefolderRuntimefolderEdgeV1Chainer) Projects(name string) *runtimeprojectRuntimeprojectEdgeV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["runtimeprojects.runtimeproject.edge-orchestrator.intel.com"] = name
	return &runtimeprojectRuntimeprojectEdgeV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetProjects calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *runtimefolderRuntimefolderEdgeV1Chainer) GetProjects(ctx context.Context, displayName string) (result *RuntimeprojectRuntimeProject, err error) {
	hashedName := helper.GetHashedName("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", c.parentLabels, displayName)
	logger.Debugf("[GetProjects] using chainer for name %s, displayName %s, labels %#v", hashedName, displayName, c.parentLabels)
	return c.client.Runtimeproject().GetRuntimeProjectByName(ctx, hashedName)
}

// AddProjects calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimefolderRuntimefolderEdgeV1Chainer) AddProjects(ctx context.Context,
	objToCreate *baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject) (result *RuntimeprojectRuntimeProject, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Runtimeproject().CreateRuntimeProjectByName(ctx, objToCreate)
}

// DeleteProjects calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimefolderRuntimefolderEdgeV1Chainer) DeleteProjects(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IsNameHashedLabel] = "true"
	hashedName := helper.GetHashedName("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", c.parentLabels, name)
	return c.client.Runtimeproject().DeleteRuntimeProjectByName(ctx, hashedName)
}

func (group *RuntimeprojectEdgeV1) GetRuntimeProjectChildrenMap() map[string]baseruntimeprojectedgeorchestratorintelcomv1.Child {
	return map[string]baseruntimeprojectedgeorchestratorintelcomv1.Child{}
}

func (group *RuntimeprojectEdgeV1) GetRuntimeProjectChild(grp, kind, name string) baseruntimeprojectedgeorchestratorintelcomv1.Child {
	return baseruntimeprojectedgeorchestratorintelcomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetRuntimeProjectByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RuntimeprojectEdgeV1) GetRuntimeProjectByName(ctx context.Context, hashedName string) (*RuntimeprojectRuntimeProject, error) {
	key := "runtimeprojects.runtimeproject.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			logger.Debugf("[GetRuntimeProjectByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				logger.Fatalf("[GetRuntimeProjectByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject).ResourceVersion)
				if writeCacheVersionErr != nil {
					logger.Fatalf("[GetRuntimeProjectByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &RuntimeprojectRuntimeProject{
					client:         group.client,
					RuntimeProject: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &RuntimeprojectRuntimeProject{
				client:         group.client,
				RuntimeProject: resWrCache.(*baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RuntimeprojectEdgeV1().
			RuntimeProjects().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &RuntimeprojectRuntimeProject{
				client:         group.client,
				RuntimeProject: result,
			}, nil
		} else if errors.IsNotFound(err) {
			logger.Debugf("[GetRuntimeProjectByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on Get RuntimeProjects: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[GetRuntimeProjectByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[GetRuntimeProjectByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadRuntimeProjectByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RuntimeprojectEdgeV1) ForceReadRuntimeProjectByName(ctx context.Context, hashedName string) (*RuntimeprojectRuntimeProject, error) {
	logger.Debugf("[ForceReadRuntimeProjectByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RuntimeprojectEdgeV1().
			RuntimeProjects().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[ForceReadRuntimeProjectByName] Failed to Get RuntimeProjects: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max Retry exceed on Get RuntimeProjects: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[ForceReadRuntimeProjectByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[ForceReadRuntimeProjectByName]: %+v", err)
				return nil, err
			}
		} else {
			logger.Debugf("[ForceReadRuntimeProjectByName] Executed Successfully :%s", hashedName)
			return &RuntimeprojectRuntimeProject{
				client:         group.client,
				RuntimeProject: result,
			}, nil
		}
	}
}

// DeleteRuntimeProjectByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RuntimeprojectEdgeV1) DeleteRuntimeProjectByName(ctx context.Context, hashedName string) (err error) {
	logger.Debugf("[DeleteRuntimeProjectByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RuntimeprojectEdgeV1().
			RuntimeProjects().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[DeleteRuntimeProjectByName] Failed to get RuntimeProjects: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on get RuntimeProjects: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteRuntimeProjectByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteRuntimeProjectByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteRuntimeProjectByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", hashedName, "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com") {
		err := group.client.Projectactivewatcher().DeleteProjectActiveWatcherByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", hashedName, "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			RuntimeprojectEdgeV1().
			RuntimeProjects().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			logger.Errorf("[DeleteRuntimeProjectByName] failed to delete RuntimeProjects: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on delete RuntimeProjects: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteRuntimeProjectByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteRuntimeProjectByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteRuntimeProjectByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("runtimeprojects.runtimeproject.edge-orchestrator.intel.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	logger.Debugf("[DeleteRuntimeProjectByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimefolders.runtimefolder.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	if result.GetLabels() != nil {
		if parents[common.IsNameHashedLabel] == "true" {
			parentName = helper.GetHashedName("runtimefolders.runtimefolder.edge-orchestrator.intel.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("runtimefolders.runtimefolder.edge-orchestrator.intel.com", parents, parentName)
	}
	RemoveChild("runtimefolders.runtimefolder.edge-orchestrator.intel.com", parentName, "runtimeprojects.runtimeproject.edge-orchestrator.intel.com", hashedName)

	return nil
}

// CreateRuntimeProjectByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RuntimeprojectEdgeV1) CreateRuntimeProjectByName(ctx context.Context,
	objToCreate *baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject) (*RuntimeprojectRuntimeProject, error) {
	logger.Debugf("[CreateRuntimeProjectByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DisplayNameLabel]; !ok {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
	}

	objToCreate.Spec.ActiveWatchersGvk = nil

	var (
		retryCount int
		result     *baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RuntimeprojectEdgeV1().
			RuntimeProjects().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			logger.Errorf("[CreateRuntimeProjectByName] Failed to create RuntimeProject: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on create RuntimeProject: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[CreateRuntimeProjectByName] context canceled while creating RuntimeProject: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				logger.Debugf("[CreateRuntimeProjectByName] RuntimeProject: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.RuntimeprojectEdgeV1().RuntimeProjects().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					logger.Fatalf("[CreateRuntimeProjectByName] Unable to Get RuntimeProject %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				logger.Errorf("[CreateRuntimeProjectByName] found unexpected error while creating RuntimeProject: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			logger.Debugf("[CreateRuntimeProjectByName] RuntimeProject: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("runtimeprojects.runtimeproject.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[CreateRuntimeProjectByName] RuntimeProject: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["runtimefolders.runtimefolder.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	parentHashedName := helper.GetHashedName("runtimefolders.runtimefolder.edge-orchestrator.intel.com", objToCreate.GetLabels(), parentName)

	AddChild("runtimefolders.runtimefolder.edge-orchestrator.intel.com", parentHashedName, "runtimeprojects.runtimeproject.edge-orchestrator.intel.com", objToCreate.Name)

	logger.Debugf("[CreateRuntimeProjectByName] Executed Successfully: %s", objToCreate.GetName())
	return &RuntimeprojectRuntimeProject{
		client:         group.client,
		RuntimeProject: result,
	}, nil
}

// UpdateRuntimeProjectByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RuntimeprojectEdgeV1) UpdateRuntimeProjectByName(ctx context.Context,
	objToUpdate *baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject) (*RuntimeprojectRuntimeProject, error) {
	logger.Debugf("[UpdateRuntimeProjectByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Runtimeproject().GetRuntimeProjectByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["runtimeprojects.runtimeproject.edge-orchestrator.intel.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IsNameHashedLabel] = current.Labels[common.IsNameHashedLabel]
			objToUpdate.Labels[common.DisplayNameLabel] = current.Labels[common.DisplayNameLabel]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Deleted)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Deleted).IsNil() {
			patchValueDeleted := objToUpdate.Spec.Deleted
			patchOpDeleted := PatchOp{
				Op:    "replace",
				Path:  "/spec/deleted",
				Value: patchValueDeleted,
			}
			patch = append(patch, patchOpDeleted)
		}
	} else {
		patchValueDeleted := objToUpdate.Spec.Deleted
		patchOpDeleted := PatchOp{
			Op:    "replace",
			Path:  "/spec/deleted",
			Value: patchValueDeleted,
		}
		patch = append(patch, patchOpDeleted)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			RuntimeprojectEdgeV1().
			RuntimeProjects().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			logger.Errorf("[UpdateRuntimeProjectByName] Failed to patch RuntimeProject %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					logger.Debugf("Trigger RuntimeProject Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteRuntimeProjectByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						logger.Debugf("Error occur while deleting RuntimeProject: %s", objToUpdate.GetName())
						return nil, delErr
					}
					logger.Debugf("RuntimeProject deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[UpdateRuntimeProjectByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				logger.Errorf("[UpdateRuntimeProjectByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				logger.Debugf("Trigger RuntimeProject Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteRuntimeProjectByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					logger.Debugf("Error occur while deleting RuntimeProject: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				logger.Debugf("RuntimeProject Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			logger.Debugf("[UpdateRuntimeProjectByName] Patch RuntimeProject Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("runtimeprojects.runtimeproject.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[UpdateRuntimeProjectByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	logger.Debugf("[UpdateRuntimeProjectByName] Executed Successfully %s", objToUpdate.GetName())
	return &RuntimeprojectRuntimeProject{
		client:         group.client,
		RuntimeProject: result,
	}, nil
}

// ListRuntimeProjects returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RuntimeprojectEdgeV1) ListRuntimeProjects(ctx context.Context,
	opts metav1.ListOptions) (result []*RuntimeprojectRuntimeProject, err error) {
	key := "runtimeprojects.runtimeproject.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*RuntimeprojectRuntimeProject, len(items))
		for k, v := range items {
			item, _ := v.(*baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject)
			result[k] = &RuntimeprojectRuntimeProject{
				client:         group.client,
				RuntimeProject: item,
			}
		}
	} else {
		list, err := group.client.baseClient.RuntimeprojectEdgeV1().
			RuntimeProjects().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*RuntimeprojectRuntimeProject, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &RuntimeprojectRuntimeProject{
				client:         group.client,
				RuntimeProject: &item,
			}
		}
	}
	return
}

type RuntimeprojectRuntimeProject struct {
	client *Clientset
	*baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject
}

// Delete removes obj and all it's children from the database.
func (obj *RuntimeprojectRuntimeProject) Delete(ctx context.Context) error {
	err := obj.client.Runtimeproject().DeleteRuntimeProjectByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.RuntimeProject = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RuntimeprojectRuntimeProject) Update(ctx context.Context) error {
	result, err := obj.client.Runtimeproject().UpdateRuntimeProjectByName(ctx, obj.RuntimeProject)
	if err != nil {
		return err
	}
	obj.RuntimeProject = result.RuntimeProject
	return nil
}

func (obj *RuntimeprojectRuntimeProject) GetParent(ctx context.Context) (result *RuntimefolderRuntimeFolder, err error) {
	hashedName := helper.GetHashedName("runtimefolders.runtimefolder.edge-orchestrator.intel.com", obj.Labels, obj.Labels["runtimefolders.runtimefolder.edge-orchestrator.intel.com"])
	logger.Debugf("[GetParent] Get parent of RuntimeprojectRuntimeProject name %s [labels %#v] of parent type runtimefolders.runtimefolder.edge-orchestrator.intel.com and name %s", obj.Name, obj.Labels, hashedName)
	return obj.client.Runtimefolder().GetRuntimeFolderByName(ctx, hashedName)
}

type RuntimeprojectRuntimeProjectActiveWatchers struct {
	client         *Clientset
	ActiveWatchers []baseruntimeprojectedgeorchestratorintelcomv1.Child
}

func (n *RuntimeprojectRuntimeProjectActiveWatchers) Next(ctx context.Context) (*ProjectactivewatcherProjectActiveWatcher, error) {
	for index, child := range n.ActiveWatchers {
		logger.Debugf("[RuntimeprojectRuntimeProjectActiveWatchers Next] Get next ActiveWatchers with name %s", child.Name)
		obj, err := n.client.Projectactivewatcher().GetProjectActiveWatcherByName(ctx, child.Name)
		if err == nil {
			if index == len(n.ActiveWatchers)-1 {
				n.ActiveWatchers = nil
			} else {
				n.ActiveWatchers = n.ActiveWatchers[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllActiveWatchersIter returns an iterator for all children of given type
func (obj *RuntimeprojectRuntimeProject) GetAllActiveWatchersIter(ctx context.Context) (
	result RuntimeprojectRuntimeProjectActiveWatchers) {
	result.client = obj.client
	for _, v := range GetChildren("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", obj.Name, "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com") {
		result.ActiveWatchers = append(result.ActiveWatchers, baseruntimeprojectedgeorchestratorintelcomv1.Child{
			Group: "projectactivewatcher.edge-orchestrator.intel.com",
			Kind:  "ProjectActiveWatcher",
			Name:  v,
		})
	}
	return
}

// GetAllActiveWatchers returns all children of a given type
func (obj *RuntimeprojectRuntimeProject) GetAllActiveWatchers(ctx context.Context) (
	result []*ProjectactivewatcherProjectActiveWatcher, err error) {
	for _, v := range GetChildren("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", obj.Name, "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com") {
		logger.Debugf("[RuntimeprojectRuntimeProject GetAllActiveWatchers] Get next ActiveWatchers with name %s", v)
		l, err := obj.client.Projectactivewatcher().GetProjectActiveWatcherByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetActiveWatchers returns child which has given displayName
func (obj *RuntimeprojectRuntimeProject) GetActiveWatchers(ctx context.Context,
	displayName string) (result *ProjectactivewatcherProjectActiveWatcher, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["runtimeprojects.runtimeproject.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", parentLabels, displayName)
	logger.Debugf("[GetActiveWatchers] in RuntimeprojectRuntimeProject with name %s, displayName %s, parentLabels %#v", childHashName, displayName, parentLabels)
	if IsChildExists("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", obj.Name, "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", childHashName) == false {
		logger.Debugf("[GetActiveWatchers] ChildNotFound ActiveWatchers with name %s, displayName %s ", childHashName, displayName)
		return nil, NewChildNotFound(obj.DisplayName(), "Runtimeproject.RuntimeProject", "ActiveWatchers", displayName)
	}

	logger.Debugf("[GetActiveWatchers] invoke GetProjectActiveWatcherByName name %s, displayName %s", childHashName, displayName)
	result, err = obj.client.Projectactivewatcher().GetProjectActiveWatcherByName(ctx, childHashName)
	return
}

// AddActiveWatchers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RuntimeprojectRuntimeProject) AddActiveWatchers(ctx context.Context,
	objToCreate *baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher) (result *ProjectactivewatcherProjectActiveWatcher, err error) {
	logger.Debugf("[AddActiveWatchers] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimeprojects.runtimeproject.edge-orchestrator.intel.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimeprojects.runtimeproject.edge-orchestrator.intel.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Projectactivewatcher().CreateProjectActiveWatcherByName(ctx, objToCreate)
	logger.Debugf("[AddActiveWatchers] ProjectActiveWatcher created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Runtimeproject().GetRuntimeProjectByName(ctx, obj.GetName())
	if getErr == nil {
		obj.RuntimeProject = updatedObj.RuntimeProject
	}
	logger.Debugf("[AddActiveWatchers] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteActiveWatchers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RuntimeprojectRuntimeProject) DeleteActiveWatchers(ctx context.Context, displayName string) (err error) {
	logger.Debugf("[ DeleteActiveWatchers] Received for ProjectActiveWatcher object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["runtimeprojects.runtimeproject.edge-orchestrator.intel.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", parentLabels, displayName)
	if IsChildExists("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", obj.Name, "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Runtimeproject.RuntimeProject", "ActiveWatchers", displayName)
	}

	err = obj.client.Projectactivewatcher().DeleteProjectActiveWatcherByName(ctx, childHashName)
	if err != nil {
		return err
	}
	logger.Debugf("[ DeleteActiveWatchers] ProjectActiveWatcher object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Runtimeproject().GetRuntimeProjectByName(ctx, obj.GetName())
	if err == nil {
		obj.RuntimeProject = updatedObj.RuntimeProject
	}
	return
}

type runtimeprojectRuntimeprojectEdgeV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *runtimeprojectRuntimeprojectEdgeV1Chainer) Subscribe() {
	key := "runtimeprojects.runtimeproject.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerruntimeprojectedgeorchestratorintelcomv1.NewRuntimeProjectInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *runtimeprojectRuntimeprojectEdgeV1Chainer) Unsubscribe() {
	key := "runtimeprojects.runtimeproject.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *runtimeprojectRuntimeprojectEdgeV1Chainer) IsSubscribed() bool {
	key := "runtimeprojects.runtimeproject.edge-orchestrator.intel.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *runtimeprojectRuntimeprojectEdgeV1Chainer) addCallback(obj *RuntimeprojectRuntimeProject) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["runtimefolders.runtimefolder.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("runtimefolders.runtimefolder.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[addCallback] received for runtimeprojects.runtimeproject.edge-orchestrator.intel.com name %s displayName %s parent runtimefolders.runtimefolder.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	AddChild("runtimefolders.runtimefolder.edge-orchestrator.intel.com", parentHashName, "runtimeprojects.runtimeproject.edge-orchestrator.intel.com", obj.Name)
}

func (c *runtimeprojectRuntimeprojectEdgeV1Chainer) deleteCallback(obj *RuntimeprojectRuntimeProject) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["runtimefolders.runtimefolder.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("runtimefolders.runtimefolder.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[deleteCallback] received for runtimeprojects.runtimeproject.edge-orchestrator.intel.com name %s displayName %s parent runtimefolders.runtimefolder.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	RemoveChild("runtimefolders.runtimefolder.edge-orchestrator.intel.com", parentHashName, "runtimeprojects.runtimeproject.edge-orchestrator.intel.com", obj.Name)
}

func (c *runtimeprojectRuntimeprojectEdgeV1Chainer) RegisterEventHandler(addCB func(obj *RuntimeprojectRuntimeProject), updateCB func(oldObj, newObj *RuntimeprojectRuntimeProject), deleteCB func(obj *RuntimeprojectRuntimeProject)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for RuntimeprojectRuntimeProject")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "runtimeprojects.runtimeproject.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimeprojectRuntimeProject")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimeprojectRuntimeProject, so creating a new one")
		informer = informerruntimeprojectedgeorchestratorintelcomv1.NewRuntimeProjectInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RuntimeprojectRuntimeProject{
				client:         c.client,
				RuntimeProject: obj.(*baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject),
			}
			logger.Debugf("[RegisterEventHandler AddFunc] Got Add event for runtimeprojects.runtimeproject.edge-orchestrator.intel.com name %s", nc.RuntimeProject.Name)

			var parent *RuntimefolderRuntimeFolder
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimefolders.runtimefolder.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimefolders.runtimefolder.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtimefolder().ForceReadRuntimeFolderByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("runtimefolders.runtimefolder.edge-orchestrator.intel.com", parent.Name, "runtimeprojects.runtimeproject.edge-orchestrator.intel.com", nc.Name) {
				AddChild("runtimefolders.runtimefolder.edge-orchestrator.intel.com", parent.Name, "runtimeprojects.runtimeproject.edge-orchestrator.intel.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RuntimeprojectRuntimeProject{
				client:         c.client,
				RuntimeProject: oldObj.(*baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject),
			}
			newData := &RuntimeprojectRuntimeProject{
				client:         c.client,
				RuntimeProject: newObj.(*baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject),
			}
			logger.Debugf("[RegisterEventHandler UpdateFunc] Got Update event for runtimeprojects.runtimeproject.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.RuntimeProject.Name, oldData.ResourceVersion, newData.ResourceVersion)
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &RuntimeprojectRuntimeProject{
				client:         c.client,
				RuntimeProject: obj.(*baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject),
			}
			logger.Debugf("[RegisterEventHandler DeleteFunc] Got Delete event for runtimeprojects.runtimeproject.edge-orchestrator.intel.com name %s", nc.RuntimeProject.Name)

			var parent *RuntimefolderRuntimeFolder
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimefolders.runtimefolder.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimefolders.runtimefolder.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtimefolder().ForceReadRuntimeFolderByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("runtimefolders.runtimefolder.edge-orchestrator.intel.com", parent.Name, "runtimeprojects.runtimeproject.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("runtimefolders.runtimefolder.edge-orchestrator.intel.com", parent.Name, "runtimeprojects.runtimeproject.edge-orchestrator.intel.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *runtimeprojectRuntimeprojectEdgeV1Chainer) RegisterAddCallback(cbfn func(obj *RuntimeprojectRuntimeProject)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterAddCallback] Received for RuntimeprojectRuntimeProject")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "runtimeprojects.runtimeproject.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimeprojectRuntimeProject")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimeprojectRuntimeProject, so creating a new one")
		informer = informerruntimeprojectedgeorchestratorintelcomv1.NewRuntimeProjectInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RuntimeprojectRuntimeProject{
				client:         c.client,
				RuntimeProject: obj.(*baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject),
			}
			logger.Debugf("[RegisterAddCallback] Got Add event for runtimeprojects.runtimeproject.edge-orchestrator.intel.com name %s", nc.RuntimeProject.Name)

			var parent *RuntimefolderRuntimeFolder
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimefolders.runtimefolder.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimefolders.runtimefolder.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtimefolder().ForceReadRuntimeFolderByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("runtimefolders.runtimefolder.edge-orchestrator.intel.com", parent.Name, "runtimeprojects.runtimeproject.edge-orchestrator.intel.com", nc.Name) {
				AddChild("runtimefolders.runtimefolder.edge-orchestrator.intel.com", parent.Name, "runtimeprojects.runtimeproject.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *runtimeprojectRuntimeprojectEdgeV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *RuntimeprojectRuntimeProject)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterUpdateCallback] Received for RuntimeprojectRuntimeProject")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "runtimeprojects.runtimeproject.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimeprojectRuntimeProject")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimeprojectRuntimeProject, so creating a new one")
		informer = informerruntimeprojectedgeorchestratorintelcomv1.NewRuntimeProjectInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RuntimeprojectRuntimeProject{
				client:         c.client,
				RuntimeProject: oldObj.(*baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject),
			}
			newData := &RuntimeprojectRuntimeProject{
				client:         c.client,
				RuntimeProject: newObj.(*baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject),
			}
			logger.Debugf("[RegisterUpdateCallback] Got Update event for runtimeprojects.runtimeproject.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.RuntimeProject.Name, oldData.ResourceVersion, newData.ResourceVersion)
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *runtimeprojectRuntimeprojectEdgeV1Chainer) RegisterDeleteCallback(cbfn func(obj *RuntimeprojectRuntimeProject)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterDeleteCallback] Received for RuntimeprojectRuntimeProject")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "runtimeprojects.runtimeproject.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimeprojectRuntimeProject")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimeprojectRuntimeProject, so creating a new one")
		informer = informerruntimeprojectedgeorchestratorintelcomv1.NewRuntimeProjectInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &RuntimeprojectRuntimeProject{
				client:         c.client,
				RuntimeProject: obj.(*baseruntimeprojectedgeorchestratorintelcomv1.RuntimeProject),
			}
			logger.Debugf("[RegisterDeleteCallback] Got Delete event for runtimeprojects.runtimeproject.edge-orchestrator.intel.com name %s", nc.RuntimeProject.Name)

			var parent *RuntimefolderRuntimeFolder
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("runtimefolders.runtimefolder.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimefolders.runtimefolder.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtimefolder().ForceReadRuntimeFolderByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("runtimefolders.runtimefolder.edge-orchestrator.intel.com", parent.Name, "runtimeprojects.runtimeproject.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("runtimefolders.runtimefolder.edge-orchestrator.intel.com", parent.Name, "runtimeprojects.runtimeproject.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *runtimeprojectRuntimeprojectEdgeV1Chainer) ActiveWatchers(name string) *projectactivewatcherProjectactivewatcherEdgeV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com"] = name
	return &projectactivewatcherProjectactivewatcherEdgeV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetActiveWatchers calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *runtimeprojectRuntimeprojectEdgeV1Chainer) GetActiveWatchers(ctx context.Context, displayName string) (result *ProjectactivewatcherProjectActiveWatcher, err error) {
	hashedName := helper.GetHashedName("projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", c.parentLabels, displayName)
	logger.Debugf("[GetActiveWatchers] using chainer for name %s, displayName %s, labels %#v", hashedName, displayName, c.parentLabels)
	return c.client.Projectactivewatcher().GetProjectActiveWatcherByName(ctx, hashedName)
}

// AddActiveWatchers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimeprojectRuntimeprojectEdgeV1Chainer) AddActiveWatchers(ctx context.Context,
	objToCreate *baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher) (result *ProjectactivewatcherProjectActiveWatcher, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName("projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Projectactivewatcher().CreateProjectActiveWatcherByName(ctx, objToCreate)
}

// DeleteActiveWatchers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimeprojectRuntimeprojectEdgeV1Chainer) DeleteActiveWatchers(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IsNameHashedLabel] = "true"
	hashedName := helper.GetHashedName("projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", c.parentLabels, name)
	return c.client.Projectactivewatcher().DeleteProjectActiveWatcherByName(ctx, hashedName)
}

func (group *ProjectactivewatcherEdgeV1) GetProjectActiveWatcherChildrenMap() map[string]baseprojectactivewatcheredgeorchestratorintelcomv1.Child {
	return map[string]baseprojectactivewatcheredgeorchestratorintelcomv1.Child{}
}

func (group *ProjectactivewatcherEdgeV1) GetProjectActiveWatcherChild(grp, kind, name string) baseprojectactivewatcheredgeorchestratorintelcomv1.Child {
	return baseprojectactivewatcheredgeorchestratorintelcomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetProjectActiveWatcherByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ProjectactivewatcherEdgeV1) GetProjectActiveWatcherByName(ctx context.Context, hashedName string) (*ProjectactivewatcherProjectActiveWatcher, error) {
	key := "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			logger.Debugf("[GetProjectActiveWatcherByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				logger.Fatalf("[GetProjectActiveWatcherByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher).ResourceVersion)
				if writeCacheVersionErr != nil {
					logger.Fatalf("[GetProjectActiveWatcherByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &ProjectactivewatcherProjectActiveWatcher{
					client:               group.client,
					ProjectActiveWatcher: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &ProjectactivewatcherProjectActiveWatcher{
				client:               group.client,
				ProjectActiveWatcher: resWrCache.(*baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ProjectactivewatcherEdgeV1().
			ProjectActiveWatchers().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &ProjectactivewatcherProjectActiveWatcher{
				client:               group.client,
				ProjectActiveWatcher: result,
			}, nil
		} else if errors.IsNotFound(err) {
			logger.Debugf("[GetProjectActiveWatcherByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on Get ProjectActiveWatchers: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[GetProjectActiveWatcherByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[GetProjectActiveWatcherByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadProjectActiveWatcherByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ProjectactivewatcherEdgeV1) ForceReadProjectActiveWatcherByName(ctx context.Context, hashedName string) (*ProjectactivewatcherProjectActiveWatcher, error) {
	logger.Debugf("[ForceReadProjectActiveWatcherByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ProjectactivewatcherEdgeV1().
			ProjectActiveWatchers().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[ForceReadProjectActiveWatcherByName] Failed to Get ProjectActiveWatchers: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max Retry exceed on Get ProjectActiveWatchers: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[ForceReadProjectActiveWatcherByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[ForceReadProjectActiveWatcherByName]: %+v", err)
				return nil, err
			}
		} else {
			logger.Debugf("[ForceReadProjectActiveWatcherByName] Executed Successfully :%s", hashedName)
			return &ProjectactivewatcherProjectActiveWatcher{
				client:               group.client,
				ProjectActiveWatcher: result,
			}, nil
		}
	}
}

// DeleteProjectActiveWatcherByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ProjectactivewatcherEdgeV1) DeleteProjectActiveWatcherByName(ctx context.Context, hashedName string) (err error) {
	logger.Debugf("[DeleteProjectActiveWatcherByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ProjectactivewatcherEdgeV1().
			ProjectActiveWatchers().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[DeleteProjectActiveWatcherByName] Failed to get ProjectActiveWatchers: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on get ProjectActiveWatchers: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteProjectActiveWatcherByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteProjectActiveWatcherByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteProjectActiveWatcherByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			ProjectactivewatcherEdgeV1().
			ProjectActiveWatchers().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			logger.Errorf("[DeleteProjectActiveWatcherByName] failed to delete ProjectActiveWatchers: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on delete ProjectActiveWatchers: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteProjectActiveWatcherByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteProjectActiveWatcherByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteProjectActiveWatcherByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	logger.Debugf("[DeleteProjectActiveWatcherByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimeprojects.runtimeproject.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	if result.GetLabels() != nil {
		if parents[common.IsNameHashedLabel] == "true" {
			parentName = helper.GetHashedName("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", parents, parentName)
	}
	RemoveChild("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", parentName, "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", hashedName)

	return nil
}

// CreateProjectActiveWatcherByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ProjectactivewatcherEdgeV1) CreateProjectActiveWatcherByName(ctx context.Context,
	objToCreate *baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher) (*ProjectactivewatcherProjectActiveWatcher, error) {
	logger.Debugf("[CreateProjectActiveWatcherByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DisplayNameLabel]; !ok {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ProjectactivewatcherEdgeV1().
			ProjectActiveWatchers().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			logger.Errorf("[CreateProjectActiveWatcherByName] Failed to create ProjectActiveWatcher: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on create ProjectActiveWatcher: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[CreateProjectActiveWatcherByName] context canceled while creating ProjectActiveWatcher: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				logger.Debugf("[CreateProjectActiveWatcherByName] ProjectActiveWatcher: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.ProjectactivewatcherEdgeV1().ProjectActiveWatchers().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					logger.Fatalf("[CreateProjectActiveWatcherByName] Unable to Get ProjectActiveWatcher %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				logger.Errorf("[CreateProjectActiveWatcherByName] found unexpected error while creating ProjectActiveWatcher: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			logger.Debugf("[CreateProjectActiveWatcherByName] ProjectActiveWatcher: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[CreateProjectActiveWatcherByName] ProjectActiveWatcher: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["runtimeprojects.runtimeproject.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	parentHashedName := helper.GetHashedName("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", objToCreate.GetLabels(), parentName)

	AddChild("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", parentHashedName, "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", objToCreate.Name)

	logger.Debugf("[CreateProjectActiveWatcherByName] Executed Successfully: %s", objToCreate.GetName())
	return &ProjectactivewatcherProjectActiveWatcher{
		client:               group.client,
		ProjectActiveWatcher: result,
	}, nil
}

// UpdateProjectActiveWatcherByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ProjectactivewatcherEdgeV1) UpdateProjectActiveWatcherByName(ctx context.Context,
	objToUpdate *baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher) (*ProjectactivewatcherProjectActiveWatcher, error) {
	logger.Debugf("[UpdateProjectActiveWatcherByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Projectactivewatcher().GetProjectActiveWatcherByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IsNameHashedLabel] = current.Labels[common.IsNameHashedLabel]
			objToUpdate.Labels[common.DisplayNameLabel] = current.Labels[common.DisplayNameLabel]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.StatusIndicator)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.StatusIndicator).IsNil() {
			patchValueStatusIndicator := objToUpdate.Spec.StatusIndicator
			patchOpStatusIndicator := PatchOp{
				Op:    "replace",
				Path:  "/spec/statusIndicator",
				Value: patchValueStatusIndicator,
			}
			patch = append(patch, patchOpStatusIndicator)
		}
	} else {
		patchValueStatusIndicator := objToUpdate.Spec.StatusIndicator
		patchOpStatusIndicator := PatchOp{
			Op:    "replace",
			Path:  "/spec/statusIndicator",
			Value: patchValueStatusIndicator,
		}
		patch = append(patch, patchOpStatusIndicator)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Message)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Message).IsNil() {
			patchValueMessage := objToUpdate.Spec.Message
			patchOpMessage := PatchOp{
				Op:    "replace",
				Path:  "/spec/message",
				Value: patchValueMessage,
			}
			patch = append(patch, patchOpMessage)
		}
	} else {
		patchValueMessage := objToUpdate.Spec.Message
		patchOpMessage := PatchOp{
			Op:    "replace",
			Path:  "/spec/message",
			Value: patchValueMessage,
		}
		patch = append(patch, patchOpMessage)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.TimeStamp)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.TimeStamp).IsNil() {
			patchValueTimeStamp := objToUpdate.Spec.TimeStamp
			patchOpTimeStamp := PatchOp{
				Op:    "replace",
				Path:  "/spec/timeStamp",
				Value: patchValueTimeStamp,
			}
			patch = append(patch, patchOpTimeStamp)
		}
	} else {
		patchValueTimeStamp := objToUpdate.Spec.TimeStamp
		patchOpTimeStamp := PatchOp{
			Op:    "replace",
			Path:  "/spec/timeStamp",
			Value: patchValueTimeStamp,
		}
		patch = append(patch, patchOpTimeStamp)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			ProjectactivewatcherEdgeV1().
			ProjectActiveWatchers().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			logger.Errorf("[UpdateProjectActiveWatcherByName] Failed to patch ProjectActiveWatcher %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					logger.Debugf("Trigger ProjectActiveWatcher Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteProjectActiveWatcherByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						logger.Debugf("Error occur while deleting ProjectActiveWatcher: %s", objToUpdate.GetName())
						return nil, delErr
					}
					logger.Debugf("ProjectActiveWatcher deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[UpdateProjectActiveWatcherByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				logger.Errorf("[UpdateProjectActiveWatcherByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				logger.Debugf("Trigger ProjectActiveWatcher Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteProjectActiveWatcherByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					logger.Debugf("Error occur while deleting ProjectActiveWatcher: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				logger.Debugf("ProjectActiveWatcher Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			logger.Debugf("[UpdateProjectActiveWatcherByName] Patch ProjectActiveWatcher Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[UpdateProjectActiveWatcherByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	logger.Debugf("[UpdateProjectActiveWatcherByName] Executed Successfully %s", objToUpdate.GetName())
	return &ProjectactivewatcherProjectActiveWatcher{
		client:               group.client,
		ProjectActiveWatcher: result,
	}, nil
}

// ListProjectActiveWatchers returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ProjectactivewatcherEdgeV1) ListProjectActiveWatchers(ctx context.Context,
	opts metav1.ListOptions) (result []*ProjectactivewatcherProjectActiveWatcher, err error) {
	key := "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*ProjectactivewatcherProjectActiveWatcher, len(items))
		for k, v := range items {
			item, _ := v.(*baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher)
			result[k] = &ProjectactivewatcherProjectActiveWatcher{
				client:               group.client,
				ProjectActiveWatcher: item,
			}
		}
	} else {
		list, err := group.client.baseClient.ProjectactivewatcherEdgeV1().
			ProjectActiveWatchers().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*ProjectactivewatcherProjectActiveWatcher, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &ProjectactivewatcherProjectActiveWatcher{
				client:               group.client,
				ProjectActiveWatcher: &item,
			}
		}
	}
	return
}

type ProjectactivewatcherProjectActiveWatcher struct {
	client *Clientset
	*baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher
}

// Delete removes obj and all it's children from the database.
func (obj *ProjectactivewatcherProjectActiveWatcher) Delete(ctx context.Context) error {
	err := obj.client.Projectactivewatcher().DeleteProjectActiveWatcherByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.ProjectActiveWatcher = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ProjectactivewatcherProjectActiveWatcher) Update(ctx context.Context) error {
	result, err := obj.client.Projectactivewatcher().UpdateProjectActiveWatcherByName(ctx, obj.ProjectActiveWatcher)
	if err != nil {
		return err
	}
	obj.ProjectActiveWatcher = result.ProjectActiveWatcher
	return nil
}

func (obj *ProjectactivewatcherProjectActiveWatcher) GetParent(ctx context.Context) (result *RuntimeprojectRuntimeProject, err error) {
	hashedName := helper.GetHashedName("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", obj.Labels, obj.Labels["runtimeprojects.runtimeproject.edge-orchestrator.intel.com"])
	logger.Debugf("[GetParent] Get parent of ProjectactivewatcherProjectActiveWatcher name %s [labels %#v] of parent type runtimeprojects.runtimeproject.edge-orchestrator.intel.com and name %s", obj.Name, obj.Labels, hashedName)
	return obj.client.Runtimeproject().GetRuntimeProjectByName(ctx, hashedName)
}

type projectactivewatcherProjectactivewatcherEdgeV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *projectactivewatcherProjectactivewatcherEdgeV1Chainer) Subscribe() {
	key := "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerprojectactivewatcheredgeorchestratorintelcomv1.NewProjectActiveWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *projectactivewatcherProjectactivewatcherEdgeV1Chainer) Unsubscribe() {
	key := "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *projectactivewatcherProjectactivewatcherEdgeV1Chainer) IsSubscribed() bool {
	key := "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *projectactivewatcherProjectactivewatcherEdgeV1Chainer) addCallback(obj *ProjectactivewatcherProjectActiveWatcher) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["runtimeprojects.runtimeproject.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[addCallback] received for projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com name %s displayName %s parent runtimeprojects.runtimeproject.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	AddChild("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", parentHashName, "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", obj.Name)
}

func (c *projectactivewatcherProjectactivewatcherEdgeV1Chainer) deleteCallback(obj *ProjectactivewatcherProjectActiveWatcher) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["runtimeprojects.runtimeproject.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[deleteCallback] received for projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com name %s displayName %s parent runtimeprojects.runtimeproject.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	RemoveChild("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", parentHashName, "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", obj.Name)
}

func (c *projectactivewatcherProjectactivewatcherEdgeV1Chainer) RegisterEventHandler(addCB func(obj *ProjectactivewatcherProjectActiveWatcher), updateCB func(oldObj, newObj *ProjectactivewatcherProjectActiveWatcher), deleteCB func(obj *ProjectactivewatcherProjectActiveWatcher)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for ProjectactivewatcherProjectActiveWatcher")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ProjectactivewatcherProjectActiveWatcher")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ProjectactivewatcherProjectActiveWatcher, so creating a new one")
		informer = informerprojectactivewatcheredgeorchestratorintelcomv1.NewProjectActiveWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ProjectactivewatcherProjectActiveWatcher{
				client:               c.client,
				ProjectActiveWatcher: obj.(*baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher),
			}
			logger.Debugf("[RegisterEventHandler AddFunc] Got Add event for projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com name %s", nc.ProjectActiveWatcher.Name)

			var parent *RuntimeprojectRuntimeProject
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimeprojects.runtimeproject.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtimeproject().ForceReadRuntimeProjectByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", parent.Name, "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", nc.Name) {
				AddChild("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", parent.Name, "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ProjectactivewatcherProjectActiveWatcher{
				client:               c.client,
				ProjectActiveWatcher: oldObj.(*baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher),
			}
			newData := &ProjectactivewatcherProjectActiveWatcher{
				client:               c.client,
				ProjectActiveWatcher: newObj.(*baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher),
			}
			logger.Debugf("[RegisterEventHandler UpdateFunc] Got Update event for projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.ProjectActiveWatcher.Name, oldData.ResourceVersion, newData.ResourceVersion)
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &ProjectactivewatcherProjectActiveWatcher{
				client:               c.client,
				ProjectActiveWatcher: obj.(*baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher),
			}
			logger.Debugf("[RegisterEventHandler DeleteFunc] Got Delete event for projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com name %s", nc.ProjectActiveWatcher.Name)

			var parent *RuntimeprojectRuntimeProject
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimeprojects.runtimeproject.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtimeproject().ForceReadRuntimeProjectByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", parent.Name, "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", parent.Name, "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *projectactivewatcherProjectactivewatcherEdgeV1Chainer) RegisterAddCallback(cbfn func(obj *ProjectactivewatcherProjectActiveWatcher)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterAddCallback] Received for ProjectactivewatcherProjectActiveWatcher")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ProjectactivewatcherProjectActiveWatcher")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ProjectactivewatcherProjectActiveWatcher, so creating a new one")
		informer = informerprojectactivewatcheredgeorchestratorintelcomv1.NewProjectActiveWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ProjectactivewatcherProjectActiveWatcher{
				client:               c.client,
				ProjectActiveWatcher: obj.(*baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher),
			}
			logger.Debugf("[RegisterAddCallback] Got Add event for projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com name %s", nc.ProjectActiveWatcher.Name)

			var parent *RuntimeprojectRuntimeProject
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimeprojects.runtimeproject.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtimeproject().ForceReadRuntimeProjectByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", parent.Name, "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", nc.Name) {
				AddChild("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", parent.Name, "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *projectactivewatcherProjectactivewatcherEdgeV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *ProjectactivewatcherProjectActiveWatcher)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterUpdateCallback] Received for ProjectactivewatcherProjectActiveWatcher")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ProjectactivewatcherProjectActiveWatcher")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ProjectactivewatcherProjectActiveWatcher, so creating a new one")
		informer = informerprojectactivewatcheredgeorchestratorintelcomv1.NewProjectActiveWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ProjectactivewatcherProjectActiveWatcher{
				client:               c.client,
				ProjectActiveWatcher: oldObj.(*baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher),
			}
			newData := &ProjectactivewatcherProjectActiveWatcher{
				client:               c.client,
				ProjectActiveWatcher: newObj.(*baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher),
			}
			logger.Debugf("[RegisterUpdateCallback] Got Update event for projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.ProjectActiveWatcher.Name, oldData.ResourceVersion, newData.ResourceVersion)
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *projectactivewatcherProjectactivewatcherEdgeV1Chainer) RegisterDeleteCallback(cbfn func(obj *ProjectactivewatcherProjectActiveWatcher)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterDeleteCallback] Received for ProjectactivewatcherProjectActiveWatcher")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ProjectactivewatcherProjectActiveWatcher")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ProjectactivewatcherProjectActiveWatcher, so creating a new one")
		informer = informerprojectactivewatcheredgeorchestratorintelcomv1.NewProjectActiveWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &ProjectactivewatcherProjectActiveWatcher{
				client:               c.client,
				ProjectActiveWatcher: obj.(*baseprojectactivewatcheredgeorchestratorintelcomv1.ProjectActiveWatcher),
			}
			logger.Debugf("[RegisterDeleteCallback] Got Delete event for projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com name %s", nc.ProjectActiveWatcher.Name)

			var parent *RuntimeprojectRuntimeProject
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimeprojects.runtimeproject.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtimeproject().ForceReadRuntimeProjectByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", parent.Name, "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("runtimeprojects.runtimeproject.edge-orchestrator.intel.com", parent.Name, "projectactivewatchers.projectactivewatcher.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (group *OrgactivewatcherEdgeV1) GetOrgActiveWatcherChildrenMap() map[string]baseorgactivewatcheredgeorchestratorintelcomv1.Child {
	return map[string]baseorgactivewatcheredgeorchestratorintelcomv1.Child{}
}

func (group *OrgactivewatcherEdgeV1) GetOrgActiveWatcherChild(grp, kind, name string) baseorgactivewatcheredgeorchestratorintelcomv1.Child {
	return baseorgactivewatcheredgeorchestratorintelcomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetOrgActiveWatcherByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *OrgactivewatcherEdgeV1) GetOrgActiveWatcherByName(ctx context.Context, hashedName string) (*OrgactivewatcherOrgActiveWatcher, error) {
	key := "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			logger.Debugf("[GetOrgActiveWatcherByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				logger.Fatalf("[GetOrgActiveWatcherByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher).ResourceVersion)
				if writeCacheVersionErr != nil {
					logger.Fatalf("[GetOrgActiveWatcherByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &OrgactivewatcherOrgActiveWatcher{
					client:           group.client,
					OrgActiveWatcher: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &OrgactivewatcherOrgActiveWatcher{
				client:           group.client,
				OrgActiveWatcher: resWrCache.(*baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			OrgactivewatcherEdgeV1().
			OrgActiveWatchers().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &OrgactivewatcherOrgActiveWatcher{
				client:           group.client,
				OrgActiveWatcher: result,
			}, nil
		} else if errors.IsNotFound(err) {
			logger.Debugf("[GetOrgActiveWatcherByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on Get OrgActiveWatchers: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[GetOrgActiveWatcherByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[GetOrgActiveWatcherByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadOrgActiveWatcherByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *OrgactivewatcherEdgeV1) ForceReadOrgActiveWatcherByName(ctx context.Context, hashedName string) (*OrgactivewatcherOrgActiveWatcher, error) {
	logger.Debugf("[ForceReadOrgActiveWatcherByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			OrgactivewatcherEdgeV1().
			OrgActiveWatchers().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[ForceReadOrgActiveWatcherByName] Failed to Get OrgActiveWatchers: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max Retry exceed on Get OrgActiveWatchers: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[ForceReadOrgActiveWatcherByName]: %+v", err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[ForceReadOrgActiveWatcherByName]: %+v", err)
				return nil, err
			}
		} else {
			logger.Debugf("[ForceReadOrgActiveWatcherByName] Executed Successfully :%s", hashedName)
			return &OrgactivewatcherOrgActiveWatcher{
				client:           group.client,
				OrgActiveWatcher: result,
			}, nil
		}
	}
}

// DeleteOrgActiveWatcherByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *OrgactivewatcherEdgeV1) DeleteOrgActiveWatcherByName(ctx context.Context, hashedName string) (err error) {
	logger.Debugf("[DeleteOrgActiveWatcherByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			OrgactivewatcherEdgeV1().
			OrgActiveWatchers().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[DeleteOrgActiveWatcherByName] Failed to get OrgActiveWatchers: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on get OrgActiveWatchers: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteOrgActiveWatcherByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteOrgActiveWatcherByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteOrgActiveWatcherByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			OrgactivewatcherEdgeV1().
			OrgActiveWatchers().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			logger.Errorf("[DeleteOrgActiveWatcherByName] failed to delete OrgActiveWatchers: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on delete OrgActiveWatchers: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[DeleteOrgActiveWatcherByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				logger.Errorf("[DeleteOrgActiveWatcherByName] Object: %s not found", hashedName)
				break
			} else {
				logger.Errorf("[DeleteOrgActiveWatcherByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	logger.Debugf("[DeleteOrgActiveWatcherByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	if result.GetLabels() != nil {
		if parents[common.IsNameHashedLabel] == "true" {
			parentName = helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parents, parentName)
	}
	RemoveChild("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parentName, "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", hashedName)

	return nil
}

// CreateOrgActiveWatcherByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *OrgactivewatcherEdgeV1) CreateOrgActiveWatcherByName(ctx context.Context,
	objToCreate *baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher) (*OrgactivewatcherOrgActiveWatcher, error) {
	logger.Debugf("[CreateOrgActiveWatcherByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DisplayNameLabel]; !ok {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			OrgactivewatcherEdgeV1().
			OrgActiveWatchers().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			logger.Errorf("[CreateOrgActiveWatcherByName] Failed to create OrgActiveWatcher: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on create OrgActiveWatcher: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[CreateOrgActiveWatcherByName] context canceled while creating OrgActiveWatcher: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				logger.Debugf("[CreateOrgActiveWatcherByName] OrgActiveWatcher: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.OrgactivewatcherEdgeV1().OrgActiveWatchers().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					logger.Fatalf("[CreateOrgActiveWatcherByName] Unable to Get OrgActiveWatcher %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				logger.Errorf("[CreateOrgActiveWatcherByName] found unexpected error while creating OrgActiveWatcher: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			logger.Debugf("[CreateOrgActiveWatcherByName] OrgActiveWatcher: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[CreateOrgActiveWatcherByName] OrgActiveWatcher: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"]
	if !ok {
		parentName = helper.DefaultKey
	}
	parentHashedName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", objToCreate.GetLabels(), parentName)

	AddChild("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parentHashedName, "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", objToCreate.Name)

	logger.Debugf("[CreateOrgActiveWatcherByName] Executed Successfully: %s", objToCreate.GetName())
	return &OrgactivewatcherOrgActiveWatcher{
		client:           group.client,
		OrgActiveWatcher: result,
	}, nil
}

// UpdateOrgActiveWatcherByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *OrgactivewatcherEdgeV1) UpdateOrgActiveWatcherByName(ctx context.Context,
	objToUpdate *baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher) (*OrgactivewatcherOrgActiveWatcher, error) {
	logger.Debugf("[UpdateOrgActiveWatcherByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Orgactivewatcher().GetOrgActiveWatcherByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IsNameHashedLabel] = current.Labels[common.IsNameHashedLabel]
			objToUpdate.Labels[common.DisplayNameLabel] = current.Labels[common.DisplayNameLabel]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
		patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.StatusIndicator)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.StatusIndicator).IsNil() {
			patchValueStatusIndicator := objToUpdate.Spec.StatusIndicator
			patchOpStatusIndicator := PatchOp{
				Op:    "replace",
				Path:  "/spec/statusIndicator",
				Value: patchValueStatusIndicator,
			}
			patch = append(patch, patchOpStatusIndicator)
		}
	} else {
		patchValueStatusIndicator := objToUpdate.Spec.StatusIndicator
		patchOpStatusIndicator := PatchOp{
			Op:    "replace",
			Path:  "/spec/statusIndicator",
			Value: patchValueStatusIndicator,
		}
		patch = append(patch, patchOpStatusIndicator)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Message)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Message).IsNil() {
			patchValueMessage := objToUpdate.Spec.Message
			patchOpMessage := PatchOp{
				Op:    "replace",
				Path:  "/spec/message",
				Value: patchValueMessage,
			}
			patch = append(patch, patchOpMessage)
		}
	} else {
		patchValueMessage := objToUpdate.Spec.Message
		patchOpMessage := PatchOp{
			Op:    "replace",
			Path:  "/spec/message",
			Value: patchValueMessage,
		}
		patch = append(patch, patchOpMessage)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.TimeStamp)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.TimeStamp).IsNil() {
			patchValueTimeStamp := objToUpdate.Spec.TimeStamp
			patchOpTimeStamp := PatchOp{
				Op:    "replace",
				Path:  "/spec/timeStamp",
				Value: patchValueTimeStamp,
			}
			patch = append(patch, patchOpTimeStamp)
		}
	} else {
		patchValueTimeStamp := objToUpdate.Spec.TimeStamp
		patchOpTimeStamp := PatchOp{
			Op:    "replace",
			Path:  "/spec/timeStamp",
			Value: patchValueTimeStamp,
		}
		patch = append(patch, patchOpTimeStamp)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			OrgactivewatcherEdgeV1().
			OrgActiveWatchers().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			logger.Errorf("[UpdateOrgActiveWatcherByName] Failed to patch OrgActiveWatcher %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					logger.Debugf("Trigger OrgActiveWatcher Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteOrgActiveWatcherByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						logger.Debugf("Error occur while deleting OrgActiveWatcher: %s", objToUpdate.GetName())
						return nil, delErr
					}
					logger.Debugf("OrgActiveWatcher deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				logger.Errorf("[UpdateOrgActiveWatcherByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				logger.Errorf("[UpdateOrgActiveWatcherByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				logger.Debugf("Trigger OrgActiveWatcher Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteOrgActiveWatcherByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					logger.Debugf("Error occur while deleting OrgActiveWatcher: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				logger.Debugf("OrgActiveWatcher Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			logger.Debugf("[UpdateOrgActiveWatcherByName] Patch OrgActiveWatcher Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com"); ok {
				logger.Debugf("[UpdateOrgActiveWatcherByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	logger.Debugf("[UpdateOrgActiveWatcherByName] Executed Successfully %s", objToUpdate.GetName())
	return &OrgactivewatcherOrgActiveWatcher{
		client:           group.client,
		OrgActiveWatcher: result,
	}, nil
}

// ListOrgActiveWatchers returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *OrgactivewatcherEdgeV1) ListOrgActiveWatchers(ctx context.Context,
	opts metav1.ListOptions) (result []*OrgactivewatcherOrgActiveWatcher, err error) {
	key := "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*OrgactivewatcherOrgActiveWatcher, len(items))
		for k, v := range items {
			item, _ := v.(*baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher)
			result[k] = &OrgactivewatcherOrgActiveWatcher{
				client:           group.client,
				OrgActiveWatcher: item,
			}
		}
	} else {
		list, err := group.client.baseClient.OrgactivewatcherEdgeV1().
			OrgActiveWatchers().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*OrgactivewatcherOrgActiveWatcher, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &OrgactivewatcherOrgActiveWatcher{
				client:           group.client,
				OrgActiveWatcher: &item,
			}
		}
	}
	return
}

type OrgactivewatcherOrgActiveWatcher struct {
	client *Clientset
	*baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher
}

// Delete removes obj and all it's children from the database.
func (obj *OrgactivewatcherOrgActiveWatcher) Delete(ctx context.Context) error {
	err := obj.client.Orgactivewatcher().DeleteOrgActiveWatcherByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.OrgActiveWatcher = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *OrgactivewatcherOrgActiveWatcher) Update(ctx context.Context) error {
	result, err := obj.client.Orgactivewatcher().UpdateOrgActiveWatcherByName(ctx, obj.OrgActiveWatcher)
	if err != nil {
		return err
	}
	obj.OrgActiveWatcher = result.OrgActiveWatcher
	return nil
}

func (obj *OrgactivewatcherOrgActiveWatcher) GetParent(ctx context.Context) (result *RuntimeorgRuntimeOrg, err error) {
	hashedName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", obj.Labels, obj.Labels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"])
	logger.Debugf("[GetParent] Get parent of OrgactivewatcherOrgActiveWatcher name %s [labels %#v] of parent type runtimeorgs.runtimeorg.edge-orchestrator.intel.com and name %s", obj.Name, obj.Labels, hashedName)
	return obj.client.Runtimeorg().GetRuntimeOrgByName(ctx, hashedName)
}

type orgactivewatcherOrgactivewatcherEdgeV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *orgactivewatcherOrgactivewatcherEdgeV1Chainer) Subscribe() {
	key := "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerorgactivewatcheredgeorchestratorintelcomv1.NewOrgActiveWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *orgactivewatcherOrgactivewatcherEdgeV1Chainer) Unsubscribe() {
	key := "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *orgactivewatcherOrgactivewatcherEdgeV1Chainer) IsSubscribed() bool {
	key := "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *orgactivewatcherOrgactivewatcherEdgeV1Chainer) addCallback(obj *OrgactivewatcherOrgActiveWatcher) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[addCallback] received for orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com name %s displayName %s parent runtimeorgs.runtimeorg.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	AddChild("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parentHashName, "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", obj.Name)
}

func (c *orgactivewatcherOrgactivewatcherEdgeV1Chainer) deleteCallback(obj *OrgactivewatcherOrgActiveWatcher) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", obj.Labels, parentDisplayName)
	logger.Debugf("[deleteCallback] received for orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com name %s displayName %s parent runtimeorgs.runtimeorg.edge-orchestrator.intel.com name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	RemoveChild("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parentHashName, "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", obj.Name)
}

func (c *orgactivewatcherOrgactivewatcherEdgeV1Chainer) RegisterEventHandler(addCB func(obj *OrgactivewatcherOrgActiveWatcher), updateCB func(oldObj, newObj *OrgactivewatcherOrgActiveWatcher), deleteCB func(obj *OrgactivewatcherOrgActiveWatcher)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for OrgactivewatcherOrgActiveWatcher")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for OrgactivewatcherOrgActiveWatcher")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for OrgactivewatcherOrgActiveWatcher, so creating a new one")
		informer = informerorgactivewatcheredgeorchestratorintelcomv1.NewOrgActiveWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &OrgactivewatcherOrgActiveWatcher{
				client:           c.client,
				OrgActiveWatcher: obj.(*baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher),
			}
			logger.Debugf("[RegisterEventHandler AddFunc] Got Add event for orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com name %s", nc.OrgActiveWatcher.Name)

			var parent *RuntimeorgRuntimeOrg
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtimeorg().ForceReadRuntimeOrgByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parent.Name, "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", nc.Name) {
				AddChild("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parent.Name, "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &OrgactivewatcherOrgActiveWatcher{
				client:           c.client,
				OrgActiveWatcher: oldObj.(*baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher),
			}
			newData := &OrgactivewatcherOrgActiveWatcher{
				client:           c.client,
				OrgActiveWatcher: newObj.(*baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher),
			}
			logger.Debugf("[RegisterEventHandler UpdateFunc] Got Update event for orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.OrgActiveWatcher.Name, oldData.ResourceVersion, newData.ResourceVersion)
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &OrgactivewatcherOrgActiveWatcher{
				client:           c.client,
				OrgActiveWatcher: obj.(*baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher),
			}
			logger.Debugf("[RegisterEventHandler DeleteFunc] Got Delete event for orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com name %s", nc.OrgActiveWatcher.Name)

			var parent *RuntimeorgRuntimeOrg
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtimeorg().ForceReadRuntimeOrgByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parent.Name, "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parent.Name, "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *orgactivewatcherOrgactivewatcherEdgeV1Chainer) RegisterAddCallback(cbfn func(obj *OrgactivewatcherOrgActiveWatcher)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterAddCallback] Received for OrgactivewatcherOrgActiveWatcher")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for OrgactivewatcherOrgActiveWatcher")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for OrgactivewatcherOrgActiveWatcher, so creating a new one")
		informer = informerorgactivewatcheredgeorchestratorintelcomv1.NewOrgActiveWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &OrgactivewatcherOrgActiveWatcher{
				client:           c.client,
				OrgActiveWatcher: obj.(*baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher),
			}
			logger.Debugf("[RegisterAddCallback] Got Add event for orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com name %s", nc.OrgActiveWatcher.Name)

			var parent *RuntimeorgRuntimeOrg
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtimeorg().ForceReadRuntimeOrgByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parent.Name, "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", nc.Name) {
				AddChild("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parent.Name, "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *orgactivewatcherOrgactivewatcherEdgeV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *OrgactivewatcherOrgActiveWatcher)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterUpdateCallback] Received for OrgactivewatcherOrgActiveWatcher")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for OrgactivewatcherOrgActiveWatcher")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for OrgactivewatcherOrgActiveWatcher, so creating a new one")
		informer = informerorgactivewatcheredgeorchestratorintelcomv1.NewOrgActiveWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &OrgactivewatcherOrgActiveWatcher{
				client:           c.client,
				OrgActiveWatcher: oldObj.(*baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher),
			}
			newData := &OrgactivewatcherOrgActiveWatcher{
				client:           c.client,
				OrgActiveWatcher: newObj.(*baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher),
			}
			logger.Debugf("[RegisterUpdateCallback] Got Update event for orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com name %s old version %s new version %s", oldData.OrgActiveWatcher.Name, oldData.ResourceVersion, newData.ResourceVersion)
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *orgactivewatcherOrgactivewatcherEdgeV1Chainer) RegisterDeleteCallback(cbfn func(obj *OrgactivewatcherOrgActiveWatcher)) (cache.ResourceEventHandlerRegistration, error) {
	logger.Debugf("[RegisterDeleteCallback] Received for OrgactivewatcherOrgActiveWatcher")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for OrgactivewatcherOrgActiveWatcher")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for OrgactivewatcherOrgActiveWatcher, so creating a new one")
		informer = informerorgactivewatcheredgeorchestratorintelcomv1.NewOrgActiveWatcherInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &OrgactivewatcherOrgActiveWatcher{
				client:           c.client,
				OrgActiveWatcher: obj.(*baseorgactivewatcheredgeorchestratorintelcomv1.OrgActiveWatcher),
			}
			logger.Debugf("[RegisterDeleteCallback] Got Delete event for orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com name %s", nc.OrgActiveWatcher.Name)

			var parent *RuntimeorgRuntimeOrg
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", nc.Labels, nc.Labels["runtimeorgs.runtimeorg.edge-orchestrator.intel.com"])
				parent, err = c.client.Runtimeorg().ForceReadRuntimeOrgByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parent.Name, "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", nc.Name) {
				RemoveChild("runtimeorgs.runtimeorg.edge-orchestrator.intel.com", parent.Name, "orgactivewatchers.orgactivewatcher.edge-orchestrator.intel.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}
